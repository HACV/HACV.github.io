<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>网络编程复习基础（一） | HACV</title>
    <meta name="description" content="Personal Blog Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.8eb0d87d.css" as="style"><link rel="preload" href="/assets/js/app.5089c99b.js" as="script"><link rel="preload" href="/assets/js/56.bca0377b.js" as="script"><link rel="prefetch" href="/assets/js/10.83062f3e.js"><link rel="prefetch" href="/assets/js/100.e9dd2a62.js"><link rel="prefetch" href="/assets/js/101.058dd0c3.js"><link rel="prefetch" href="/assets/js/102.be50c287.js"><link rel="prefetch" href="/assets/js/103.0023ac84.js"><link rel="prefetch" href="/assets/js/104.8f0344c1.js"><link rel="prefetch" href="/assets/js/105.fabf715d.js"><link rel="prefetch" href="/assets/js/106.92e7f959.js"><link rel="prefetch" href="/assets/js/107.e0019d98.js"><link rel="prefetch" href="/assets/js/108.5cecf10e.js"><link rel="prefetch" href="/assets/js/109.60c9088e.js"><link rel="prefetch" href="/assets/js/11.fd079fa0.js"><link rel="prefetch" href="/assets/js/110.80f96942.js"><link rel="prefetch" href="/assets/js/111.7359b96d.js"><link rel="prefetch" href="/assets/js/112.6ff2eb5c.js"><link rel="prefetch" href="/assets/js/113.5bd0d6be.js"><link rel="prefetch" href="/assets/js/114.fcd48b8e.js"><link rel="prefetch" href="/assets/js/115.87479f2c.js"><link rel="prefetch" href="/assets/js/116.73afb388.js"><link rel="prefetch" href="/assets/js/117.12707880.js"><link rel="prefetch" href="/assets/js/118.3c888002.js"><link rel="prefetch" href="/assets/js/119.2b8e507d.js"><link rel="prefetch" href="/assets/js/12.d2cc7c71.js"><link rel="prefetch" href="/assets/js/120.c9726377.js"><link rel="prefetch" href="/assets/js/121.0b07e001.js"><link rel="prefetch" href="/assets/js/122.300fcd90.js"><link rel="prefetch" href="/assets/js/123.a36d2451.js"><link rel="prefetch" href="/assets/js/124.541fb6b3.js"><link rel="prefetch" href="/assets/js/125.d0136247.js"><link rel="prefetch" href="/assets/js/126.d97843dc.js"><link rel="prefetch" href="/assets/js/127.2c06054c.js"><link rel="prefetch" href="/assets/js/128.eda9b82d.js"><link rel="prefetch" href="/assets/js/13.777fd7b6.js"><link rel="prefetch" href="/assets/js/14.a6f7c2e5.js"><link rel="prefetch" href="/assets/js/15.3390a044.js"><link rel="prefetch" href="/assets/js/16.ab6fea6a.js"><link rel="prefetch" href="/assets/js/17.37ee5d55.js"><link rel="prefetch" href="/assets/js/18.861d8a04.js"><link rel="prefetch" href="/assets/js/19.343ef19e.js"><link rel="prefetch" href="/assets/js/2.7f88d577.js"><link rel="prefetch" href="/assets/js/20.001f65ab.js"><link rel="prefetch" href="/assets/js/21.f19ed332.js"><link rel="prefetch" href="/assets/js/22.dbb030dd.js"><link rel="prefetch" href="/assets/js/23.b8e5900d.js"><link rel="prefetch" href="/assets/js/24.950e82ab.js"><link rel="prefetch" href="/assets/js/25.4832ccbf.js"><link rel="prefetch" href="/assets/js/26.66c90346.js"><link rel="prefetch" href="/assets/js/27.24e09fe3.js"><link rel="prefetch" href="/assets/js/28.ff934f1e.js"><link rel="prefetch" href="/assets/js/29.0fa59da6.js"><link rel="prefetch" href="/assets/js/3.7b71185a.js"><link rel="prefetch" href="/assets/js/30.e877ce73.js"><link rel="prefetch" href="/assets/js/31.e9621816.js"><link rel="prefetch" href="/assets/js/32.9df427e2.js"><link rel="prefetch" href="/assets/js/33.2dff3432.js"><link rel="prefetch" href="/assets/js/34.619c43fe.js"><link rel="prefetch" href="/assets/js/35.0518fc24.js"><link rel="prefetch" href="/assets/js/36.03a6a11d.js"><link rel="prefetch" href="/assets/js/37.15440d6a.js"><link rel="prefetch" href="/assets/js/38.659b3cde.js"><link rel="prefetch" href="/assets/js/39.4e2ea8cc.js"><link rel="prefetch" href="/assets/js/4.468bbcf4.js"><link rel="prefetch" href="/assets/js/40.fb09ba94.js"><link rel="prefetch" href="/assets/js/41.6a89f4e5.js"><link rel="prefetch" href="/assets/js/42.ff367989.js"><link rel="prefetch" href="/assets/js/43.75d01778.js"><link rel="prefetch" href="/assets/js/44.92fe4422.js"><link rel="prefetch" href="/assets/js/45.abe7faa9.js"><link rel="prefetch" href="/assets/js/46.3ecdbe80.js"><link rel="prefetch" href="/assets/js/47.00507805.js"><link rel="prefetch" href="/assets/js/48.3298ff6e.js"><link rel="prefetch" href="/assets/js/49.51b2e104.js"><link rel="prefetch" href="/assets/js/5.e494e309.js"><link rel="prefetch" href="/assets/js/50.efcb1a1b.js"><link rel="prefetch" href="/assets/js/51.99ddff8e.js"><link rel="prefetch" href="/assets/js/52.98895c79.js"><link rel="prefetch" href="/assets/js/53.5b4fc45b.js"><link rel="prefetch" href="/assets/js/54.08788d4b.js"><link rel="prefetch" href="/assets/js/55.6e3dc863.js"><link rel="prefetch" href="/assets/js/57.a9032acb.js"><link rel="prefetch" href="/assets/js/58.1c089110.js"><link rel="prefetch" href="/assets/js/59.c0a0016f.js"><link rel="prefetch" href="/assets/js/6.fe5993d1.js"><link rel="prefetch" href="/assets/js/60.e9103768.js"><link rel="prefetch" href="/assets/js/61.80b548d8.js"><link rel="prefetch" href="/assets/js/62.93f5ea35.js"><link rel="prefetch" href="/assets/js/63.82d88f2a.js"><link rel="prefetch" href="/assets/js/64.992338a9.js"><link rel="prefetch" href="/assets/js/65.1db700e1.js"><link rel="prefetch" href="/assets/js/66.2d8ef155.js"><link rel="prefetch" href="/assets/js/67.8fc8788e.js"><link rel="prefetch" href="/assets/js/68.a7200ef1.js"><link rel="prefetch" href="/assets/js/69.b79d1eca.js"><link rel="prefetch" href="/assets/js/7.3abebc6b.js"><link rel="prefetch" href="/assets/js/70.c2e6da4c.js"><link rel="prefetch" href="/assets/js/71.93b54633.js"><link rel="prefetch" href="/assets/js/72.1b986e4d.js"><link rel="prefetch" href="/assets/js/73.066013ab.js"><link rel="prefetch" href="/assets/js/74.ac2ba170.js"><link rel="prefetch" href="/assets/js/75.b900dc1a.js"><link rel="prefetch" href="/assets/js/76.2085054d.js"><link rel="prefetch" href="/assets/js/77.01fe50f2.js"><link rel="prefetch" href="/assets/js/78.4edd0c08.js"><link rel="prefetch" href="/assets/js/79.3adedab7.js"><link rel="prefetch" href="/assets/js/8.3578d50a.js"><link rel="prefetch" href="/assets/js/80.9eefb8b1.js"><link rel="prefetch" href="/assets/js/81.0ee6ea25.js"><link rel="prefetch" href="/assets/js/82.fa091a48.js"><link rel="prefetch" href="/assets/js/83.99b23b93.js"><link rel="prefetch" href="/assets/js/84.74a0ea11.js"><link rel="prefetch" href="/assets/js/85.ab141e43.js"><link rel="prefetch" href="/assets/js/86.c3c098ff.js"><link rel="prefetch" href="/assets/js/87.fa72836c.js"><link rel="prefetch" href="/assets/js/88.006aba83.js"><link rel="prefetch" href="/assets/js/89.335d1b19.js"><link rel="prefetch" href="/assets/js/9.b9b10179.js"><link rel="prefetch" href="/assets/js/90.74bad001.js"><link rel="prefetch" href="/assets/js/91.29296900.js"><link rel="prefetch" href="/assets/js/92.6102e45c.js"><link rel="prefetch" href="/assets/js/93.de4e6240.js"><link rel="prefetch" href="/assets/js/94.e0d6f830.js"><link rel="prefetch" href="/assets/js/95.d9abf507.js"><link rel="prefetch" href="/assets/js/96.80393a7f.js"><link rel="prefetch" href="/assets/js/97.536e8c9e.js"><link rel="prefetch" href="/assets/js/98.52e25fe7.js"><link rel="prefetch" href="/assets/js/99.51956da3.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8eb0d87d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HACV</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/01.About/" class="nav-link">✡️About</a></div><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link router-link-active">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">🐉计算机内功</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/01.About/" class="nav-link">✡️About</a></div><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link router-link-active">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">🐉计算机内功</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>网络编程复习基础（一）</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/04.Net/Basis/01.TCPIP.html#一、-基本概念目标" class="sidebar-link">一、 基本概念目标</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（1）协议" class="sidebar-link">（1）协议</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（2）协议格式" class="sidebar-link">（2）协议格式</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（3）c-s编码模型" class="sidebar-link">（3）C/S编码模型</a></li></ul></li><li><a href="/04.Net/Basis/01.TCPIP.html#二、c-s和b-s" class="sidebar-link">二、C/S和B/S</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（1）c-s架构" class="sidebar-link">（1）C/S架构</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（2）b-s架构" class="sidebar-link">（2）B/S架构</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（3）总结" class="sidebar-link">（3）总结</a></li></ul></li><li><a href="/04.Net/Basis/01.TCPIP.html#三、tcp-ip4层模型和os" class="sidebar-link">三、TCP/IP4层模型和OS</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（1）7层模型和tcp-ip4层对应方式" class="sidebar-link">（1）7层模型和TCP/IP4层对应方式</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（2）计算机网络中的os『重要』" class="sidebar-link">（2）计算机网络中的OS『重要』</a></li></ul></li><li><a href="/04.Net/Basis/01.TCPIP.html#四、自底向上4层模型" class="sidebar-link">四、自底向上4层模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（1）以太网帧『网络接口层』" class="sidebar-link">（1）以太网帧『网络接口层』</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（2）arp数据报『网络层』" class="sidebar-link">（2）ARP数据报『网络层』</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（3）路由器寻址『网络层』" class="sidebar-link">（3）路由器寻址『网络层』</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（3）ip段格式『网络层』" class="sidebar-link">（3）IP段格式『网络层』</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（4）tcp-udp『传输层』" class="sidebar-link">（4）TCP/UDP『传输层』</a></li><li class="sidebar-sub-header"><a href="/04.Net/Basis/01.TCPIP.html#（5）应用层没有固定格式『重要』" class="sidebar-link">（5）应用层没有固定格式『重要』</a></li></ul></li><li><a href="/04.Net/Basis/01.TCPIP.html#五、套接字（socket）" class="sidebar-link">五、套接字（Socket）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/04.Net/Basis/01.TCPIP.html#概念辨析『重要』" class="sidebar-link">概念辨析『重要』</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/04.Net/Basis/01.TCPIP.html#参考资料" class="sidebar-link">参考资料</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><p>title: 网络协议基础<br>
date: 2020-08-06 08:00:01</p> <h1 id="网络编程复习基础（一）"><a href="#网络编程复习基础（一）" class="header-anchor">#</a> 网络编程复习基础（一）</h1> <ul><li><font style="background:yellow;">约定，以后用的网络层次，仅用『TCP/IP四层』中的术语</font></li> <li>『我们的网络编程研究的是4层模型，不是我们教学中的5层模型，注意！</li></ul> <h2 id="一、-基本概念目标"><a href="#一、-基本概念目标" class="header-anchor">#</a> 一、 基本概念目标</h2> <h3 id="（1）协议"><a href="#（1）协议" class="header-anchor">#</a> （1）协议</h3> <ul><li><strong>协议</strong>：相互约定的“数据<strong>传输</strong>”和“数据<strong>解释</strong>”的规则，协议是在数据传输之间就已经制定好了。</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>这种仅在A、B之间被遵守的协议称之为原始协议。
当此协议被更多的人采用，不断的增加、改进、维护、完善。最终形成一个稳定的、
完整的文件传输协议，被广泛应用于各种文件传输过程中。该协议就成为一个标准协 
议。最早的ftp协议就是由此衍生而来,后来，觉得这个不错，就不断完善这个，比如
加入，校验机制等等。后面就成为我们熟识的FTP协议。  

我们计算机中这么多协议，规定我们在传输数据的时候，要遵循某种格式，按照这个
格式进行传输。我们就说我们遵循某种协议。这个协议一旦制定好之后，你在使用这
个协议的时候，是不是要严格的按照这个协议来进行传递呢？
必须按照！一点也不允许你偷工减料。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="（2）协议格式"><a href="#（2）协议格式" class="header-anchor">#</a> （2）协议格式</h3> <ul><li>了解基本的或者说常用的协议格式</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>数据包基本格式:
数-应-传-网-链路   我们扔到网络环境中的这个数据包，这个数据包的基本格式。
也就是协议的总体格式是哪些？

以太网帧（链路层）格式
arp数据包格式——arp攻击  
IP段格式（网络层）——IP 32  
TCP/UDP（传输层）——prot 16——65535    
TCP格式是我们整个网络编程当中比较重要的一种格式！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="（3）c-s编码模型"><a href="#（3）c-s编码模型" class="header-anchor">#</a> （3）C/S编码模型</h3> <p>​</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>server<span class="token punctuation">.</span>c	
	<span class="token number">1.</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  建立套接字
	<span class="token number">2.</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 绑定IP 端口号  <span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">sockaddr_in</span> addr 初始化<span class="token punctuation">)</span>
	<span class="token number">3.</span> <span class="token function">listen</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 指定最大同时发起连接数
	<span class="token number">4.</span> <span class="token function">accept</span><span class="token punctuation">(</span><span class="token punctuation">)</span>  阻塞等待客户端发起连接
	<span class="token number">5.</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token number">6.</span> 小<span class="token operator">--</span>大
	<span class="token number">7.</span> write 给 客户端
	<span class="token number">8.</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
client<span class="token punctuation">.</span>c
	<span class="token number">1.</span> <span class="token function">socket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token number">2.</span> <span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  可以依赖“隐式绑定”
	<span class="token number">3.</span> <span class="token function">connect</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>发起连接
	<span class="token number">4.</span> <span class="token function">write</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token number">5.</span> <span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token number">6.</span> <span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><h2 id="二、c-s和b-s"><a href="#二、c-s和b-s" class="header-anchor">#</a> 二、C/S和B/S</h2> <h3 id="（1）c-s架构"><a href="#（1）c-s架构" class="header-anchor">#</a> （1）C/S架构</h3> <ul><li>优点：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>  1.协议的选用灵活，我们可以采用我们『自定义』的协议，并不一定要遵循现有的协议。
  典型的，比如电脑上的QQ软件。客户端，典型的C/S架构。
  2.数据可以提前缓存，比如，游戏的第一次的缓存。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>缺点：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、每次使用，要下载客户端。
客户端装在你主机上，你也不知道对你电脑做了什么事情，比如3Q大战，
『360和QQ』互相喷，客户端对用户的安全构成威胁。
2、需要开发客户端和服务端，两个需要联合调试，调试困难，
『联调』（联合调试）非常闹心。而且，开发量也大。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="（2）b-s架构"><a href="#（2）b-s架构" class="header-anchor">#</a> （2）B/S架构</h3> <ul><li>优点：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1.由于不会给主机安装客户端，啥的，相对来说，安全性要高一些。
2.只需要开发服务器端，你采用B/S模式，你所要选用的协议就是http协议，你既然选用这个模式，
你就要对这个协议进行『完整』的支持，『你用或者不用的这个部分，你都要支持他。』
3.跨平台，比如网页游戏，无论是在Linux还是Windows
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><ul><li>缺点：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、必须支持http协议，而且不能对http裁剪，你必须支持所有，即使这个模块你不用。但是你得支持。
2、数据是现加载，现缓存。所以，一般网页游戏是2D游戏，而不是3D游戏。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="（3）总结"><a href="#（3）总结" class="header-anchor">#</a> （3）总结</h3> <p>老实说，C/S和B/S互补<br>
数据量访问比较大：C/S模型<br>
应用程序稳定性高：C/S模型</p> <h2 id="三、tcp-ip4层模型和os"><a href="#三、tcp-ip4层模型和os" class="header-anchor">#</a> 三、TCP/IP4层模型和OS</h2> <ul><li>网络分层模型</li> <li><font style="background:yellow;">在我们的Linux操作系统中，我们的一般的<strong>应用程序</strong>的角度出发，我们重点掌握的是<strong>TCP/IP四层模型</strong>结结构（注意这句话）</font></li> <li>7层和4层，其实说的是一回事，只不过，划分的理论依据和方式不太一样而已。</li></ul> <h3 id="（1）7层模型和tcp-ip4层对应方式"><a href="#（1）7层模型和tcp-ip4层对应方式" class="header-anchor">#</a> （1）7层模型和TCP/IP4层对应方式</h3> <p>7层模型记忆法：  物数网传,会表应（<strong>巫术忘传会表应</strong>）<br>
有一说一，这个首先的学习方法就是硬背。（比如，你小时候背99乘法表，最开始不晓得干啥的，后面就开窍了，这个也是这样，暂时无法给你讲很多辅助知识，所以只能硬记）</p> <br> <br> <center><font size="5" style="background:yellow;">七层协议</font></center> <table><thead><tr><th>7层</th> <th>说明</th></tr></thead> <tbody><tr><td>物理层</td> <td>在网络通信过程当中，你所使用到的一<strong>些物理设备</strong>的一些<strong>标准</strong>。比如双绞线，光纤，我们现在使用的是光纤，早期的话，还会提到同轴电缆这样的东西。这里面所涉及到你网线的接口，它什么样的类型，都在这个里面都有一个限定。指定。还有就是你使用的这个物理设备是按照什么方式去传播的？也就是我们通常所说的bit位。传输速率是每秒多少bit，其实还有我们提到的数模转换与模数转换，高低电平的转化。</td></tr> <tr><td>数据链路层</td> <td>主要，实际上是针对我们网络当中，<strong>物理层接受过来的数据</strong>，进行<strong>校验</strong>的，它主要是数据进行侦测和校验。<br>比如说，你数据传输过来，有没有数据的丢失啊。是否有错误啊。在它的底层有个简单的二进制的校验的规则。</td></tr> <tr><td>网络层</td> <td>指定我们在传输的过程当中，提供的<strong>网络访问的路径</strong>？？<br>比如说，我们知道，<strong>你要想数据包在网络当中传输，必须要给他指定一个唯一的IP地址</strong>。<br>指定完IP地址之后，它通过IP地址在你当前比较<strong>繁杂的网络环境当中，进行寻路</strong>。<br>通过路由的跳转，最终到达目的地。它为什么能够到达目的地？主要是你给它传的IP地址而到达的。</td></tr> <tr><td>传输层</td> <td>对应的信息更加进一步了，主要携带的是<strong>端口号</strong>。<br>可能大家不晓得这个端口号代表的是啥？<br><font style="background:yellow;"><strong>实际上，端口号实际上代表我们之前讲过的（进程）</strong><br>但是，我们每一个进程扔到网络环境当中的时候，会给你这个进程配上一个唯一的端口号，<br>那因此，一个唯一的端口号，可以代表一个进程，咋们知道，进程在你当前的计算机中是唯一的。</font>正是因为这个进程在计算机当中唯一，加上网络层中IP地址在网络环境当中也是唯一的。所以，它就可以在网络当中游走了。**所以，我们传输层和网络层，我们通常说他们两是捆绑使用的。**因此我们经常说“网络 传输”通常说的“网络传输&quot;就是指的这2层而言。</td></tr> <tr><td>会话层</td> <td>所谓的会话层和表示层：<br>实际上是对我们传输层，上层的数据进行间接的封装和解封装的这样的一个过程。<br>也是为了对数据进行确认的。<br>在好多上面，会对回话和表示进行一个打包处理。<br><strong>因为我们刚刚强调，你的这个会话层和表示层和应用层，在TCP/IP模型里面，统一把他称为，应用层。</strong><br>因为这里面，这3层的分工不是那么的明确。<br>主要是对我们发送过来的信息，进行再一次的封装。</td></tr> <tr><td>表示层</td> <td></td></tr> <tr><td>应用层</td> <td>重点强调这个应用层：<br>这个应用层，主要是<strong>针对我们应用程序</strong>而言，所封装的一些协议。比如FTP，http<br><strong>主要是为了方便用户对数据进行访问，把数据包拿过来，进行访问（深刻理解这句话）</strong><br><font style="background:yellow;">而我们的，电子邮件、文件传输和终端仿真,这些是我们在“应用层”<strong>上面</strong>封装的一些协议。它是直接在我们的应用程序里面要用到的</font><br>所以说，你编写的应用程序直接会用到的协议是哪层的协议？？应用层协议。</td></tr></tbody></table> <br> <br> <center><font size="5" style="background:yellow;">TCP/IP四层（重点）</font></center> <ul><li>1、网络接口层（也有书叫：链路层）</li> <li>反正就是最接近底层的—&gt;网络层（主要用到协议：IP协议）—&gt;传输协议（一般用到TCP/UDP协议）—&gt;应用层（比如，FTP协议，SSH协议，FTPS，<strong>USB协议，蓝牙的协议？？</strong>）</li> <li>2、以太网帧协议，加上帧头和帧尾之后，会对应有一个以太网的驱动程序，也就是说，通过以太网驱动，由我们的网卡，把我们的数据包扔到，以太网环境当中。然后，下面的那根线，实际上模拟的就是我们网络环境。</li></ul> <table><thead><tr><th>TCP/IP</th> <th></th> <th>对应的ISO7层模型的</th></tr></thead> <tbody><tr><td>链路层（网络接口层）</td> <td><font size="2">最后，链路层的协议叫做——<strong>以太网帧协议</strong>。</font></td> <td>物理层、数据链路层</td></tr> <tr><td>网络层</td> <td></td> <td></td></tr> <tr><td>传输层</td> <td></td> <td></td></tr> <tr><td>应用层</td> <td></td> <td>表示层、会话层、应用层</td></tr></tbody></table> <p>而下边这些协议，实际我们，会在应用程序中用到吗？不会！！！！
<strong>也就是，除了第7层之外的其他协议，你是不会在你编写的程序当中用得到的；</strong></p> <p>我们所写的应用程序，默认都是封装好了以后直接向下发送，
比如，你在程序当中遵循的http协议，那你要遵循它的get，set方法，遵循它的这个方法，按照这个方法，去写你的数据流。写好了以后，就表示我们支持了http协议，当你程序运行起来之后，操作系统会帮助你调用以下的这些底层，1-6层。这些活都是谁干的？？？都是操作系统干的。</p> <ul><li>问题：我的应用程序当中，我有可能使用到“网络层”或者“传输层协议”啊，这
那这个时候，你在使用的还是<strong>TCP/IP模型</strong>吗？就不是了，如果你在应用程序当中，使用到了这些协议的话
说明你<strong>使用的不再是默认的TCP/IP模型</strong>。
而我们选用的是什么协议啊？？
<strong>自定义</strong>的协议！！！！
如果说，你采用的是<strong>自定义的协议</strong>的话，我们才会在“网络层”或者“传输层“涉及到协议的这种概念。</li></ul> <p>有了4层模型的基本认识之后（注意，是TCP/IP 4层模型）我们接下来要讨论的是<strong>我们的数据包如何封装，借助这4层协议，完成网络传输。</strong></p> <p>首先，准备数据“啥时候还我钱”  （这个时候，要是直接放网络中，会被网络的海浪淹死）
然后，在这个数据之外，封装上了应用层数据（这个时候，要是直接放网络中，还是会会被网络的海浪淹死）
然后，在上面的基础上，继续封装传输层协议的，（这个时候，要是直接放网络中，照常会被网络的海浪淹死）
然后，在上面的基础上，继续封装网络层协议的
然后，在上面的基础上，继续封装链路层（前后，头和尾都封装，这个和以前的不一样）层协议的
（这个时候，再放网络中，不会被网络的海浪淹死，可以正常传输）</p> <p>注意，上面的，<font style="background:red;">数据包的逐层封装，都是操作系统帮你干的！！,不需要我们自己来封装（也就是说，不是我们写的client.c里面做的）</font>（比如，上面，你写的数据，被封装上应用层，这是OS帮你干的的）同样，解封装，也是操作系统帮你做的。
所以，你的数据，在网络传输前，需要操作系统帮你，你的数据才能传输。</p> <p><strong>最后要了解，你的数据最终是从哪里出去的？？
一定是从你的网卡里面传输出去的。所以，你的网卡要传输到你的网络环境里面。当然，这期间，可能需要经过路由器，交换机</strong>
数据要想传输，必须进行封装！</p> <h3 id="（2）计算机网络中的os『重要』"><a href="#（2）计算机网络中的os『重要』" class="header-anchor">#</a> （2）计算机网络中的OS『重要』</h3> <br> <br> <table><thead><tr><th>2大区域</th> <th>对应TCP/IP模型</th></tr></thead> <tbody><tr><td>内核区域（kernel区）</td> <td>链路层，网络层，传输层</td></tr> <tr><td>用户区域（user区）</td> <td>应用层</td></tr></tbody></table> <ul><li>1、对于用户来说，我只处理，<strong>应用程序</strong>的细节。</li> <li>2、对于内核来说，它处理<strong>通信</strong>的一些细节。
比如，客户端首先封装好FTP协议，然后向下交给传输层。</li> <li>3、所以，我们强调，这个数据的<strong>封装</strong>实际上是由我们操作系统来帮我们完成的。</li> <li>4、问题：那你这个用户区，万一用到协议呢？那需要我们在编程的过程当中对这个协议进行支持。比如，你使用FTP。你就需要使用它的put和GET</li></ul> <h2 id="四、自底向上4层模型"><a href="#四、自底向上4层模型" class="header-anchor">#</a> 四、自底向上4层模型</h2> <ul><li>逆向思维</li></ul> <p><strong>上半部分重点：数据包的封装！</strong></p> <h3 id="（1）以太网帧『网络接口层』"><a href="#（1）以太网帧『网络接口层』" class="header-anchor">#</a> （1）以太网帧『网络接口层』</h3> <p>在说以太网帧格式之前，你首先要明白，我现在要讲的这个格式，它在我们数据包里面扮演什么角色？？
<strong>以太网帧，是在我们最外层的——网络接口层（链路层）（TCP/IP模型当中）</strong></p> <p>现在我们来看看，链路层如何帮助我们完成数据包的找寻。
如图，6字节目标地址，6字节的源地址，2字节的类型，<font style="background:yellow;">4字节的校验（CRC）<strong>（注意，这个4字节的，就是我们每次画画的时候那个，帧尾那个玩意！！！）</strong></font>
我们刚开始，知道链路层，主要用来校验。</p> <p><font style="background:yellow;">注意，上面的目的地址和源地址，不是IP地址，而是对应的电脑里面的硬件地址（MAC地址，所谓的MAC地址，实际上就是网卡的编号，对应你每个人都有的身份证，这个编号保证这块网卡在网络应用环境当中，是唯一的。）比如，我们Linux下ifconfig就能看到</font></p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>也就是说这个网卡编号，在全世界，不会出现重复（神奇）

这个网卡编号，实际上，在网卡出厂之前，比如说英伟达公司，在生产网卡之前，就已经把编号指定好了。

全世界，会专门有这样的组织给分配，比如说，全世界生产这个的厂商，假如说3
家，他们在生产网卡之前，会收到一个网卡编号的使用范围！比如，1号厂商，
1000-5000，2号为5001-10000这样的意思。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><ul><li>注意：以太网帧的，这个目的地址指的是，我的这个数据包<strong>将要去到的下一个网卡</strong>的MAC地址是多少。而我的这个源地址是指的，我自己的MAC地址。</li> <li>那么问题来了：我的这个数据包发送出来，要经过路由器，要经过好多，我怎么知道我的这个数据包要发送的下一块网卡的MAC地址是多少？？怎么知道它的下一个MAC地址是多少？因为，我们知道，我们自己的机器，有我们自己的MAC，路由器有属于路由器自己的MAC。</li> <li>因为路由器，也是网络终端设备。它也有属于自己的网卡，每个路由器都有一个MAC，当我从这到这个，我是怎么知道他的MAC地址的呢？？？需要借助的是，我们接下来要讲的ARP请求，在以太网帧中，我们知道2个字节表示，以太网帧的类型！</li> <li>当你的这个类型传递：
0800的时候，表示我是普通的以太网数据包，后面跟的是数据
0806，表示我的以太网帧发送的是一个ARP请求包，而发送不是数据。ARP请求包，用来请求，下一跳的MAC地址。</li></ul> <p>**以太帧中，有一个特殊的协议，也就是ARP协议，**这个ARP协议，就是专门用来获取。下一个，我要经过的路由器的MAC地址的。</p> <p>也就是说，我们这个协议，它是一个一般化的格式，或者说是个模板，我通过模板里面。这个2字节的变化，来达到发送不同数据的目的。下面，我们来看看那个28个字节的ARP数据报</p> <h3 id="（2）arp数据报『网络层』"><a href="#（2）arp数据报『网络层』" class="header-anchor">#</a> （2）ARP数据报『网络层』</h3> <p>6+6+2+++28+18的PAD（原因是，我要28+18才能达到最小的46个字节，满足人家那格式才行，言外之意，这18个字节没啥用，真正有用的是那28个字节）</p> <ul><li><strong>PAD表示——填充</strong></li></ul> <blockquote><p>PS（小知识）：所以iPad怎么来的？就是为了完成一个填充，填充iPhone和Mac因为苹果出iPhone的时候，那个iPhone大概是4英寸大小，而我们的Mac最小的一般是11或13寸大小，因此，它在这两个大小之间，填充了一个9寸的大小，所以取名iPad，其实是为了填充屏幕中间的这一段空白。</p></blockquote> <p>我们主要关注28字节中，这些部分
6字节的发送端的以太网地址，
4字节发送端的IP地址，
6字节大小目的以太网地址
4字节目的IP地址</p> <p>比如，我在发送<strong>ARP请求</strong>的时候，我们不知道目的地址是多少</p> <p><strong>(1）所以，我们将前6个字节填充为0（目的MAC地址）</strong></p> <p>（2）6个字节（自己的源MAC地址）</p> <p>(3)2字节，帧类型，0806</p> <p>6字节的发送端的以太网地址，（同（2）中一样）
4字节发送端的IP地址（填充好）
6字节大小接收端以太网地址(<strong>填上全0，因为现在还不知道)</strong>
4字节接收端IP地址（填充，知道的IP，因为，你IP都不知道，那就没有办法传递了。。）</p> <p>ARP请求包，会把我们封装好的这个数据包，扔到网络环境当中，然后，<strong>把网络环境当中，所有的，我能连接的，都发送一下。（这叫广播把）</strong>
当他们收到之后，发现发过来的目的MAC地址竟然是全0，它会讲目的IP和自己的IP进行比较，
如果发现是自己的IP，那他就做什么操作？？？我帮你做填充，将我的MAC地址填充好。
然后，填充好之后，发送回一个，回复：但是回复是这样的。
同样，它的这个包，也是向我网络环境当中，我能连接的所有的路由，或者是终端进行发送。
发送到之后，每个人都会检查自己的IP，要是对不上则扔掉。
要是先前那个发送的，收到了，发现有目的IP，也就表示，我先前发送ARP请求包，它给了我回应了。
这样就知道那个目的MAC了。</p> <p><font style="background:yellow;">就是通过上面这种方式，在我们的网络环境中，从这个节点，选择到这个节点。。。（但是，我还是不懂，什么鬼）</font></p> <p>注意，ARP数据报，是干嘛的？
获取MAC地址的，确切的来说，是获取<strong>我下一个即将要把数据包投递的。那个路由的MAC地址</strong>。
我们把这个<strong>路由</strong>称之为我的“下一跳”；</p> <p>那么我的数据报，在我一个路由一个路由之间传输，这每一个路由节点，我们又称之为“一跳”
形容，数据包，从这蹦到这。。</p> <p>ARP数据报，所谓数据报，就是去完之后，就没有回了。有去无回的数据报？？？
什么鬼
arp数据报;获取下一跳的mac地址。</p> <p>我们的数据包每到一个路由器，都要完成一个数据包的解包和打包（但是，不是完全的解包罗）</p> <p><font style="background:yellow;">问题：（难点，重点）
ARP数据包中的，发送端IP地址是本机IP，那么目的IP地址呢？？
是我数据包，最终去往的那个IP地址吗？？还是我的目前的下一跳的IP地址？？
答案：<strong>下一跳的IP地址</strong>
那么问题来了，最终去往的那个IP放在哪里呢？？？
封装在了我们的网络层，具体说是封装在网络层的IP协议当中（这是，计算机网络的核心知识点之一，个人认为，事实上也是的）
</font>
所以，也解释了，每到一个路由器，要解包:解数据链路层的，解网络层的。</p> <p><font size="5" style="background:yellow;">（重点：理解这里，计算机网络水平就上升很多了）这样，我就明白了数据包，如何寻路，其实就是利用数据链路层（ARP广播）和网络层（IP）</font>从网络层中，根据你要传输的，<strong>最终目的IP</strong>，通过路由器中的路由表，进行寻路。
路由器参照自己内部的路由表，帮助我进行寻路，就是决定路由器应该下一跳。知道下一跳，我就知道下一跳的IP地址了。然后，可以把这个往ARP的目的IP添。，然后重复先前的ARP广播，一步步的这么跳下去。
这样，我清晰了。</p> <p>但是，在这个基础上，我又有一个疑问：那我们新开的一个路由器，投入网络使用的时候，最初是怎么知道，相邻的路由器的呢？？？？难道是手工？？？</p> <p>加餐：网络环境很差，各种最优的选择的路由器直接断开，怎么办？？
所以就只能，发一些其他路由器，看能不能从你那里绕过去。
而且，很低概率上，甚至会在好几个路由器之间死循环——————这种数据包，要是很多的话，就会拥塞住你当前的网络环境。
为了为了防止这种死循环，我们所有的数据包在发送的时候，要经过多少跳才能送到最终的终点的地方，这个上限有限定的！！！比如，我跳了100跳了，还没有到达，，，我们就会考虑丢弃这个。
**我们把这个上限，称之为TTL（就是你的这个数据包，在网络传输过程当中的最长生命周期，一般是以1跳为单位）**比如TTL=56，表示最多经过56个路由器，要是经过这么多，还没有到，，，
**因为每经过一个路由器，就把TTL减1；**那最后一个路由器把他丢弃。也就是把TTL减为0的路由器。
这样就保证了，就算在网络环境很差的环境下，也不会拥塞我们的网络。</p> <h3 id="（3）路由器寻址『网络层』"><a href="#（3）路由器寻址『网络层』" class="header-anchor">#</a> （3）路由器寻址『网络层』</h3> <p>问，我封装好的数据包，怎么会，从这端到那一端？
原因是数据包里面有一层是IP地址。
显然，它在实际进入网络环境的时候，它会根据我们的 IP地址去进行寻路。
实际上，当我们的数据包从网卡里面出来的时候，实际上，它可以选择的路好多条。
这些，都有可能到达目的地，所以=，我们形象称为“网”
路由器——
路，
由：经由的意思，我从这条路走到这边会经由哪些站点？也就是说，我选路的一个过程。
你实际选择了哪些路由器，作为我的经过，我们把这个路由器，称为我的一个路由节点。</p> <p>在每个路由节点里面，会有一个路由表！路由表是什么？
表格，表格内部记录了一条条路由信息。
路由表记录了，我的路由器连接了哪些路由器，也就是说，我会把你的数据包，接下来发送给哪些路由器。</p> <p>注意，元地址，我自己的路由是192.168.1.23
我目标的路由是192.168.10.56
显然，它要把他的<strong>目标路由</strong>记录在里面。
然后发现，下面的192.168.45.67更接近我的路由？？
所以，选他。</p> <p>我们把，路由器参照自己的这个路由表在选择，数据包下一个发送位置的过程，我们把他称之为寻路。
（我要寻找我的下一个路由节点）</p> <p><font style="background:yellow;">注意：对于TCP协议来说，它的寻路，一般情况下只有一次。
就是当数据包第一次发送的时候。</font>
一旦，我把这条路建立好了之后，假如说，我要发送一个小说过去。这个小说显然，要发送好多这样的数据包发送。
<font style="background:yellow;">一旦，我把这条路建立好了之后，那么后续，它所有的数据包都是按照这条路径来走的@！！</font>
因此，我们说，TCP在数据传输过程当中，稳定，因为我传输数据的路由是固定的！！！</p> <p>如果是UDP协议就不一样了，由于，它没有<strong>建立通路</strong>的这样一种机制！！
所以，它可能第1个走这条路，第2个走这条。
也就是说，UDP协议在选择的时候，它每次都要干啥？它<strong>每次</strong>都要进行一次寻路操作！！！</p> <p>注意：你的数据包在封装的时候，里面要封装一个IP，这个IP地址里面记录的是，我要发送的数据包的<strong>目标位置</strong>！而这个IP地址，也是我路由器寻路的一个依据，那么实际上，路由器在寻路的时候，它单纯的是依据我们的这个IP吗？实际上不是的，路由器要寻路不假，但是在寻路的过程当中，它不单单，依照我们这个IP还依照我们这个谁呢？？？也就是我们数据包里面的，以太网帧！！！</p> <h3 id="（3）ip段格式『网络层』"><a href="#（3）ip段格式『网络层』" class="header-anchor">#</a> （3）IP段格式『网络层』</h3> <p><strong>4位版本号</strong>：IPv4和Ipv6（其实IPv6主要是国内在推动，毕竟最初IP地址在定位的时候，就是欧美组织在定的，当时下发的时候，几乎就是按照基础的科研单位，就是最小的科研单位，比如到学校的院系，去划分）
当我们国家的计算机起步，人家几乎分完了，没办法找别人硬要，要来了一部分IP，给我们开发。
所以说，给我们的IP少得可怜，我们整个国家的IP，范围和别人一所学校的范围，几乎差不多。。。</p> <p>但是已经推了很多年了。</p> <p><strong>4位首部长度</strong>：IP地址的首部的长度是20字节，其实就是记录在这。
16位总长度（字节数）：描述的是IP段总体的长度
16位标识<br>
3位标志<br>
13位片偏移
8位生存时间（TTL）：表示数据包在网络当中能够经过多少个路由器。（记住，TTL在IP段里面记录）
问题，要是中国到澳大利亚，256跳够吗？？？额。你的跳数和你的物理距离无关。有可能到澳大利亚，海底光缆，3跳就过去了，有可能到广州需要经过几十跳。这都有可能。
8位协议
16位首部校验和：在IP段这一层，进行你这个数据包的校验。
32位源IP地址：最初的IP地址(强调)
32位的目的IP：最终的IP地址（强调，
注意，是32位，4字节的IP地址，编程的时候，记得哈
你程序当中的IP一定受到这个限制！！！</p> <p>联系：<font size="5" style="background:yellow;">IP层封装的这些东西，对于，以太网帧格式来说，是它的什么部分？？是它的数据，，，比如在前面的前面的图中，对应的是46-1500字节的那个里面</font></p> <h3 id="（4）tcp-udp『传输层』"><a href="#（4）tcp-udp『传输层』" class="header-anchor">#</a> （4）TCP/UDP『传输层』</h3> <ul><li><strong>由于TCP和UDP都位于传输层，言外之意，在传输层的时候，我们要做一个协议选择。</strong></li></ul> <h4 id="udp数据报格式："><a href="#udp数据报格式：" class="header-anchor">#</a> UDP数据报格式：</h4> <p>端口号用来描述，进程。（毕竟IP只能找到电脑，端口号才能找到那个电脑上哪个进程）</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>16位源端口号：（这2个东西，在编程之前，我们私下已经定好了）
16位目的端口号：（这2个东西，在编程之前，我们私下已经定好了）比如，说，你
个人的IP，你需要通过打电话，或者发电报的方式提前知道。
端口号在我们封装，C/S模型或者B/S模型的时候，我们指定好端口号是多少，比如
说，B/S模型，端口号是8080端口，这都固定的端口，
16位UDP长度：
16位UDP校验和
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h4 id="tcp数据报格式："><a href="#tcp数据报格式：" class="header-anchor">#</a> TCP数据报格式：</h4> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>显然和UDP都是属于传输层协议，那么都有
16位源端口号：
16位目的端口号：
但是TCP除此之外，还需要有一些东西。
32位序号，（（大概懂
32位确认序号。（（大概懂

4位首部长度：
保留6位:将来，万一协议需要扩展，，，虽然到现在也没用上。
标志位：URG，ACK，PSH，PST，SYN，FIN
16位窗口大小
16位校验和
16位紧急指针
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p><font style="background:yellow;">至此，以太网帧层-》网络层-》传输层我们从思路上走了一遍</font></p> <p>这些个协议格式，大概我们都给他们介绍了。</p> <h3 id="（5）应用层没有固定格式『重要』"><a href="#（5）应用层没有固定格式『重要』" class="header-anchor">#</a> （5）应用层没有固定格式『重要』</h3> <ul><li>Q：至于，<strong>应用层，它的协议有没有固定格式</strong>？</li> <li>A：没有，比如我们知道，画一条先，下3层是内核部分，应用层是user部分,用户层，你所谓的协议是什么样子的，有多少个头，携带多少个数据应该是<strong>由用户自己来确定的</strong>。所以，它的协议不固定</li></ul> <h2 id="五、套接字（socket）"><a href="#五、套接字（socket）" class="header-anchor">#</a> 五、套接字（Socket）</h2> <p>（很重要的前置知识）</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token number">1.</span> 成对出现
<span class="token number">2.</span> bind  IP port
<span class="token number">3.</span> 一个fd 两个buf  
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><div class="language-txt line-numbers-mode"><pre class="language-text"><code>Socket中文称呼是套接字的意思
但是也有中文“插座”：指的是我们现实生活中，两部分，比如你手机充电器和提供插
口的东西
（所以，socket是2端，不会是一端，也就是，一个是数据发送端，一个是数据接收端。好吧，这比喻还比较形象）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>注意：</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>IP地址: 在网络环境中唯1标示1台主机
端口号（Port）:在主机中唯一标示一个进程
IP+port: 在网络环境中唯1标示1个进程
我们把“在网络环境中唯1标示1个进程”称为socket
从这个角度出发，**Socket他必须包含：IP地址和端口号**
因此你在使用socket之前，你需要确认这两个。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>套接字是我们Linux系统当中的一种文件类型，socket是一个文件是一个伪文件。</p> <p>注意：</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>当你创建好一个socket以后，我也是有一个文件描述法（fd）
但是，这一个文件描述法，对应2个缓冲区！
这『2个缓冲』用1个文件描述符来指向。
1个缓冲区，专门用来完成数据的读入，一个用来完成写出。

所以，我们拿着socket去进行数据操作的时候，我既可以向fd当中写数据，也可以从fd里面读数据。
比如：管道，数据是单向流动的，半双工通信
只能一个方向流动，要想2个方向流动，需要2根管道！！！
但是socket不一样，他是双向『全双工』的！！就是，在同一时刻，我既可以数据读入，也可以数据读出嘛。。
（2个缓冲区）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>当你写数据的时候，通过文件描述法，写入到套接字这个伪文件里面。实际上是通过，发送端缓冲区，连接到另外一个套接字的接收端。把数据写过去了。</p> <ul><li>缓冲区是在内核里面给我们提供的一片存储空间，4K大小左右</li></ul> <h2 id="概念辨析『重要』"><a href="#概念辨析『重要』" class="header-anchor">#</a> 概念辨析『重要』</h2> <ul><li>7层模型中，只有『数据链路层』的说法</li> <li>TCP/IP4层模型中，只有『链路层』或者是『网络接口层』的说法，注意概念！！</li></ul> <h2 id="参考资料"><a href="#参考资料" class="header-anchor">#</a> 参考资料</h2> <ul><li>游双，《<a href="https://book.douban.com/subject/24722611/" target="_blank" rel="noopener noreferrer">Linux高性能服务器编程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li> <li>陈硕，《<a href="https://book.douban.com/subject/20471211/" target="_blank" rel="noopener noreferrer">Linux多线程服务端编程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li> <li>史蒂文斯 / 芬纳 / 鲁道夫，《<a href="https://book.douban.com/subject/1500149/" target="_blank" rel="noopener noreferrer">UNIX网络编程<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li></ul></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.5089c99b.js" defer></script><script src="/assets/js/56.bca0377b.js" defer></script>
  </body>
</html>

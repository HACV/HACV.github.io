<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>✅ C++2.0新特性 | HACV</title>
    <meta name="description" content="Personal Blog Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.0dbae9ec.css" as="style"><link rel="preload" href="/assets/js/app.2faae0a0.js" as="script"><link rel="preload" href="/assets/js/83.eb3feba5.js" as="script"><link rel="prefetch" href="/assets/js/10.877a55b7.js"><link rel="prefetch" href="/assets/js/100.ff163aa2.js"><link rel="prefetch" href="/assets/js/11.a50cd084.js"><link rel="prefetch" href="/assets/js/12.4f613f36.js"><link rel="prefetch" href="/assets/js/13.b6349c30.js"><link rel="prefetch" href="/assets/js/14.7ee96d39.js"><link rel="prefetch" href="/assets/js/15.1cd4416a.js"><link rel="prefetch" href="/assets/js/16.1d34b067.js"><link rel="prefetch" href="/assets/js/17.51677e82.js"><link rel="prefetch" href="/assets/js/18.ea56a77c.js"><link rel="prefetch" href="/assets/js/19.5bf109e0.js"><link rel="prefetch" href="/assets/js/2.ef8300fa.js"><link rel="prefetch" href="/assets/js/20.2c26a59b.js"><link rel="prefetch" href="/assets/js/21.a1fd0b54.js"><link rel="prefetch" href="/assets/js/22.6f98cda0.js"><link rel="prefetch" href="/assets/js/23.2224753e.js"><link rel="prefetch" href="/assets/js/24.3e484053.js"><link rel="prefetch" href="/assets/js/25.3f4a5f65.js"><link rel="prefetch" href="/assets/js/26.ce0361f9.js"><link rel="prefetch" href="/assets/js/27.bf8eb072.js"><link rel="prefetch" href="/assets/js/28.3672c0da.js"><link rel="prefetch" href="/assets/js/29.41cc0c19.js"><link rel="prefetch" href="/assets/js/3.097212f4.js"><link rel="prefetch" href="/assets/js/30.b8bafb55.js"><link rel="prefetch" href="/assets/js/31.7b7fde4c.js"><link rel="prefetch" href="/assets/js/32.7f41d2e2.js"><link rel="prefetch" href="/assets/js/33.95a7ef36.js"><link rel="prefetch" href="/assets/js/34.0c9ed89f.js"><link rel="prefetch" href="/assets/js/35.ce701b23.js"><link rel="prefetch" href="/assets/js/36.f63306f5.js"><link rel="prefetch" href="/assets/js/37.c23f73e1.js"><link rel="prefetch" href="/assets/js/38.9f9ae58c.js"><link rel="prefetch" href="/assets/js/39.eeedf72c.js"><link rel="prefetch" href="/assets/js/4.804f4910.js"><link rel="prefetch" href="/assets/js/40.3bb56b05.js"><link rel="prefetch" href="/assets/js/41.085977ed.js"><link rel="prefetch" href="/assets/js/42.8e9761d6.js"><link rel="prefetch" href="/assets/js/43.f0012948.js"><link rel="prefetch" href="/assets/js/44.2bb3aad4.js"><link rel="prefetch" href="/assets/js/45.10f97b3f.js"><link rel="prefetch" href="/assets/js/46.dc31d302.js"><link rel="prefetch" href="/assets/js/47.b026b5e3.js"><link rel="prefetch" href="/assets/js/48.5ccba59d.js"><link rel="prefetch" href="/assets/js/49.637595bf.js"><link rel="prefetch" href="/assets/js/5.b3e93cf0.js"><link rel="prefetch" href="/assets/js/50.e25f098a.js"><link rel="prefetch" href="/assets/js/51.0a44b492.js"><link rel="prefetch" href="/assets/js/52.2dee17f1.js"><link rel="prefetch" href="/assets/js/53.f25ea82e.js"><link rel="prefetch" href="/assets/js/54.bea53589.js"><link rel="prefetch" href="/assets/js/55.28a34913.js"><link rel="prefetch" href="/assets/js/56.be50a469.js"><link rel="prefetch" href="/assets/js/57.cff21887.js"><link rel="prefetch" href="/assets/js/58.1f5ba164.js"><link rel="prefetch" href="/assets/js/59.7fe62295.js"><link rel="prefetch" href="/assets/js/6.76a54562.js"><link rel="prefetch" href="/assets/js/60.f224a395.js"><link rel="prefetch" href="/assets/js/61.5db2158d.js"><link rel="prefetch" href="/assets/js/62.82e94ca5.js"><link rel="prefetch" href="/assets/js/63.07a248b2.js"><link rel="prefetch" href="/assets/js/64.ccec04a2.js"><link rel="prefetch" href="/assets/js/65.94e93a01.js"><link rel="prefetch" href="/assets/js/66.54362b20.js"><link rel="prefetch" href="/assets/js/67.4d4df9dd.js"><link rel="prefetch" href="/assets/js/68.a8c1746a.js"><link rel="prefetch" href="/assets/js/69.5d84fc9e.js"><link rel="prefetch" href="/assets/js/7.424e8efc.js"><link rel="prefetch" href="/assets/js/70.2c5d5582.js"><link rel="prefetch" href="/assets/js/71.25d26a7d.js"><link rel="prefetch" href="/assets/js/72.bf8b6cd2.js"><link rel="prefetch" href="/assets/js/73.4b222965.js"><link rel="prefetch" href="/assets/js/74.60633a73.js"><link rel="prefetch" href="/assets/js/75.9899628b.js"><link rel="prefetch" href="/assets/js/76.b89b8d50.js"><link rel="prefetch" href="/assets/js/77.6c672ab3.js"><link rel="prefetch" href="/assets/js/78.78618cad.js"><link rel="prefetch" href="/assets/js/79.d894a151.js"><link rel="prefetch" href="/assets/js/8.643f00e1.js"><link rel="prefetch" href="/assets/js/80.16092758.js"><link rel="prefetch" href="/assets/js/81.bb0cb284.js"><link rel="prefetch" href="/assets/js/82.5f7e327a.js"><link rel="prefetch" href="/assets/js/84.28445c05.js"><link rel="prefetch" href="/assets/js/85.2ac2804d.js"><link rel="prefetch" href="/assets/js/86.2c2486dc.js"><link rel="prefetch" href="/assets/js/87.7c0d0cb1.js"><link rel="prefetch" href="/assets/js/88.0f74e7b0.js"><link rel="prefetch" href="/assets/js/89.47d730bc.js"><link rel="prefetch" href="/assets/js/9.3583c964.js"><link rel="prefetch" href="/assets/js/90.d0850d65.js"><link rel="prefetch" href="/assets/js/91.2db88926.js"><link rel="prefetch" href="/assets/js/92.28714ea2.js"><link rel="prefetch" href="/assets/js/93.4433b003.js"><link rel="prefetch" href="/assets/js/94.3dfb4cc8.js"><link rel="prefetch" href="/assets/js/95.86d1e3d6.js"><link rel="prefetch" href="/assets/js/96.97b41e32.js"><link rel="prefetch" href="/assets/js/97.2d105583.js"><link rel="prefetch" href="/assets/js/98.ba67e7b8.js"><link rel="prefetch" href="/assets/js/99.cf55180f.js">
    <link rel="stylesheet" href="/assets/css/0.styles.0dbae9ec.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HACV</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🔋软件</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></li><li class="dropdown-item"><!----> <a href="/03.OS/" class="nav-link">💻操作系统</a></li><li class="dropdown-item"><!----> <a href="/04.Net/" class="nav-link">☁️计算机网络</a></li><li class="dropdown-item"><!----> <a href="/05.SE/" class="nav-link">✅软件工程</a></li></ul></div></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">⚡️数据库</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">⚙️工具</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/09.Language/Cpp/" class="nav-link router-link-active">⭐️C++</a></li><li class="dropdown-item"><!----> <a href="/09.Language/Java/" class="nav-link">☕️Java</a></li></ul></div></div><div class="nav-item"><a href="/10.SourceCode/" class="nav-link">⭐️源码剖析</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🔋软件</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></li><li class="dropdown-item"><!----> <a href="/03.OS/" class="nav-link">💻操作系统</a></li><li class="dropdown-item"><!----> <a href="/04.Net/" class="nav-link">☁️计算机网络</a></li><li class="dropdown-item"><!----> <a href="/05.SE/" class="nav-link">✅软件工程</a></li></ul></div></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">⚡️数据库</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">⚙️工具</a></div><div class="nav-item"><div class="dropdown-wrapper"><a class="dropdown-title"><span class="title">🚀语言</span> <span class="arrow right"></span></a> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/09.Language/Cpp/" class="nav-link router-link-active">⭐️C++</a></li><li class="dropdown-item"><!----> <a href="/09.Language/Java/" class="nav-link">☕️Java</a></li></ul></div></div><div class="nav-item"><a href="/10.SourceCode/" class="nav-link">⭐️源码剖析</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>✅ C++2.0新特性</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#📑-目录" class="sidebar-link">📑 目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#✅-一、语法部分" class="sidebar-link">✅ 一、语法部分</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳01-演进、环境与资源" class="sidebar-link">⏳01.演进、环境与资源</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳02-variadic-template『可变模板参数』" class="sidebar-link">⏳02.Variadic Template『可变模板参数』</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳03-『3个东西』" class="sidebar-link">⏳03.『3个东西』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#『-补充自后一个视频』" class="sidebar-link">『 补充自后一个视频』</a></li></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳04-一致性的初始化" class="sidebar-link">⏳04. 一致性的初始化</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳05-初始化列表-上" class="sidebar-link">⏳05.初始化列表(上)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳06-初始化列表-下" class="sidebar-link">⏳06.初始化列表(下)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳07-explicit-for-ctors-taking-『more-than』-one-argument" class="sidebar-link">⏳07. Explicit for ctors taking 『more than』 one argument</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#『c-2-0开始的』c-2-0新特性『c-98有很小的用途』" class="sidebar-link">『C++2.0开始的』C++2.0新特性『C++98有很小的用途』</a></li></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳08-基于范围的for语句" class="sidebar-link">⏳08.基于范围的for语句</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳09-default-delete" class="sidebar-link">⏳09. =default, =delete</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳10-alias-template" class="sidebar-link">⏳10. Alias Template</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳11-template-template-parameter" class="sidebar-link">⏳11. Template template parameter</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳12-『4个东西』" class="sidebar-link">⏳12. 『4个东西』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#『类型的化名』" class="sidebar-link">『类型的化名』</a></li></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳13-decltype『关键字』" class="sidebar-link">⏳13. decltype『关键字』</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳14-lambdas" class="sidebar-link">⏳14. lambdas</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#✅-可变模板参数系列" class="sidebar-link">✅ 可变模板参数系列</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳15-variadic-templates-1" class="sidebar-link">⏳15. Variadic Templates 1</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳16-variadic-templates-2" class="sidebar-link">⏳16. Variadic Templates 2</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳17-variadic-templates-3" class="sidebar-link">⏳17. Variadic Templates 3</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳18-variadic-templates-4" class="sidebar-link">⏳18. Variadic Templates 4</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳19-variadic-templates-5" class="sidebar-link">⏳19. Variadic Templates 5</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳20-variadic-templates-6-1" class="sidebar-link">⏳20. Variadic Templates 6(1)</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳21-variadic-templates-7-c-keywords" class="sidebar-link">⏳21. Variadic Templates_7 &amp; C++ Keywords</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#✅-二、标准库部分" class="sidebar-link">✅ 二、标准库部分</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳22-标准库-源代码分布" class="sidebar-link">⏳22.标准库-源代码分布</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳23-右值引用和move语义『移动语义-move-semantic』" class="sidebar-link">⏳23.右值引用和move语义『移动语义/move semantic』</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳24-完美转发" class="sidebar-link">⏳24.完美转发</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳25-写一个-move-aware-class" class="sidebar-link">⏳25.写一个 Move-aware class</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Cpp/ReviewCpp/03.C%2B%2B2.0%E6%96%B0%E7%89%B9%E6%80%A7.html#⏳26-move-aware-class-对容器的效能测试" class="sidebar-link">⏳26.Move-aware class 对容器的效能测试</a><ul class="sidebar-sub-headers"></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="✅-c-2-0新特性"><a href="#✅-c-2-0新特性" class="header-anchor">#</a> ✅ C++2.0新特性</h1> <h2 id="📑-目录"><a href="#📑-目录" class="header-anchor">#</a> 📑 目录</h2> <p>[TOC]</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>一、语法部分
01.演进、环境与资源
02.Variadic Template『可变模板参数』
✅03.『3个东西』
『1』Spaces in Template Expression
『2』nullptr and std::nullptr_t
『3』Automatic Type Deduction with auto，通过auto自动类型扣除

✅04.Unifrom Initialization『一致性的初始化』
✅05.Initializer_list（上）
06. Initializer_list（下）
07. Explicit for ctors taking 『more than』 one argument
✅08.基于范围的for语句
09.=default, =delete
10.Alias Template
11.Template template parameter
12.『4个东西』
&gt; - Type Alias，类型的化名
&gt; - noexcept
&gt; - override
&gt; - final
13.decltype『关键字』
14.lambdas

✅23.右值引用和move语义（游戏公司面试考了）
	- 缺乏右值引用和引用（又叫“左值引用”）
	- 新引进的名称：临终值，在C++11中为右值引用专门定义了临终值（eXpiring value）这一概念
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><h2 id="✅-一、语法部分"><a href="#✅-一、语法部分" class="header-anchor">#</a> ✅ 一、语法部分</h2> <ul><li>⏳01.演进、环境与资源</li> <li>⏳02.可变模板参数</li> <li>⏳03.模板表达式中的空格、nullptr and std--nullptr_t、Automatic Type Deduction with auto</li></ul> <h2 id="⏳01-演进、环境与资源"><a href="#⏳01-演进、环境与资源" class="header-anchor">#</a> ⏳01.演进、环境与资源</h2> <p><img src="img/C++%E6%A0%87%E5%87%8611/01.png" alt="01"></p> <ul><li>在软件界，还没有成熟的就是0.几，所以1.0版本是个正式成熟的作品</li> <li>1.1-1.2这样的一些小改版</li> <li>C++2.0又是一个里程碑</li></ul> <p>『本课程涵盖了C++11和C++14』</p> <blockquote><p>这个课程，新特性被我分为2部分，1个是语言部分，1个是标准库部分。</p></blockquote> <p><img src="img/C++%E6%A0%87%E5%87%8611/02.png" alt="01"></p> <p><img src="img/C++%E6%A0%87%E5%87%8611/03.png" alt="01"></p> <p><img src="img/C++%E6%A0%87%E5%87%8611/04.png" alt="01"></p> <ul><li>『较全面』的，并且从实例中获得体验。</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/05.png" alt="01"></p> <ul><li>C++14是对C++11的一些小地方的修缮。『最重要是1.0和2.0的』</li> <li>『本课程涵盖C++11和14』</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/06.png" alt="01"></p> <ul><li>我们还是希望，大家能很快改掉你的旧的写法，用新的写法</li> <li>我们列出的都是『2.0』新增加的一些头文件。</li></ul> <blockquote><p><strong>注意</strong>：**标准库的东西都是放在『命名空间std』**中，所以在你使用这些东西的时候，你要把它全名写出来。因此，一个东西的全名，你要带着那个命名空间。</p> <p>当然，怕麻烦用using namespace std;</p></blockquote> <ul><li>TR1那个版本的C++</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>TR1的那些东西是被放在，命名空间std的次要的命名空间tr1
所以当时，你必须<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token operator">::</span>tr1 
早期是这样的，但是现在已经搬到std里面来了！！！
『也就是说<span class="token number">2.0</span>里面，我们就不需要管那个TR1了』
TR1的技术和组件还全部存在，但是现在被放到std里面了
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p><img src="img/C++%E6%A0%87%E5%87%8611/07.png" alt="01"></p> <ul><li>学习语言上的东西，当然要去测试。了解编译器对2.0的支持度</li></ul> <p>网页推荐：</p> <ul><li><a href="https://isocpp.org/" target="_blank" rel="noopener noreferrer">https://isocpp.org/<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>『这个里面说明了“编译器”支持C++11和14如何』</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/08.png" alt="01"></p> <p><img src="img/C++%E6%A0%87%E5%87%8611/09.png" alt="01"></p> <ul><li>这样可以查看，手上的编译器对这些的支持程度。</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/10.png" alt="01"></p> <ul><li>自己做测试用的编译器是：DevC++5.11这个编译器。</li></ul> <p>​</p> <p><strong>（1）语言</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>语言<span class="token operator">:</span>
<span class="token operator">-</span> Variadic Templates  <span class="token comment">//叫作：</span>
<span class="token operator">-</span> move Semantics	『标记』
<span class="token operator">-</span> <span class="token keyword">auto</span>				『标记』
<span class="token operator">-</span> Range<span class="token operator">-</span>base <span class="token keyword">for</span> loop 『标记』
<span class="token operator">-</span> Initializer list
<span class="token operator">-</span> Lambdas
<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><strong>（2）标准库</strong></p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">-</span> type_traits	『标记』
<span class="token operator">-</span> Unordered容器
<span class="token operator">-</span> forward_list	『标记』
<span class="token operator">-</span> array			『标记』
<span class="token operator">-</span> tuple			『标记』
<span class="token operator">-</span> Con<span class="token operator">-</span>currency
<span class="token operator">-</span> RegEx
。。。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="⏳02-variadic-template『可变模板参数』"><a href="#⏳02-variadic-template『可变模板参数』" class="header-anchor">#</a> ⏳02.Variadic Template『可变模板参数』</h2> <blockquote><p>Variadic Templates，可变模板</p></blockquote> <ul><li><p>Variadic Templates这个叫作：其实没有单词Variadic，这个叫作『</p></li> <li><p>看下面的代码，竟然有个『<code>...</code>』，这给我们带来了困扰，因为没想到到了C++2.0这个『<code>...</code>』成为了关键字的一部分！！</p></li> <li><p>实际上，这个『<code>...</code>』在以前C的时代就存在了，在那个printf中</p></li> <li><p>所以我们联想到，『<code>...</code>』是可以接受任意变化个数的东西。</p></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">void</span> <span class="token function">PrintX</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="⏳03-『3个东西』"><a href="#⏳03-『3个东西』" class="header-anchor">#</a> ⏳03.『3个东西』</h2> <ul><li>『1』Spaces in Template Expression，在模板表达式中的“空格”</li> <li>『2』<code>nullptr</code> and <code>std::nullptr_t</code></li> <li>『3』Automatic Type Deduction with auto，通过auto自动类型扣除</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/03_01.png" alt="01"></p> <p>在temperate expression 模板表达式里面的那个空格，这空格一向很讨厌。如果你过去有经验了，你一定很清楚我在说什么。
就是这样子。像这个呢写一个模板，如果这个模板参数本身又是一个模板的话，这个右边就会出现两个大挂号啊。尖刮号。这个<strong>在过去呢一定要把它空开来</strong>。
这个病意思就是说编译器如果你这个连在一起，编译器编在这里会以为那是一个操作符。然后他前后边前后看就看不懂。这个编译器在当时不够聪明。
那现在进化终于他懂了，所以这个观这个空格可以拿掉了再拿掉了。
<strong>从C++11这边就o k</strong> 。这个就是这么小的一个东西啊，我们现在很轻松的一个主题。好，我去看看，他告诉你可以这么写，那我就很有兴趣。那标准库是不是都改成这样的呢？的确呃，当时啊我在看4.5版。
四点五版。
这边就已经变成这样子了。所以他已经开始运用新的这一种语法。</p> <ul><li>C++11的编译器变聪明了2333，可以那么写，标准库都变了</li></ul> <blockquote><p>nullptr and std::nullptr_t</p></blockquote> <p><img src="img/C++%E6%A0%87%E5%87%8611/03_02.png" alt="01"></p> <p>然后nullptr以及那这到底是什么呢？看起来对它对比，而是对比我这边准备的是一个type。标准库底下的一个Type，所以左边这个大概是个object咯，一个对象咯？一个东西喽？ 不<strong>过也有人把他当作，说他是一个关键字</strong>！！这个倒也无所谓了。
好，这个东西叫null point。就是<strong>零的,空的,指针空的指针</strong>。</p> <ul><li>这边说C++11 的允许你使用nullpoint 这个东西，这个关键字来取代替0，或者是代替NULL</li></ul> <p>额，NULL是怎么用的呢？
在在此之前，2011之前。
你要把一根指针设为空指针的话，设为零指针的话呢，你赋值给他是0也可以，可是感觉不太对味！！</p> <p>那个味道不太对！！
<strong>指针嘛，怎么让他变成零呢</strong>？？？
所以『通常』就设为大写的这个NULL， 其实呢这个NULL定义就是0『23333』</p> <p><strong>那现在说啊，我们把它区开来吧，因为零是个数值，NULL应该是个指针，那不然我们</strong>。是不是把它区分开来呢？<strong>就出现了新的关键字</strong>。</p> <p>现在看这个例子，我是记得两个函数叫f 都叫f， 所以说函数重载咯，他们的参数不一样！！</p> <p>如果我这么调用，<strong>上面2个是函数的声明啊，下面3个是调用</strong>。如果是这么调用的话。
编译器一看，0是个整数。他不把0当成一个指针呢，所以调用的是后面有注解。第二个是上面这个版本。如果是下面这样呢。传的是NULL指针
就算not permanent，这个关键词是灵好了，但是<strong>编译器也知道，其实你的意思是来他是要传一个指针进去</strong>。</p> <p>所以第2种呢是这个版本。后面游戏。那如果你传这个。<strong>大写的NULL进去会怎么样呢？<strong>那就看看这个NULL 是什么了。刚刚我说</strong>在前头2011之前，这个NULL 其实定有一个它define 他定义就是0</strong>。</p> <ul><li>如果这样的话，第二个就是上面那个版本，因为零这个整数要到上面的版本，这里有写了。如果呢大写的NULL那是零，这样的是上面那个版本。</li></ul> <p>但如果这个NULL不是零，但那其实是0啊。但是我是说<strong>如果</strong>你传了一个你定义的一个符号进去，他不是0的话！！</p> <p>那编译器就不知道，比如说你曾经一个3,2,7,6,8。
32768是个整数吗？当然是！！
可以说是一个地址呢？？也是啊，也可能是啊？
所以编译器就不知道你到底是要调用谁</p> <p><strong>好。那这一个东西（指着nullptr）！！</strong> <strong>这个东西它的类型是什么</strong>？</p> <p>是这一种呃，下面这段文字是这种Type『指着<code>std::nullptr_t</code>
那这个Type 定义在这一个头文件里头。这个Type又是什么呢？我实在很想看一看他到底是什么??所以我就把这头文件挖出来。</p> <p>前面不是有提过啊，这个是一个<code>延伸文件名称</code>在·。h·的。</p> <p><strong>不过新的标准是前面加一个c</strong> 所以这两个其实那是同一种同一个东西。</p> <p>同一种东西lef 可能是这一个内涵他吧。我得实际去看才下。</p> <p>好，那这里面就有我们刚刚在讨论这一个type 到底是什么Type，这边就有个定义了。好，这个是又是一个很小的东西，叫做nullptr</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/03_03.png" alt="01"></p> <p>》 关键字auto</p> <p>以前在谈auto 这个字眼的时候会出现在什么地方？</p> <p>我们会说啊一个function有一个auto  variable（ auto 变量）</p> <p><strong>当时在讲这个字的时候，是说为什么讲一个变量是auto 变量呢？</strong></p> <p>我们说1个函数，如果他有local， local 就是本地的变量的话！
<strong>那这个函数结束的时候，这个变量的生命就消失了，他自动会消失掉</strong>。</p> <p><strong>所以我们把local 局部本地的这一种，一个函数里头的这种变量叫做local 变量，又叫做auto变量。是因为这样，他自己</strong>的生命会<strong>自动</strong>消失。</p> <blockquote><p>可是现在谈的不是这个！！！！</p></blockquote> <p>现在谈的这个auto 呢。是这么用的
这么用：他的意思是告诉编译器说。
我<strong>啊，现在也不知道这个变量是什么类型，你就自己帮我推一把</strong>！！</p> <p>那我就告诉你说，这是一个auto 变量。『此auto非彼auto』</p> <p>『『其实编译器在编译的过程里面<strong>当然知道</strong>什么东西是什么类型。』』
也<strong>因此才可以做模板的实参推</strong>导argument deduction 实参推导。</p> <p>编译器本来就具备这个能力，现在在C++2.0**，它就把这个能力表现出来**，让你去使用，就是这里的aoto。</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>现今有很多经典的语言：
这一种经典的，古典的这种语言呢！！
从Pascal开始到C++到java到C#都很重视type ，变量的type 类型。

所以如果是使用这种语言的呢，都特别的对于类型敏感！！！呃，特别的概念清楚。
所以我们是希望程序员要很清楚类型的体系。不要。
因为有了这个屠龙宝刀。
反正他会帮我推，我就什么东西。auto，不要这样！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><ul><li>所以这个auto这个关键字。主要是帮助我们怎么样呢？</li></ul> <p>这边有讲了：使用auto 是特别有用，在什么地方呢？</p> <p>在于这个Type 啊。很长，你实在懒得打那么多字。或者这个type 实在是很复杂。
所以一时间想不出来你，你大约隐约有印象，但是你一时间可能写代码来容易有点出错！！！
这两者我们都可以举例子。
1、太长的这一种。像以前在写迭代器i就最常碰到这种情况。</p> <p>但是我们其实心里面得知道</p> <p>2、那第二种呢就是说这个类型呢有点复杂，了一下想不出来。
lamda表达式！！</p> <p><strong>lamda表达式，它其实是一个没有名称的函数！！『或者叫仿函数！！！</strong>
没有名称的仿函数</p> <p>好，暂时不管他，总之我们很少人能够写出一个Lamda表达式的类型出来，但现在你是要这个那么大，用l 就表示这个Lamda。嗯，本来必须写出l 的类型。
现在说啊，实在是也写不出来了啊，就是auto。</p> <h3 id="『-补充自后一个视频』"><a href="#『-补充自后一个视频』" class="header-anchor">#</a> 『 补充自后一个视频』</h3> <ul><li>关于auto另外2张投影片。</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/04_01.png" alt="01"></p> <ul><li>的</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/04_02.png" alt="01"></p> <p>我总是很好奇，所以有这些新的语法出来，或者一些新的更好的一个东西东西就对象啊出来。那自己本身标准库自己本身有没有去用到他呢？比如说。
点你说我现在有auto，看起来是关键字很不错啊。标准库有没有去用啊？
我就找了一下，这很容易找到你用刚刚我讲的任何的一个全文检索版本，很容易找到。</p> <p>但如果是旧版本的这个操作符的返回类型，那就长啊就是圈起来这一块。
我们现在不去解释他。我有另外一门课叫新加压标准库比同学会谈到，像这种东西怎么会成为这么长呢？是成为一个迭代器。<strong>里头的经过萃取机萃 取出它的difference type</strong>。difference type 就是那个距离<strong>两个迭代器的距离</strong>。
为什么会说需要设计这个那个其他的课程会去提我们这里不具体。所以这两个的差别啊这么长一串就变成auto这个字眼。标准库本身也有在使用这一个新的关键字。</p> <h2 id="⏳04-一致性的初始化"><a href="#⏳04-一致性的初始化" class="header-anchor">#</a> ⏳04. 一致性的初始化</h2> <blockquote><p><strong>Unifrom Initialization</strong>，一致性的初始化</p> <ul><li><p>4分钟的时候，才开始</p></li> <li><p>这个特性，背后其实是<strong>下一节</strong>的在支持</p></li></ul></blockquote> <p><img src="img/C++%E6%A0%87%E5%87%8611/04_03.png" alt="01"></p> <p>接下来我们谈：</p> <ul><li><p>uniform initialization 叫做『一致性的初始化』，设初值啦</p></li> <li><p>既然谈到一致性，<strong>大概表示过去不一致哦</strong>，</p></li> <li><p>Q：是这样吗？？</p></li> <li><p>A：是这样的！！</p></li></ul> <p><strong>在C++11之前，程序员哈，特别是一些新手很容易困惑于1件事情</strong>：什么事情呢？就是要初始化变量，或者初始化一个对象的时候该怎么写？？
这个初始化呢，可能是发生在<strong>小括号</strong><code>()</code>，发生在<strong>大括号</strong>，或者是发生在<strong>赋值符号</strong>上面。
这一段话的意思：这个就这3个动作，可以表现这一段话的意思。这是我写的某一段代码里头，以前写的代码里头呢。但是不止在设定初值的时候。
这是一种写法。
下面这是一种写法。
这是第三种写法。『『指着下面的3个框框说』』』这是呼应上面这段文字。</p> <p>现在C++2.0，说基于这个原因，现在导入了一个观念，叫做<code>uniform initialization</code>，<code>一致性的初始化</code>。他的意思是什么呢？？？
<strong>任何初始化动作，你都可以用一个共同语法，只有一种语法</strong>。
那就是用大括号！！这个叫一致性。
当然现在你还是习惯用以前的那也不会错，这个都是回溯相容的啊。</p> <p>这个不可能推翻掉以前的东西。但现在。你可以全部都用大括号，<strong>比如上面这样黄色的部分都是。<strong>这是一个数组array，大括号，就是</strong>在变量的后面直接放大挂耗电量</strong>。名字叫这个吗？</p> <p>在变量的后面直接放大挂号就是做一个初始化的动作，直接设初值。</p> <p>继续讨论！！
<strong>虽然看起来形式都一样，其实技术上有点不同！！</strong>
1、首先，我告诉大家，这个大括号一出现，其实拿来当初值，是因为这一段：：<strong>利用一个事实</strong>，什么事实呢？</p> <p>编译器只要看到大括号一出现。他就做出一个这种东西出来『指的 Initializer_list』 我们后再过2,3张投影片，就要开始讲这个东西。</p> <p>所以做，所以左手边，黄色的部分有4段，其实就是四个音量。这个内部其实是<strong>关联</strong>到一个array。这个array 指的是，标准库里面提供的一个容器。</p> <p>2、注意一下这边我的表现了。说做出一个这一种东西出来，他的类型是t 那t 是什
题是什么？现在就呼应：：为什么他在新的标准里面提供？『一致性的初始化**』其实是背后有所谓的initialize list 在做支持**。我这里还没讲完，但是你看前看下一
3、但是这边还有一句话。但是如果调用了这个函数呢，它的参数就是这种东西。
因should like the least。调用者却不能给予数个，然后以他们就是说这句话是什么意思？
有的函数的设计，他接受的就是一个这种东西。</p> <p>我们后面投影片，接下来就要讲这种东西嘛。
在此之前，2.0之前你从来没看过，因为这个也是新东西。但<strong>现在说如果有的函数它的定义的时候</strong>就这种东西的话，那现在刚刚不是说过这些蓝黄色的部分，就是形成这种东西吗？所以就整个就传过去，<strong>就不会像这样逐一分解啊</strong>。</p> <p>所以在函数的调用这里就是不知道函数这里在调用这一些东西。
大括号就形成了一个。in the list.
4、<strong>原因</strong>：：『『『如果这个构造函数的设计不一，它本身不是函数，可以有很多个嘛，<strong>其中有一个版本。他就是接受这种。initially_lis</strong>t. 他就是接受这种的话，那黄色的这一些东西就整包转过去。』』</p> <p>编译器会自动的把它拆解一个一个的来丢过来，来调用这个函数。
所以这是两种情况这是两种情况。啊，具体说说，但是如果他参数本身是这一样的一个。调用者却不能。
<strong>这什么意思呢？</strong>
以刚刚构造函数来讲。如果他只有这样可接受这种东西。如果说要这个版本的话。
<strong>调用者必须准备一个这种东西去调用它！！</strong></p> <p><strong>不能够呃，好像杂牌军一样</strong>，自己准备了几个呢，就以为这几个会被编一些合成一包来调用。</p> <p><strong>后面还会有更详细的解释。当我们去理解initialize list。</strong> <strong>这里面的设计就会更清楚。</strong></p> <p>一在整理一次是什么？这个地方已经形成了那个一包了。
<strong>而构造函数也有一个版本，是接受这样一包。那那太好了。一包传给一包。</strong> <strong>我怎么能说出这一段话呢？因为我看过标准过的源代码。</strong></p> <blockquote><p>所有的容器都有这一种构造函数！！！</p></blockquote> <p>这一段源代码全文检索得到的结果呢，在后面投影片我也会展现给你看。</p> <p>『2』但是这这个情况又不一样了。这一个也是形成一包这个名字太长了，我就这一包好了哈。你说。like the least the er.
他也是形成一包。
这背后有一个array，这个这个说法完全跟上面一样。
在元素是两个。
但是他在调用comm px 的构造函数的时候。
count 构造函数。
『『没有一个版本是接受一把握这种东西。』』
你有一包东西，你传给的那一个，你要调用那个函数，他不接受一包，他就说一个一个。
所以这时候说什么？编译器会把那一包的那两个元素分解，传给构造函数。
这都是看了。
因为我看了这个一次性的<strong>设定初值之方法</strong>啊，这当然很简单的，你看啊就是这么用，但是他背后牵扯的东西，就看了源代码挖出来以后整理成这一些文字就更深入的东西！！！</p> <p>如果这么复杂，你不想理解的话，那就是你回到这里来黄色的部分你就这么使用就对了。然后接下来我们就要去谈：这个Initializer_list</p> <h2 id="⏳05-初始化列表-上"><a href="#⏳05-初始化列表-上" class="header-anchor">#</a> ⏳05.初始化列表(上)</h2> <blockquote><p><strong>Initializer_list</strong>，初始化列表</p></blockquote> <p><img src="img/C++%E6%A0%87%E5%87%8611/05_01.png" alt="01"></p> <p>刚刚谈的这一个一致化的设初值动作，可<strong>能会让你掉以轻心</strong>！！</p> <p>觉得说：反正就是设初值嘛！！那也不过我就把习惯性的把以前呢，呃好几种作用写法，我改成大括号的写法，或者我不改也没关系呀啊！！</p> <p>呃，在使用设初值，在设初值这一件事情上面，的确它是个小事情。但是为了完成刚刚讲的一致性的设初级的动作，<strong>它背后呢，所牵扯到一个新的设计，却对于标准库影响很大</strong>。</p> <p>刚刚有提到在设初值的这个大括号过程里面，其实你可以任意放元素。所以这又来一个任意放元素了，**这个有没有让你联想到一开始我们给你们重磅炸弹very attempts. **。</p> <p>大瓜号的背后其实是这个这一个东西做出来的。这并不是刚刚那颗原子弹的very i addict template！！！不是啊不是，但是这1个呢也很重要，因为他也要来接受个数可变的元素！！</p> <p>东西有变化，这件事情本身就不太好实现出来。所以我们前面讲过very addict template 可以实现这个这个initialize。the least 呢也是要来解决这个东西有变化的这个。那么现在要谈的就是说，那个大括号其实形成了形成了一个Initializer_list</p> <p>我们先看一些小东西。这里说的事情是什么？
他可以设定初值，他本来就是在设定初值用的呀，不是吗？大括号一次化的射出刺动作吗？
但这里的意思是：像这种写法的话，i他到底是多少是不知道的，你不能假设他是0。</p> <p><strong>我想这个从c 以来，可能老师都告诫过你，谆谆教会你很多次了。所以你如果需要一个初值，你要把它写出来，你不要默认的以为他有什么初值</strong>。</p> <p>那下面这样呢，那这就是设初值，虽然你初值没有写，但是他就是你他为什么是0，因为现在的利现在的团队形式。i n t i n t 的充值的对a 默认为是你。</p> <p>同样的道理，这一个这个值这是一个指针。它的初值是什么？不知道不知道他指向哪里。
但是如果是这样子写的话呢：</p> <ul><li>所以大括号可以用来设初值。</li></ul> <p>1、然后我们看下面这一个。
说如果你使用大瓜号。
但是你里面放的东西，汗原来的类型，声明的所有的类型。
这是<strong>转不过去，那当然不要提了，编译器就停在这个地方。</strong>
报错。
但是如果<strong>转得过去的话，他是不允许你这个叫做缩小</strong>的。窄化的一个转换！！
比如说这5.0是应该这个浮点数。
<strong>他转成整数，5.0应该转成5，本来就是共同的可以通过的。但是如果你用大括号就不能！！。</strong>
这边说error a l l 这里有三个error，你看一下都是。
都是一种窄化的转换。
这这不不可以！！</p> <p>2、嗯。但是这一边呢<strong>是一些书籍上文章上写的是过于强硬</strong>。
<strong>我实际在我的平台上面，我的平台是什么</strong>？前面讲过了，做了测试呢。
<strong>他只是给警告！！</strong>！
<strong>这是一个小小的地方呢来提醒大家。</strong>『可能只是警告！！！』</p> <p>好，然后我们再往下来看一看，这个背后就是一个大瓜号所形成的其实是这么一种东西。
我们来好好的研究这个东西。</p> <ul><li>他说他可以接受个数不定的元素进来，就是大括号里面你可以任意放元素！！</li></ul> <h2 id="⏳06-初始化列表-下"><a href="#⏳06-初始化列表-下" class="header-anchor">#</a> ⏳06.初始化列表(下)</h2> <p><img src="img/C++%E6%A0%87%E5%87%8611/06_01.png" alt="01"></p> <p>我们从。
一次性的。
初始化方式是初级的方式。
谈到了那个大括号，其实是形成一个。
initialize this.
然后再谈到。
那所谓initially the least that 只是一个观念，背后到底是什么呢？
背后就是这一个class 的支撑。
我前面提到说，也许你会掉以轻心，其实呢这个就是叔侄嘛，形势反正就是大括号。
那再往下挖在到底在挖什么呢？我说他背后要靠这个class 支撑，这个class 影响了标准库的实现。
啊，在新的版本上啊有相当程度的影响，并且货币也会介绍在下一张投影片哦，就就这一张投影片就会介绍。
你也可能自己要需要用到这一个class。
好，我们来看看。
直接看例子吧。
我写一个函数叫print。
上面是定义，下面是调用的方式。
如果我愿意。
我想要接受任意一个个数的东西。
我觉得这么写，用这个initialize the least。
我这么写的话，使用者他就可以这样调用了。
用大括号。
形成了。
一串东西我前面提过背后是一个呃瑞一个数组啊。
这一串东西。
第一期会把它变成是这自动的把它写成是这一种东西，然后存进来。
所以他这是可以实现参数个数。
不对。
这个结果。
那前面的那个v attic template like a 重磅炸弹啊。very at this temperate.
他是比这个更厉害，他不但可以接受任意个数，而且这里面的类型都不类型都不一样。那个我们前面已经介绍过观念的嘛。
再一次让你区分两者的不同，这里面呢都必须是整数，为什么？因为这个卡函数定义的时候说我要接受的是总数。
传进来之后，我们看看怎么用。这也是一个你也可以把这个当成是一个容器，容器怎么用就很大家就很熟悉的。
这边用一个follow。
for 循环。
取出他的头。
取出它的尾巴，把那个头一直加加，这样就是不断的再循环。
下面我们用到前面介绍的这个o to o 这个关键字，可以让我们很方便的写这一串。
这样我就一个一个的取出。
这里头的每一个元素。
就可以把它打印出来把它打印出来，或者做任何处理。
所以你也可能会需要写这种函数，那你就会要用到这一个。
卡拉斯。
我们再看一个例子。
我现在设置一个class 叫p。
这里有两个构造函数。
这个构造函数接受a b。
这个构造函数呢接受的是一个这一种这这这这一包哇，这我从从现在开始，我把这个叫一包，免得我这念出来实在太长了。
这一包也就是我们标题的这个东西。
我设计了两个版本。
我们看看。
这是一个class。
接下来呢我要做出四个对象是个object。
有的是用小包号，有的是用大括号的，是值，我们看看谁会这样，到谁，这里都有输出结果哦。
这就输出。所以这边呢光看这个输出结果注解，我把输出呢抄过来，所以你就知道谁要用谁了。
啊，一定要请注意一点。
好，我这边画了一个箭头。
不要误会，我再说这个第二次调用调用到第一版本，我不是这个意思。
第二。
p qrs 这q 啊。
调用的也是第二版本，后面有后面是这个执行结果嘛。
啊，所以千万不要误会的这一条线的意思这一条线的意思是说当负数的时候是这种情况。
这等一下再说了。
好，我们来看看为什么是下面四个调到谁的解释一下。
第一个动作。
他小小括号两个参数。
当然是先调用环北一啦，这完全吻合。
第二呢。
p, q r s, the q 呢浙大括号是形成一个一包。
一包就是这种东西啊。
形成一包，所以当然是调用到二楼。
这边输出结果我就抄出来。
三呢qq rs 这个r 呢这个也是一包啊。
所以调用呢也是版本二这一包。
四呢第四个。
这个。
这个也是一包。
这个等号这个你可能会想，这不是应该调用到操作符重载这个。
算这个符号吗？
啊，这个叫很多私家叫程序员，常常会即使你是老手的说。
乍看之下也是会误会，其实这个因为它是在直接建立一个新的对象，所以第二种是构造函数。
上面就是构造函数。
好，那他第二的是这也是一包啊，大括号是一包，所以这样道理是。
版本三呃，不是不是版本三c p q r s 这个rr 还有三个参数啊，这里一包是可以接受任意个数。
所以三个也是可以进来。
这样来解释啊这四个调用动作所调用到的谁是谁。
下面有注有一些说明。
啊，如果一杠二只写了在说什么呢？
如果没有二，只有一的话。
没有二啊。
只有一。
那么下面这个p q r s 会怎么样？
不影响p 对不对？基本来就是调用意义嘛。
其物呢？
修正两个。
本来应该调用版本二，现在帮忙二不在。
那么。
编译器。
会把这一包东西。
拆解。
拆解为两这个例子拆解为例啊。
下一个例子就拆解为三个。
好，这拆解为两个之后来看看哦，这款粉衣就是接受两个。
于是他会调用到分贝。
这是这里所说的，如果你没有版本二的话。
那么那个接受两个参数的两个整数的那样一个构造函数啊，也就是这里的版本一。
他还是可以用来设q ns 刚刚才讲的是qu 啊。
他被拆解开来放进去。
在此也可以a s 是什么，s 跟q 是一样的嘛，都是要用构造函数同一件事情。
但是不能够拿来这个r 就不成立了。
因为啊拆解开来是三个参数。
现在只有版本一。
这是不吻合的。
我们借由这个非常细琐的探讨。
就能够玩，目的是完全清楚这个initialize the list，它作为函数参数的时候什么情况被调用。
什么这个这个取舍，这版本一跟二的取舍。
好，现在我来解释这一条线。
我要说这条线我要说明什么呢？说。
come mx 就是这种情况。
compose 本身没有版本二这一种构造函数他只有一。
但是前面我们在。
这样我来翻到前面去。
啊。
复数。
好，给我三秒钟的时间啊，这里找到了。
当初我们在讲一致性的初始化动作的时候，我有这么一个例子，复数嘛。
而且这里就是这个一包。
这呼应我刚刚所讲的东西，马上又要在跳舞到那个地方去看了这个东西。当时我这边有一段说明。
讲的就是。
刚刚所说的那一件事情。
啊，注意这一页，这一回到这一页来，然后再比对看看我们进行到的这个地方。
这一条线我说就是这种情况。
下面注解告诉你他是可以被调用起来的，会这样到一。
右手边就是影响ize list 的源代码。
我这个人对技术的挖掘就有这个习惯，就是挖到我满意为耻。
现在对于要来看看怎么用是很清楚了，这个东西怎么做。
好，他的data 我总是先看他数据的部分。
他的dat 在这里。
看到一个array。
那前面已经打给各位打过底了，他背后是一个array 的支持。
还有一个长度。
但是这个array 呢它不是真的，而为他只是一个迭代器哟。
不过好像他背后是一个array，而这里呢是一个头部，有那些指向头，我们可以推想是这样，我们还没有看细节呢。
在他的源代码里面，这边有一句话很重要一个注解。
他说编译器能够无调用一个private contract。
这一个control act。
放到private 里头。
按理说就没有任何人没有任何人。
能够以这种形式来创建一个对象喽。
因为他是。why did?
但是他说编译器可以。我这边歇会。
那边现在什么时候来做这个事情呢？就是在当他看到大括号的事。
他就要制造出一个这种东西。
要制造出这种东西，他就会调用这一个地方，这是right。
第一次有无葬权限？
我们不能调用它，可以调用。
他调用它是做什么事情呢？他传建了一个迭代器，跟那个大小。
事实上，那在这个地方解释就没有继续解释下去了。事实上我可以告诉你。
第一期在调用它之前已经先准备好一个array。
然后把这个额外的头传进来啊，长度存进来存进来做什么，被他登记起来。
登记起来。
所以戊因我这前面强韩国的话可能讲好几次了，这一个东西这一包东西背后其实是一。
个array array 是一个二点零之后的新的容器。
这个就是而为的元代嘛。
这是tr one 的版本。
为什么我要加拿提rone 呢？
怕把大家吓着了。这个是四点九的版本。
四点九的版本所做的事情跟tr 湾的事情完全一样。但是四点九的太复杂了。
我也花了不少时间才把它理清楚。
所以我们要谈观念，我们其实拿的哦tr 万来谈就够了。
好，那我们来看看。
一个array。
其实就是。
换一种形式来表现c 加加本身的数组，这种东西换了个形式，数组就是一块内存。
现在转成这种形式来表达，就可以用到标准库所有的容器所会用到的那种接口。所谓提供的那种接口。
什么头，the game.
就是头头指向头的迭代器，n 的就是指向尾巴。
尾端的那个迭代器等等等。所以他的身份就会跟其他的容器一样。
汉其他容器一样带来什么好处呢？它就可以被那些七八十个算法来处理。
因为算法算法啊指认迭代器，所以他必须提供迭代器。
但是我们就讲到这样。
所以在这个地方，tr one 这个版本我要带大家看的就是里头确实有一个瑞在这里。
这个写法就好像我们在城市里头鞋又右上角这样。
你慢慢体会一下。
其实是完全一样的，但是这里面会判断说你传进来的这个n 这个值啊。
这样这个地方给一定十嘛。
到底。
呃，如果是是十的话，那么其实得到就是。
如果他如果是零呢，得到的是一哦。
所以你可以指定说我的array n 长度是零，而实际上内部他会变成一，因为没有零这种程度的。而瑞。
他实现的小细节。
有关于array 啊，包括这个让人很害怕的这个源代码的怎么看呢？这个四点九版的怎么看呢？我们后面再讲第二讲讲标准库的时候。
会再回来看看这个东西。
目前这样就够了。
这tr one，the ray 里头是有一个真正司佳佳的数组。
再回到前面来，刚刚这边说。
精益气呢？
会准备好这个而锐之後来调用这一个private 私有的构造函数。
啊，投传进来啊，长度传进来。
这样我们就把整个关系挖的够深了，全部都理解了。
嗯，好，那进行到ti y 四点九版，我们继续往下看。
你手上都有讲义，按照这个次序啊，所以这个很容易这样子不会搞混。
进行到这一页。
我把这个源代码再抄一遍到这里。
这一块是什么？
这一块是刚刚。
你在前面出现过这个版本，一跟二。
以及他的执行调用的情况全部都再抄一遍到哪里了。到现在这一夜来。
所以这一夜的新东西是下面这些解释。
我们来看看这里面在说什么。
这第一段的意思我不要逐行的这个翻译过来啊，他的意思就是他会我刚刚所说的。
这个东西背后有一个array 在支撑。
中间这一段的意思比较一个新的观念跑出来说english lesson list 这种东西object object 就是东西，就是对象这种东西呢。
他只是refer to。
the elements of this way. 背后那个av 他不是内好without containing，没有含着他们。
这句话的意思。
看看源代码。
当编译器调用这一个构造函数，要建立这一包东西的时候，他只是船头进来，船长度进来。
呃，这跟这一个指针就指向那一个，而瑞了他并没有内涵着他。
就是这个话的。
所以后面又讲了，如果把这一包东西。
initialize the list to copy 的话。
所产生出来的另外的那个东西，你copy 就有另外一个新东西产生出来的这个东西只是refer to。
the same 相同的底部的这些元素。
应该是里头只有这根指针。
c 一包东西里头只有指针指向array。
所以拷贝过去是一个浅拷贝。
他当然发现设计上。
要做深拷贝也可以，不过他只是一个浅拷贝。我看这边我也没有把他拷贝的动作列出来。
大概是没有。
呃，好。
没有，那我可以告诉你，他其实里头只是把指针拷贝过去。
那这样的意思就是原来的这一包跟新的这一包，它里头的两根指针就指到同一个而委屈。
这件事情当然是危险的危险。
啊，会不会到底你会不会去把一个这一个一包东西去做拷贝动作呢？
呃，不知道说万一你真的有去做拷贝，你要注意这句话。这一段话。
他会形成一个两个指针指向同一个array。
好。
前面我提过。
这个一包initialize the list。
相当大幅度的影响了标准库里面的实现。
怎么讲这个话呢？
我用那个全文检索工具去查看。
因这个这一句这个这个initialize the least。
我找到了这么多的结果。
这字很小。
我找到了，结果显示。
这是一个容器容器vector 艾特大家最熟悉的这个呢deck，这个这是字符串，也是一种容器。
这是什么？
这个是算法啊，连算法都用到了啊，这个呢都是容器容器容器容器还有算法。
都用到这个东西。
他们在做什么事情？
这些容器现在的设计是。
接受在构造的时候，构造函数接受你指定任意个数的一个元素，当成他的出资。
我现在把vt 这一部分放大，其他容器都差不多。
都这样啊，现在放大。
这里面由于我这个地方全文检索，看到这四个函数。
都有用到这一包的东西。
所以我就把这四个函数。
这个都有行号，还把它。
函数了超出来的这四个一二三四一二三四。
这里头这也就是这个是that 的源代码了。
这四个函数呢所接受的参数都是这一包东西。
蓝色的。
那么在二点零版之前，c 加加二点零啊，谢谢大家。二零一一之前没有这种。
一包没有这个东西，所以这边的写法就要把更多的精力，更多的代码才能够去接受。
数量不定的参数。
所以我们说这一个东西要不就是像这样在标准库大量用到了。
要不就是在前面我有一个例子是print，你可能会需要写出一个print 函数，接受任意个数的元素啊，那是你自己可能会用上。
这是标准库已经用上。
好，那这些都是容器，其中有一个是算法out the 这里面mini 马max mara。
mini max.
有这这六个函数有用到这一包。
我来示范一下用法。
我写了一段代码的这里。
这个vector。
任意放元素。
这样就会调用构造函数。
构造函数的源代码这边已经出现了，刚刚已经看过了，这个我在示范着用这一个给你看。
再回到这里来啊，你可以像第一行这样写，也可以像第二行这样写。
或者像第三家四。
这样写。
或者这下面这行insert 刚刚。
刚刚这边有人代码有insert 这个版本嘛，这这这里。
我就像这样子，我的用意就是去用一次给你看。
好，执行完以后做一个输出啊，这个就没有意义，没有什么特殊意思。
这里头的每一个动作，他所调用的是什么？就是这里这三个就是刚刚上一页这个源代码啊。
最后看这四个函数的调用。
如果你以前用过的话，你就会知道这个mini 嘛跟max 嘛只能放两个元素。
最大跟最小，他拿a 跟b 如果纯粹是xy 好了，它它比xy 造出大的，按照中小的。
但是现在能力扩充了。
我可以放任意多个东西进去，帮我找出最大，或者帮我找出最小。
像我各用了两个例子，分别放的是字符串。
或者是放整数。
那字符串本身的比大小方式，他有他自己独特的一套，我们叫做字典形式的排列次序。字典怎么排，各位很清楚吧。
呃，a b c 一悍a c e d。
是比较大。
a b c 长度是三。
a c e d 是四。
他是a b c，b a c.
第一大。
这你你查字典，你就很清楚这个他是怎么排列的。
各位都用过一英汉字典。
所以这个字符串各位这样子看，这五个字符串谁比较大，最大的是谁呢？是s 开头的。
这里有一个spring 娜，这里一个xc 比较大的。this is 是最大的输出。是这样，那谁是最小的呢？a 开头的意思是最小的。
输出结果。
那这个数值放进去，这个就大家都很清楚了啊，数字的大小。
为什么你能够放任意多个元素呢？因为现在mini 马跟max mara 有了一个新版本，旧版本仍然存在啊。
版本是只放只接受两个参数，现在这个新版本可以接受任意参数。
这不是很棒吗？
你的函数呢尤其特别在mini 嘛跟max 马这两个函数身上，它的名称身上让你特别感受到，你可以放很多个元素进去，这是一件很合理的事情。
而不是只发两个元素进去。
我对于这个initialize list。
这一个class。
深入的挖掘啊这个地方。</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/06_02.png" alt="01"></p> <h2 id="⏳07-explicit-for-ctors-taking-『more-than』-one-argument"><a href="#⏳07-explicit-for-ctors-taking-『more-than』-one-argument" class="header-anchor">#</a> ⏳07. Explicit for ctors taking 『more than』 one argument</h2> <ul><li>对于接受多个参数的运算符explicit</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/07_01.png" alt="01"></p> <p>接下来这个主题explicit，小事情：这个标题说explicit，这个是一个关键词，
他要用来，用来干什么？<strong>是针对构造函数</strong>，并且<strong>是接受一个以上的实参</strong>！！
要用，要讨论这一件事情，那在化成代码就是这样的形式！！！
这是一个class。</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/07_02.png" alt="01"></p> <p>标题说要讨论这件事情：要讨论这些事情之前，<strong>要去看一看2.0之前</strong>的一个主题，看我把more than 划掉了！！！</p> <p>『『『所以我们先看看explicit的这个关键字，<strong>用在一个实参</strong>的构造函数身上，<strong>那又是什么情况</strong>，然后才能去讨论2.0——一个以上的实参』』』
好，我们先看这个——现在我这里有两个class，在我自己写的这个复数class，这跟标准库那个不一样！！大写的，标准库是小写的没有冲突。</p> <p>左边这一个呢，这是左右是完全警醒的，所以你特别容易让你比对。
<strong>左左跟右唯一的差别在于右边</strong>，这个是。</p> <ul><li>explicit这个关键字，他其实用途其实很少，<strong>主要就是用在构造函</strong>数身上。</li></ul> <p>好，我们先看左边的。
你设计一个复数，接受实物跟虚部，如果你需不默认为零的话啊，你可能设计出这样的版本。</p> <p>这是你这么写的话，好，如果使用者这么用，看看会有什么结果！！这意思是说我有一个负数，他是十二加五i。下面这一行是我有第二个负数，他的值是。上面那一个加上五。这个家务啊。编译器看到加5。
他会去找出来，他会想办法把舞看能不能够转换成复数。</p> <p>所以（编译器)他去看看，那这一期就看能不能能不能把<strong>五变成五加零i。</strong>
根据刚刚的分析——好，编译器也够聪明啊，他知道哦！哎，你这边有一个默认的版本。所以，5他就把他要用这一各构造函数。变成你家零i。 所以这一行就会通过。得到了结果就就两个复数相加。『『如果这是你所欢迎的，当然那很好。』如果你不欢迎这一种。在这个负数这件事情身上，当然我们觉得很自然，因为对数学上确实是这样啊，我们觉得很自然。<strong>但是如果他其他的例子里</strong>面，你<strong>不想让编译器这么自动。</strong>『『这一种叫做隐式的』』把5暗中转换为了复数。。</p> <p>如果你不想要编译器这么自动的话。你可以在这边加上一个explicit！！
那就是告诉编译器说不要自作聪明！！要在我『『明确』日如果调用它，这在我明确调用构造函数的时候，你才来调用它。
啊，<strong>不要帮我做：on the table,————桌面下的转换。</strong>
所以当写出expressive 的时候，下面这一行这个。就会失败。因为你<strong>阻止了编译器的那些自动的行为。</strong></p> <p>像这样的话，编译器的报错信息是什么呢？在我所使用的，我前面讲过，我用什么样的编译器啊，在我所使用的的编译器上面，他就会说。no match for appropriate. 七。他找不到能够相匹配成功的函数。</p> <p>『『『这就是加 或不加explicit 差别的这里。』』</p> <p><strong>关键字explicit的就是明白的，明确的！！</strong></p> <p>换句话说就是告诉编译器，我这个函数要<strong>被明确</strong>的调用，你不要自动帮我做转换。
<strong>这个是在C++2.0之前，早就存在的事实和用法！！</strong>『『『注意，注意，C++2.0前的，是这种对于1个参数的用法！！只存在于单一实参才可以哦『『一个以上就和这个无关！！』』！</p> <h3 id="『c-2-0开始的』c-2-0新特性『c-98有很小的用途』"><a href="#『c-2-0开始的』c-2-0新特性『c-98有很小的用途』" class="header-anchor">#</a> 『C++2.0开始的』C++2.0新特性『C++98有很小的用途』</h3> <blockquote><p>易错的定义！</p></blockquote> <p>『指着左边』只有这种。像这个叫做什么？这个叫单一实参哈！
这话要<strong>解释的更透彻</strong>一点就是：<strong>它是两个参数</strong>，，<strong>但是你只要指定一个实参</strong>就可以了，因为第二是第二参数是默认有默认<strong>值，所以这一种叫做one argument</strong>。one argument 就可以调用。而且没有加explicit。所以有一句很长的术语啊，仔细听：叫做none explicit one argument constructor！！只有这种constructor的这种构造函数『『<strong>才能</strong>』』够做<strong>隐式的转换。</strong></p> <ul><li>『现在2.0』』这边说，不只是一个实参的，3个2个啊，一个以上的我都也提供explicit，禁止你做转换！！『神奇』</li></ul> <p>用法，就这样子，放在构造函数前面：**在我印象之中，这个关键字『『只用』在构造函数前面。**呃，<strong>在模板那边。好像也有一一个地方会用到explicit</strong>，<strong>但是那个非常非常少人用，</strong>，这个已经够少人在使用了。</p> <p>好，所以现在刚刚把那个故事讲完，现在回到这个故事来呢，就不必再说了。各位知道哈整个整个搬离过来一样的概念：现在这边有一段测试：加上explicit 之后，现在这个情况，那么我创建出这些对象。右上角这是一个类啊。我要根据这个类创建这些对象，『『有的成功，有的不成功』</p> <p>自己看注解！！</p> <h2 id="⏳08-基于范围的for语句"><a href="#⏳08-基于范围的for语句" class="header-anchor">#</a> ⏳08.基于范围的for语句</h2> <blockquote><p>Range－based for statement，基于范围的for语句</p></blockquote> <p><img src="img/C++%E6%A0%87%E5%87%8611/08_01.png" alt="01"></p> <p>很小、很简单、很实用，我非常喜欢的。</p> <ul><li>冒号的左手边是一个声明，右手边是一个容器，就一堆数据，你只要这样就可以了。</li></ul> <p>那么for loop 这种写法呢。这一期把它编译出来的动作就是等同于什么呢？<strong>把右边这个容器的元素一个一个的取出来，放到左边这个decoration 去</strong>，这是一个声明嘛，就这么一个变量。</p> <p>右手边是一对是一对数据，只要是容器就可以了。那是这一个才刚刚才看过呀，就是那一包。就是那个Initializer_list，就是那个背后有array的那个东西。</p> <p>上到这里这个元素了，这个变量了。
那这个变量声明这里是一个reference 引用。
所以这个赋值就会变得很快。</p> <p><strong>有什么容器是不能让你改变元素的内容呢？</strong>
啊，这下看你对容器理解多少，我有另外一门课是C++标准库呢，曾经很<strong>深刻</strong>的提过这个问题！！！
<strong>那什么容器是不可以允许你直接用迭代器直接改变元素呢</strong>？
<strong>关联式容器都不可以</strong>！！！
set ，set hash map 等等等。
我刚刚提到hash，hash_set和hash_map在C++2.0换了一个新名称，叫做unordered_set和unorder_map的不定式啊，这个我们放到第二讲。</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/08_02.png" alt="01"></p> <ul><li>这种for循环，可以等价于右边2种，下面一种是调用的全局函数，让我们多认识一点，在C++2.0中，有这么2个全局函数！！是可以接受容器的</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/08_03.png" alt="01"></p> <p>我们看这一页。
还有什么要注意的吗？for loop看起来就很好用啊，也都讲完了，说下这一夜我们看看。</p> <ul><li>这边说nox expressive type conversion 显示类型的转换！！</li></ul> <p>没有这种。嗯。其实，to get an explicit 关键字。有关了。
啊。我们先不要管这些文字好了，先看看这一段。</p> <p>这个是刚刚才熟悉过的东西。
有一个很长的术语叫做。no explicit one argument constructor. 这个就是one argument。
只要搬离实参，就可以调用它们。
这个他加了显示explicit
<strong>所以不可以做转换哦，不可以，暗中转换的话，编译器不要自作聪明啊，他的意思是这样。</strong>
下面呢？</p> <p>如果我选择使用这么用啊，这个新式的for</p> <p>左边却是c 这种东西。
<strong>所以要转过去的时候。</strong> <strong>就看能不能转的过去喽。</strong>
本来字符串跟c 之间有什么关系呢？那我们也不知道啊，因为这C只是这里的一个例子而已。</p> <p>如果我但如果我的这一个这个c 他在他在。
<strong>他在某种情况下，本来跟字符串是有关联的。</strong>
因此好像本来吃不上，可以暗中的这个暗度陈仓啊，那慢慢的它转成了c。
假设c 是这么设计。</p> <p><strong>但现在我要禁止这个事情。绝对不允许你。暗度陈仓我就加上explicit</strong>。</p> <p>这个for loop本拿到的每一个元素在做赋值动作的时候啊，如果类型不一样就要做转换。那<strong>如果当初源头的地方就不准</strong>转换的话当然就会失败在。</p> <p>哦，在for这个地方会失败。这是。我认为非常好用的。</p> <h2 id="⏳09-default-delete"><a href="#⏳09-default-delete" class="header-anchor">#</a> ⏳09. <code>=default</code>, <code>=delete</code></h2> <p><img src="img/C++%E6%A0%87%E5%87%8611/09_01.png" alt="09_01"></p> <ul><li>注意：<code>=defalut</code>和<code>=delete</code>都是1个整体，他们的那个等号一定要记得。</li></ul> <blockquote><p>可能的联想：<code>=delete</code>并不是我们以前熟悉的那个<code>delete</code>啥的动作</p></blockquote> <ul><li><p>可能的联想：<code>=defalut</code>可能会让你联想到，心目中的默认可能有：默认构造函数、默认拷贝构造、默认拷贝赋值。对，这个东西就和那个东西有关系..</p></li> <li><p>所谓默认构造函数（default ctor）就是<strong>不需要任何实参</strong>，就能把它调用起来的。if你没写，编译器会给你1个，做什么用？什么都没做，，（编译器不可能知道你想做什么事情，所以它只是一个空的函数）那空函数做什么用？如果你只是单一的class，它也没有什么用，但是如果你这个class是要继承其他的父类的话，这个class，这个class的构造函数必须要调用父类的构造函数，这个调用的动作要放在哪里呢？？就要放在构造函数里面『2.02』所以，<strong>这个时候默认构造函数就有价值了</strong>。『它仍然是个空的函数，但是编译器会在你看不到，编译器就会在那放一些隐藏到背后的代码』『我们另外有1页，有些文字会讲到这个事情』</p></li> <li><p>『听得<font style="background:red;">糊里糊涂』</font></p></li></ul> <blockquote><p>C++2.0现在提供</p></blockquote> <ul><li>如果你强制加上C++2.0提供<code>=default</code>这个『算是1个关键字好了』（2333，好勉强），就可以重新获得并且使用default ctor</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token function">Zoo</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Zoo <span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span><span class="token comment">//拷贝构造函数</span>
<span class="token comment">//这个大家觉得很新奇，C++2.0这个叫『右值引用』（Right value reference），这个事情，我们到后面，有1讲，会讲语法，会取谈论它</span>
<span class="token function">Zoo</span><span class="token punctuation">(</span> Zoo<span class="token operator">&amp;&amp;</span> <span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>
<span class="token comment">//现在，告诉你，上面这2个都是构造函数。</span>
<span class="token comment">//1个叫copy construtor</span>
<span class="token comment">//1个叫move construtor</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//下面的是赋值操作</span>
<span class="token comment">//拷贝的赋值，</span>
Zoo <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Zoo <span class="token operator">&amp;</span> <span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">default</span><span class="token punctuation">;</span>

<span class="token comment">//这个叫作，『搬离赋值』（move assignment ）</span>
Zoo <span class="token operator">&amp;</span> <span class="token keyword">operator</span><span class="token operator">=</span><span class="token punctuation">(</span> <span class="token keyword">const</span> Zoo <span class="token operator">&amp;&amp;</span> <span class="token punctuation">)</span><span class="token operator">=</span><span class="token keyword">delete</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><blockquote><p><code>=delete</code>和<code>=default</code>这2个符号，这2个关键字（应该不叫这个吧，，，）<strong>最主要</strong>作用到这些函数身上：</p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、构造函数
<span class="token number">2</span>、拷贝构造『以及对应的，新的，我们叫（搬离构造）好了。。。
<span class="token number">3</span>、拷贝赋值『以及对应的，新的，我们叫（搬离赋值）好了。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>如果你写<code>=delete</code>意思：我不要它</li> <li>如果你写<code>=default</code>意思：我要编译器给我的那1个『即使我已经定义了，我还是要编译器给我的那1个』它的用意是这样。</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/09_02.png" alt="09_01"></p> <p>在学到任何一个C++2.0的『关键字』，我<strong>都非常的有兴趣的看，C++标准库有没有用到这个新的语法</strong>。于是：我就在我的这个全文检索的工具里面，去找，找到了上面的</p> <ul><li>『我去找<code>=delete</code>这个符号，当然，我不知道它会不会空1个，就像<code>= delete</code>这样』</li> <li>最后找到，有空1格</li></ul> <h2 id="⏳10-alias-template"><a href="#⏳10-alias-template" class="header-anchor">#</a> ⏳10. Alias Template</h2> <h2 id="⏳11-template-template-parameter"><a href="#⏳11-template-template-parameter" class="header-anchor">#</a> ⏳11. Template template parameter</h2> <h2 id="⏳12-『4个东西』"><a href="#⏳12-『4个东西』" class="header-anchor">#</a> ⏳12. 『4个东西』</h2> <blockquote><ul><li>Type Alias，类型的化名</li> <li>noexcept</li> <li>override</li> <li>final</li></ul></blockquote> <h3 id="『类型的化名』"><a href="#『类型的化名』" class="header-anchor">#</a> 『类型的化名』</h3> <ul><li>比模板的化名简单多了。『类似于typedef』</li> <li>这个<strong>也是借着using关键字</strong>导出来的。黄色和下面的是一样的意思，写法等价</li></ul> <h2 id="⏳13-decltype『关键字』"><a href="#⏳13-decltype『关键字』" class="header-anchor">#</a> ⏳13. decltype『关键字』</h2> <h2 id="⏳14-lambdas"><a href="#⏳14-lambdas" class="header-anchor">#</a> ⏳14. lambdas</h2> <p>lambdas是一种什么样的东西呢？
借用这个符号呃，这个名称啊来表达什么东西？我们来看看这里的文字叙述。</p> <p>C++11一看有的
导入了浪的。
他允许你。
定义出迎来方式。
inline 这个就是inline the 某一个地方呢，你马上要写出来，呃，尽力的一段基因能一段功能。那当然就是以函数的形式表现呢。
所以你可以就可以想象他好像是个inline 函数。
它可以被用来当成什么？是这样的一个一个一个单元，可以被用来当成什么呢？一个参数或者是一个local object。
反正他也就是一个东东西了吗？
啊，所以拿来当参数可以啊，传来传去可以东西可以传染出去一次，当成一个local object object 的东西。我常常讲。
遇上东西有时候啊觉得。
对象。
嗯，好。
那么法k 好。
改变了我们对于c 加加标准库的使用方式。
意思是说我们在使用c 加加标准库的时候呢。
我们往往会写一些小东西来。
来来呃声明我们的意图。
比如说要排序，那排序是用快速排序法，这个已经写好了，但是排序是要怎么比大小，这就是我们可以写，我们不写的话，他就会用。
标准库就会有一个用一个默认的版本，默认的比大小的一个准。
但我们可以写。
我们常常我们唯一能够跟。
标准库打交道，放入一些我们自己的东西，就是在这。
写一些小小的。
芳心啊。减函数对象或者叫做仿函数。
那现在这句话的意思是说，这个小小的函数对象或者是反函数呢可以换成用那么大的形式来写，写出来还是一些。
反函数或者叫函数对象，但是写法不太一样，叫做浪荡。
好，我们先看看，这可能一下子拉得太长了。我们一下子我们先来看一看，那么他的基本语法最简单的形式就是这个样。
你看到中括号开头的就是那么的。
后面接上大挂号，就是表示函数的芳心。芭比函数本体。你要在这里作为这些这一件事情。
啊。
这是一个写法，可是这个写法写出来之后呢。
是上面的文字告诉你他。
这是一个。
一个什么东西呢？就好像你在定义一个函数。
可是我怎么调用他呢？那他本身是真的是一个函数吗？其实他是一个。
对象。
所以你这样子写出来之后是没有用。
你可以直接调用啊，那就在上面这个加一个小螺号。
所以这个东西现在没有名称，但是加小挂号呢，这其实是一个。
一个类型。
一个类型太。
他的恋后面加小锅哈。
嗯。
他的内幕加小挂号是要产生意思是要产生临时对象，但是这个。
这个又不是产生临时对象，这个叫直接把它调动起来了。所以这一件这一点上跟前面我们既有的临时对象的概念有一点点不同，有一点。
点不同啊，请注意，这样就是把它直接调用。
要不要写这样了，而且成这样，这样就是直接调用起来就咨询这一行。
但我们其实很少这样子写的。
啊，你你大费周章会把它写成这样，然后里头就是在做里头这一行这样干什么，那你就直接把这里头遮阳写出来算吧。
里头有一百行，你就直接写出一百行，何必加上上下的大括号。又是防刮放的。
所以多半我们会写成下面这样。
就是把你的定义这一部分就从中括号开始这一部分。
把它。
说他是什么把它记起来大家。
a 要是娶那么大的意思，就是取什么名称都一样。
那这个l 是什么类型呢？不知道啊，没有人知道这怎么这是什么类型。
除非你功力非常深厚。
因此我们这边就用auto 来表现好了。别老是什么管他的，反正是oto，那他就是这一个东西。
现在这个东西呢要把它调用起来，加速全包哈。
所以下面这一块跟中间这一块。
都是在调用，可是下面这个写法呢，从此往下这个lk 一直拿来用。
上面这个只是调用一次。
所以那么大，你就可以想象他是一个函数对象，他是他本身是一个对象啊这个对象。the object.
作用像是一个方式，我想挂号可以调用。
啊，这是最简形式最简形式。
我们看第二段。
那么他是一个。
机能一组功能的定义。
也就是一一个函数的定义。
换一个角度讲就是这样。
他可以被定义在一个statement 里头啊一堆里面。
或者直接在expression 表达式我们的地方，你突然想要做一件事情，突然在那边就开始写了。
可以这样，那跟现在这个情况又不太一样，这个情况是。
你要做的动作写好以后。
指定为ll 有以后可以随时拿出来用。
跟线上面讲的这个有点不同，上面是你临时就想写作为一个动作了，你就写些通常这个叫。
不带名称，做完就算了。
你也不打算呢啊这一段啊，你本来在这一代码这块地方想要有一个函数。
本来你应该。
把这个放下来，他某一个适当的地方先把函数写出来，然后再回到这个原原来的地方去调用这个函数。
现在这里说不必。
啊，你可以在。
谁这么是低头或者是explosion 里头就直接把它写出来。
写法就是现在看到的这种样子。
那他就形成一个依赖。
好，那这是一个最简形式呢。现在我们看到他完整的形式是这样，语法的完整形式。
现在把这个放大下一页。
还有一个中括号里都可以有东西，他说上个月是最简形式，什么都没有。
那后头还可以有个小刮号，这就是参数。
刚刚呢最典型是没有没有效果好。
回到这里来。
就这个地方这个中刮号有个术语叫做。
叫做in the user 导入的符号导入器导入符号。看到这个就知道是那么大。
那么这个是他的参数，他的行为像函数嘛，所以他也是可以有参数的。
参数后面这里呢可以指定这三种东西。
这一个就是一个函数可不可以丢出异常，这个是在以前是一家家，二点零之前你就可以指定了。就像以前那样去指定。
而museful 这是一个关键字。
这个关系到这里头的数据。
可不可以被改写？mutable 的意思就是可可改动的和改变的。
这个后面我们再用例子来解释。
那这个呢。
这个是在描描述这个。
浪打的返回类型。
由于这个特殊的写法，它是从中国浩开始，所以你没有办法这个语法的设计上没有办法去写出一个返回类型是什么。
在他的更前面没有办法写。
一开始就是中国哈，所以换了一种方式。
在后头。
用箭头符号这样的来写这个这个语法。前面我们在介绍。
the clay type 的时候也不过就前面大概有企业吧。七八页。
有看过这一种语法，现在呢就是在复习。
好，这个都这些全部都是什么？都是optional 或是选用的和谐可不行。
如果是三个都不写的话，这边也有讲了这三。
这都是。
可有可无的。
但只要有一个存在。
就一定要写小华好。
如果三个都没有呢，那小括号可写可不屑，要看有没有参数。
所以回到上面来，这个最简形式最简形式他都没有那三个。
呃，这是这三个呢也都没有参数，所以就没有写效果好。
好，回到这里。
然后函数本体的这个。
就刚刚我口头讲的这一些这三个optional 选项，这里有他们的。
比较精准的描描述在这边。
他的意义刚刚其实我都提过了，就是个mut of 还没有。
好，这个地里头。
可以放，这个是参数，就像一般的函数的参数，那大家都很熟悉的，该怎么写？这里头要放什么呢？这里头可以放他去取。
引用外部，这个是它本身嘛这个本身的外部的点亮。
可以写出来，你要取用外部变量，不然他看不见。
那这个外部的变量是要用。
pass by value 的形式还是用pass by reference。
以传值的形式还是传引用的形式？
可以用在这个地方写出来。
嗯，等号啦，还有这一个取地址符号啦，把它写出来。
我们现在看光看这一个，由于这不是一个完整的代码，所以可能不够好。
啊，这个作为一个参考，我们看下面完整的代码就会更清楚。
在看那个完整代码之前。
我们先来看这一个。
这里啊现在是基本语法你懂了，所以这个意思是什么呢？我现在有一个那么大。
从挂号开始。
他要取用外部的一个变量叫id。
我好处。
在id。
就是下面这样。
他没有参数。
他有museful。
好，里头做这个动作。
我们来看这样的一个写法，就相当于你可以想象编译器对它就是把它变成这样。
这是什么？
这就是一个。
方程所谓函数对象这一种类，这种class 和写法。
什么叫做一个函数对象？这一种class 里头有句重返这一个操作。
这表示他将来这个对象是可以被调用的。
呃，左边几乎等同于右边，那左边真正做的事情是在大括号里头啊，所以这两行就抄过来，相当于在被调用的时候，这这两。
再回到左边来，这里面说他需要接受，他想要去取得外部的一个。
电量。
所以在右手边呢就相当于。
他里头带着这么一个变量。
好，这样差不多了。
呃，右边的这一个class 的对象，现在做出一个对象加f 就相当于左手边这边直接f。
等于像是得到了一个对象。
我也可以细细的体会这个左边和右边他们等同是不是完全能够。
心领神会。
现在我们来看看左手边这个运作的结果是什么。
可能会让你吃惊。
看起来是这样啊，因为这是一个这是一段代码，所以执行要从上往下执行。
好，一开始id 是零，进来之后是说要做这些事情。
做了没还没做哦，因为这是一个一个定义而已。真正做事下面这三行小括号啊。
ok 继续往下，这个id 现在变成四十二。
然后做三。
执行结果在下面这。
我们可能会以为现在id 是四十二，四十二调用，所以这样一次进去这个四十二就存进来i d 呀，i d 是四十二，所以这里面这个id 就是神。
四十二以后就会打印出id 呢，应该是四十二，第一个是支持二，然后累加。
然后第二次再调用进去就被四十三了。
我们可能会以为是这样。
结果确实这样。
为什么呢？那是因为这一行这个地方id 当在。
做第一期的边这一块的时候，他看到的id 是上面这一个，这是后来才变成自己，这里是没。
所以是传进来，这里是零。因此呢第一个动作是是连跌的动作。雷嘉宾一变二。
做完了之后，现在把ip 印出来。
没变，他还是四十二在这里。
里头所变的是他自己的这个id。
你想象右手边，那就好像他自己有一个id 嘛，而且这个id 呢就是零，因为这个商。
里头怎么变都不影响外头的那个id。
这边还有一句话可以注意。
浪的我跟这个他的类型是什么呢？相当于是一个。
and another month.
匿名的不知名的一个不知名的方向object。呃，左边等于右边，但是右边呢其实这个名称是不知道的。这边意气编出来的。
变这个样。
好。
这the mutable 现在我们用这一个例子再回去检讨。上一页。
这边下面。
这些说什么？
这边说，如果你没有加上特殊符号的话，就是pass by value。
加上特殊符号，就是pass by reference。
所以现在回到这个例子来，他没有加特殊符号，所以他是他是反的，就是零二零就传进来了。
等一下你就会看到，如果是怕是by reference 成引用，那又是什么效果？
另外这个mutable 的意思是说。
这个东西是可变的。
那难道不写vb 里头就不能够加家吗？
这句话。
真的是这样吗？
按照道理说，右手边这个。
这没有什么museful 可言啊，这个id 在里头是一定可以加加的。
所以我们要探讨这个mutable。
我现在可以告诉你。
的确，如果没有写mutable 这个id 放进来不能加加，那这件事情左边是不是完全等同于右边呢？
仍然有待商榷的这个地方是确实有那么一点小小的不同。
我们来看这个三个例子就很非常清楚了。
啊，先比较一下他的不同，你可能要停格下来，你自己安安静静的，也许一分钟两分钟，这三个的。
同在哪里？我不能停下来，就我现在用嘴巴告诉我。
这三者的不同，第一个这个是pass by value。
这个是pass by。
那这一个呢呃它是百分之六。
这是左边这个要加上没有the table。
这首先左中右的差别在这里。
还有什么不同吗？
没有了。
好，我们来看看这三者。
左边这一个就是上一页的执行结果。
中间这个呢它是a reference 传引用之后看看是自性。
这里。
刚刚我们的分析说这个船进来这是零。
但是由于这是他是把reference，所以这个下去的时候，这个i d 四十二。
成饮用水这个id 会受到外界的影响，这个id 有变化，也会影响外界，外界有变化，也会影响他。因为他是纯饮用。
所以这个执行下去，这里是四十二，这里面的id 已经变成负十二。
然后最下面三次调用调用七，这个七是参数。
一是参数在这里，参数为佳佳，所以里头的参数为七八九，变成七零乘八百零九。但是我在这里没有打印出来，所以。
有打印。
而这个id 也在加加。
所以进去之后呢，继续加压，就四二四三。
里头这里的变化会影响外界，因为传进来的是用。
这就是这两者的差别。
右边这一个。
这里没有没有the table。
没有music。
所以传进来的东西根本不能加加。这边我有一个我在我的手上编译的时候报错信息。
你去图加一个read only。
唯独只能读不能写的一个变量。
所以这里没根本没有执行，结果他的这个地方是编译是失败的。
我借由这三个例子，我们就应该能够很清楚的知道有没有优质的变化啊。
引用的变化传奇。呃，这个影响。
我们看下面这个例子。
质地只是要表现，这是可以通过的。如果通过，如果编译失败，我都会写出来。那这个没写的，这是通过的。
是要告诉你说，在一个像lama 这样的东西，它是一个函数嘛，他的身份是一个函数，所以你也可以写上静态的数据。
写上非静态的数据，你也可以传为返回任何的你要返回的东西。
不过如果你要返回东西的话，这个类型你如果想指定的话，就要回到。
这个。
最完整的这个语法规格，你就要写出。
那这一夜里头这边还有一种奇怪的写法。
只写一个等号。
这意思是说。
允许使用。
所有其他的object i value。
这种。
时代已经有点太我觉得太这个符号他也。
这一类奇奇怪怪的符号太多，窝了一些。
看着已经有点令人害怕。
事实上，我个人的习惯不太显著，一些不太愿意写出一些默认的东西。像这样就是你写一个等号，就是默认接受外界的。
所有的东西我are the object by value。
我宁愿多写几个字，一个一个把它写清楚，后面看了也看的比较清楚。代码很重要的是以后要能看得懂。
我别人要能看得懂。
不过还是介绍啊他有这样的一个奇特的。
那这个语法刚在刚刚的这些例子里头里头呢，我们要去演练。他没有。
我们继续往下看。
这一夜再一次展现。
编译器对于烂达所产生的代码像什么样子？
刚刚上衣这边前两年夜这边其实已经有过例子了。
那我在这个地方有，我谈到由于museful 这个关键字。
在右手边并没有实现出来。
他说他之间还是有一点点小差别。
回到这里。
所以我们我们说又再换一个例子，让大家感受。
这个医院。
他的定义在这里。
相当于二相当于你写一个二。
一样的意思。
当然在这一个比较极端的例子里头，你会感受到。
好像我写浪荡毕竟还是快一些啊。
虽然语法看起来蛮奇特的。
怎么样，中括号引导。
可以接受参数。
那三个选项。
我出现出现的话就更奇特了。
好，你可以写单独的一行。如果你写成一个方程。
反函数的话，必须请这样。
好。
这个一切争议或写成二怎么样比较好呢？我们也不是所有的事情都都能够从代码到底有几行来判断啊，上面只有一行。
叫棒。下面有七八行比较辣，也不是这样看的，只是看个人的喜好。
等等等。
总之在这边告诉大家。
浪的这样的东西。
前面提到过一个概念。
前面再讲到第可能也tape 这个关键字的时候。
有提到他有三种用途。
其中第三种用途就是要来传递一个浪大的time。
这件事情。
这个画面。
刚刚曾经出现过。
现在要讲的更详细一些。
放到前面来，刚刚出现在哪里呢？让你安心一下。我们翻到前面再讲了一个type 的时候。
三。
等一下。
就这一块。
你也太狠，用来传递让他的态度。
这一块。
这一块。
现在我们再到。
现在讲的画面的这一块。
好，我继续讲的更深入一些。那先这一块是什么呢？你有一个烂的。
你要把这个浪打他是。
这比大小。
以en 二。
啊，这个例子是两个人person，两个人在比大小，你可能把很多人全世界十亿啊啊中国十二亿人，十三亿人口呢放到一个容器里头去。
然后你要比较人的。
李大小，因为你要排序。
大小孩怎么比呢？这个是怎么设计，它是把姓名拿来比。
不是name last name。are you?
啊，这就是这样，要现灵比最培训。
像这样定义出来的一个函数。
把它当成。
参数传给set 再次需要比大局比大小。
好。
再次要求在尖括号里头，模板参数必须告诉他比大小的这个准则的菜。
那你现在写好了这个动作，可是他的pap 是什么呢？虽然你这里用oto，所以你不必写出探的，可是到了这里却真的需要一个态。
判。
就借用前面介绍的这个。
这样一放进去就找出了这些就得到了他的类型。至于这类型是什么，我们现在我们写代码写到这里也不知道啊，没有关系，反正把这个问题。
给兵器，这样话就能。
这个类型告诉set 之后。
这个set。
在构造函数。
你看这样是标创建一个慈善。
这是他的对象名称。
这样就调用起，然后它的构造函数。
并且给予他。
出资。
set 的初值要怎么给？
那得去看看这次有多少种。
构造函数了，那可能有十个构造。
现在列出的其中一个构造函数给你看。
来表现，为什么这里给这个东西。
我们先看上面这段文字。
这里说让他的内心是一个没有名称的匿名的、无名的一个方向。object.
或者叫fountain 这个概念前面已经知道了。
并且对于每一个浪荡是独一无二的。
他虽然没有名称，可是他其实内部有名称。编译器之道。
是独一无二的。
因此。
你要宣告一个这种类型的对象的话。
现在有这一个啦。
你不知道他的名字啊，但是你要宣告第二个这种东西。
你需要用模板或者用auto，现在这就是用oto。
这样slam 的。
叫什么名称呢？
要用oto。
或者你把写好的这个东西传给一个模板的模板，可以推导出模板参数。
这就是这句话的意思。
如果你真的需要这个判，你可以用otoo 拿到，你可以用模板拿到。但如果你。
我透过这两种方式，你就要去拿到的话，你可以用可能。
就是这个鞋。
比如说。
你什么情况，会真的就是手上就需要这个time 呢？比如说。
你需要。
传那个烂打当做heh 方式。
或者当做欧。the shopping quality to real, the 排序的准则。
去传给一个啊oder 的container。
不定旭的容器这句话的意思就表现出就是这段代码。
我需要把一个拉大当做排序准则，比大小的准则交给一个。
啊，o the the conner set 就是一个。
啊，older content.
啊，不对，这是不是啊，这背后是红黑树，还有另外一种啊。older the set.
那个就是一个需要hash table 的东西。
所以这一段代码就可以说明上面这个。
然后我们来看看。
为什么我在这里要准备这个这？
的源代码。
这里头我挑出它的构造函数。
我在函数这个是构造函数。
这个也是构造呃，下面这个。
这个是构造函数，因为同名嘛，the set 同名。
下面这个也是。
上面这个是没有参数的，下面就是有参数。
所以这边是有参数的。
我的线条线条呢，那是要用这一个上下下面这一个。
我也想表达什么事情呢？
我们来看看这一段。
这里说。
由于你需要让大的类型来作为。
声明，这个set 时候所需。
需要浪漫。
因为shift 的接口设计要求你给他比大小的。
所以我们必须使用。
你可能tape 啊，这都是前面讲过的。
那么会导致让大的类型。
那么大的类型。
导致type of a loved the object。
也就是c e n mp 的类型。
拿不到。
好，到这里都是我们前面讲过的。
注意。
你也必须啊让当。
全给构造函数。
那就是上面这个。
好，我们这样接下去讲就是这一件事喽。他说你也必须把这个东西传给构造函数。
说到这里来。
就是说什么呢？否则的话。
这一个容器。
上面这个set 这个容器c o l l。
会调用默认构造函数。
你传给他的默认构造。
我们看看。
你现在把这一个东西传给他。
他。
在做这个事情。
这句话说，否则的话。
也就是说，如果你不这么穿。
那调用的将会是谁？
你不传这里就是你没有参数，那调用的就是上面这一个呢，这个就是没参数的。
那没有调用这个没参数。将会做什么事呢？这是set 的源代码呀，他是怎么设计的？
他会调用。
他会调用这个紫色的东西。
紫色是什么？
这个。
这个是什么？就是你传进来的这一块。第二参数啊。
在第二个模板参数。
就是这里的第一第二这个。
有点错综复杂，我整理一下，他说像上面这样的代码，这样写是很好的。
如果没有写出传这个对象的话，那就会调用到这一个版本的构造函数。而这个版本的构造函数。
就会调用紫色的这个也就是这个。
的默认构造函数。
不幸的是。
那么大没有默认构造函数。
那怎么办？
你继续往下看，他说。否则这个容器会调用。
你所传进去的这一个排序准则，就是你现在程序是这一个那么大，你所存进去的这一个的。
默认构造函数，这原代码写在这个在这个地方很清楚。
这是产生临时对象嘛。
临时对象，然后没有给参数啊，所以调用就是默认口罩。
也就是左左边这个浪荡的默认构造。
and 呢啊如果。
nmda 并没有默认构造函数。
他也没有。a spend money operate. 赋值。
物质操作。
那么他是一个很奇特的函数。
虽然说前面说他。
有点像是一个方式啊。
所以他这个class 啰。
但是由于它奇特的写法。
他其他的语法你无法为他设计一个默认构造函数，也无法为他设计一个父亲。
操作。
这就是这一段的意思。
那怎么办？
那就会出错。
如果你左手边这样子定义的一个容器。
啊，你解决了第一个问题啊，那么大的tab 找出来了。
而你这里没有啊，烂的也放进去。
编译器。然后他来编这一块，这样合不合理呢？啡到这里发现不行啊，他找不到那么大的默认构造函数。
愿意失败。
你失败，你能不能侦测出来你能不能调试出来出错debug。
他当然会给你一堆的。
呃，一堆的报错。
啊，什么模板的包出生了，这么生存下去。
编译器提供的报错信息到底够不够详细？
你看不看的懂都要取决于你对这整个概念是不是完全清楚。
好，我们继续回到这边来往下看。
刚说。
那么大的没有默认构造函数，也没有负责操作。
所以。
对于一个要作为排序准则。
怎么样比大小这样的东西？
a class, they found the function after, and might it will be more.
请你去。
比较更直观一些。
因为。
这句话什么意思呢？你如果用那么大的一些比大小的话。
由于你不能写出默认构造函数，跟这个夫子操作。
所以可能会带来不太好的影响。
万一使用者，你把这个那么大写好了，使用者要去用它，它不小心像我刚刚讲的这样子用就错了。而由于。
层次这么的深。
这个使用者可能根本看不懂报错信息。
这就是这一段的。
所以他最后的意思是说，那么在用排序准则。
让他写一个方式方法的时候。
由于这个考量。
你把像正规的写法写成一个方式，就是一个class。
会更好一些，更直观一些。
这就是这整个故事。
好，这一页呢？
有一大堆的文字。
我们也不去看了。
嗯，不过这边我把它弄成一个蓝色的，这里也是这个重点，我们来看一下。
这里说芳心object 就是大家在学到浪荡之前所熟悉的那个东西。
非常powerful 是很有威力强大的，可以拿来让你去cum my 去去克制化，去去自己指定一些。
标准库的行为。
标准库有默认的怎么比大小，但是你可以去指定你要的比大小形式。
并且可以封装扣的跟贝塔。
这是过去我们对于方兄object 的理解。
那么这里下面这个代码呢？
这一个就是我们以前习惯的写法。
现在学到那么大了。
我们可以写成这样。
前面提到还有什么in place？gd 就马上在现地，马上要洗这个动作在这里就表现得淋漓尽致。
这里调用的是容器的一个the race 动作。
再把一个元素拿掉，涂抹掉。一race 发票。
这里要给他一些条件，我们现在不去研究这里面的东西。
这里呢需要告诉他什么叫做小于啊，给他一个条件啊，什么东西拿掉。
我想要的条件是。
传进来这个n 呢。
所有的这些元素小于n。
呃，这是什么意思啊？存进来n。
n 是元素，因为一个一个拿吗？
xy 是一个范围。
每一个元素要大于x 而且小于y 比如说xy 是十跟一百。好的，那要大于十小于板。
这个条件符合的话，统统拿掉，我们以为死掉。
那下面我就一个用法了。
呃，我有调用的形式吗？
要哦在这里三十个一百。
xy 是三十个一百在这里传进去三十个一百。
所以这个这里的数据。
大于三十小于一百的全部拿掉，得到的结果是。
你可以帮忙停止停下来，慢慢看。
像这样的一个动作就表现出。
这么单独的一行，比起你按照以前正规形式没有那么的写出来，感觉的确实是。
强而有力。
简洁有力。
看那是我的心得，是，那是因为现在的这个。
例子。
情况之下，你要指定要条件很简短，所以一行就可以表达了。
那么方兄object，你无论怎么写，他总有一个一定的规模，所以看起来相较差别很大。
在其他不同的例子呢，不一定差别这么大。
不过回到这里来，就是说这个可以马上的这个地方起。
第二个他一定是一个in line 方式。
但是如果你写成右手边。
他就不是迎来这个效率上还是有一点点差别。
但我觉得其实当然呢嘿佳佳是非常的着重效率。
可是这种效率是微不足道。
我们的效率还是要注意到啊。
out with the 算法好不好？这个时代太次要太次药。
好，这个是那么大。
下一页。
仍然遵循我过去的习惯哦，与遇到了一个新的语法。我想看看标准库有没有什么去用它呢？
这个要怎么找啊，因为一个全文检索，你到底要找什么？整个那么大的语法如此的给到前面来，如此的弹性，我怎么找呢？
我只好。
啊，王伦齐瞎马。
这个乱枪打鸟找找看。
我就找。
这张图呈现呢我找的是什么呢？
啊。
我找不到这个。
第一个右中括号，还有一个左大括号。
并不一定，那么他就表现成这样。不一定。你刚刚看到完整的那个形式是蛮复杂的，不过我就早早看法，毕竟这样的话肯定是一个浪的。
找到了不太多能找到了。
我只是要让自己能够感受到标准库也在用这个新的语法，二点零的语法。
二点零的标准库也在用二点零的新语法。
这个是那个。
好。</p> <h2 id="✅-可变模板参数系列"><a href="#✅-可变模板参数系列" class="header-anchor">#</a> ✅ 可变模板参数系列</h2> <h2 id="⏳15-variadic-templates-1"><a href="#⏳15-variadic-templates-1" class="header-anchor">#</a> ⏳15. Variadic Templates 1</h2> <h2 id="⏳16-variadic-templates-2"><a href="#⏳16-variadic-templates-2" class="header-anchor">#</a> ⏳16. Variadic Templates 2</h2> <h2 id="⏳17-variadic-templates-3"><a href="#⏳17-variadic-templates-3" class="header-anchor">#</a> ⏳17. Variadic Templates 3</h2> <h2 id="⏳18-variadic-templates-4"><a href="#⏳18-variadic-templates-4" class="header-anchor">#</a> ⏳18. Variadic Templates 4</h2> <h2 id="⏳19-variadic-templates-5"><a href="#⏳19-variadic-templates-5" class="header-anchor">#</a> ⏳19. Variadic Templates 5</h2> <h2 id="⏳20-variadic-templates-6-1"><a href="#⏳20-variadic-templates-6-1" class="header-anchor">#</a> ⏳20. Variadic Templates 6(1)</h2> <h2 id="⏳21-variadic-templates-7-c-keywords"><a href="#⏳21-variadic-templates-7-c-keywords" class="header-anchor">#</a> ⏳21. Variadic Templates_7 &amp; C++ Keywords</h2> <h2 id="✅-二、标准库部分"><a href="#✅-二、标准库部分" class="header-anchor">#</a> ✅ 二、标准库部分</h2> <h2 id="⏳22-标准库-源代码分布"><a href="#⏳22-标准库-源代码分布" class="header-anchor">#</a> ⏳22.标准库-源代码分布</h2> <p><img src="img/C++%E6%A0%87%E5%87%8611/22_01.png" alt="22_01"></p> <ul><li>现在我们课程进入第2部分——C++2.0新特性的第2讲之标准库</li> <li>『前面是语言<strong>语法</strong>、<strong>关键字</strong>』</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/22_02.png" alt="22_01"></p> <ul><li>建议：希望你能和我一样去看到源代码！！！</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/22_03.png" alt="22_01"></p> <ul><li>如果你手上不是VC或者GNU，那么你总是能找到一个include子目录。</li> <li>呃当然了，这么多的头文件你要搭配一个『全文检索』，才会更帮助你来找到你要找到的源代码。</li></ul> <h2 id="⏳23-右值引用和move语义『移动语义-move-semantic』"><a href="#⏳23-右值引用和move语义『移动语义-move-semantic』" class="header-anchor">#</a> ⏳23.右值引用和move语义『移动语义/move semantic』</h2> <ul><li><p>博客<a href="https://codinfox.github.io/dev/2014/06/03/move-semantic-perfect-forward/" target="_blank" rel="noopener noreferrer">参考<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>“右值引用”的<a href="https://zh.wikipedia.org/wiki/%E5%8F%B3%E5%80%BC%E5%BC%95%E7%94%A8#%E7%A7%BB%E5%8A%A8%E8%AF%AD%E4%B9%89%E4%B8%8E%E5%BC%82%E5%B8%B8" target="_blank" rel="noopener noreferrer">维基百科<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li></ul> <blockquote><p>Rvalue references and Move Semantics，（<strong>游戏公司面试考了</strong>）</p></blockquote> <ul><li>面试问了，谈一谈，左值引用和右值引用？？</li> <li>谈一谈左值和右值『看来，4个是不同的概念，，，』</li></ul> <p>我要介绍一个<strong>非常非常重要</strong>的东西，叫做右值的引用。『右值的引用』这个关系到后面的一个叫——move搬离，的语义，而这个move语义又号称是可以对于容器的效率有大幅度的改善，而容器又是你几乎都一定会用到的。所以这个层层下来了，这非常重要。</p> <p>那么这个右值引用了，按理说它<strong>是属于语言</strong>的那一部分，我怎么把它放到标准库这边第二讲来谈呢。**没错，他是语言的部分，但是他接下去发展的呢，就都是跟标准库有关。**好，所以我放到这里来谈。</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/23_01.png" alt="22_01"></p> <p>这个<strong>右值引用</strong>又是什么意思？我们看到这里的文字说明。这是一种<strong>新的Type</strong>，新的类型————引用的类型。是从其实从2003（就是TR1）之后就引入了，但是大家都不是很熟悉他。但是在2.0这个就变得很重要了。</p> <ul><li>他可以来帮助解决一个问题，什么问题呢？就是不必要copy！！</li></ul> <p><strong>事实上，copy 的事情在我们。没有意识到的情况之下呢，常常在发生</strong>！！
比如说你把一个临时对象。啊，你从你的实验室里面抓到一个数据，这个数据呢，你要包成一个对象，一个object，然后把它insert 或者是pushback 放到你的容器里头去。你可能抓一百万个数据，就要准备一百万个这一种对象，然后放到你的元素去。你这个，一个一个的数据抓出来都是一些你会制造一些临时对象。</p> <p>临时对象要放到容器去，这就是一个copy的动作。那这个copy动作其实可能非必要啊，<strong>什么情况必要，什么情况，非必要的</strong>，我们等一下再来分析</p> <p>那这个非必要的情况之下呢，那如果有一百万次，这不是就，呃，非常浪费时间的嘛。</p> <p>而且如果你把它放到容器之后，这个容器在默默的情况之下，在你不知道的情况之下呢，他也可能在做。在做很多的copy 的动作。比如说那个vector 要成长。啊，在你没有意识的情况之下，他已经默默的搬到另外一个地方去。那可能要靠比五十万个元素，七十万个元素，很多很多的元素。所以回到这里来。</p> <ul><li>这一个语义，这一个语法语义的发展就是为了：要解决非必要的拷贝。</li></ul> <p>什么叫做非必要的拷贝呢？</p> <p>这边是有一个说明：当赋值，拷贝也是一种赋值啊！！就是把东西放到另外一个地方去，这个叫assign嘛。赋值的右手边，右手边就是来源端呢，你a =b 就是把b assign给a。
那个b 在右手边，b就是来源端，拷贝的来源端啊，当右手边是一个右值的话。</p> <p>我们现在可能还不知道什么叫右值。等一下我会分析。</p> <p>当右手边是一个右值的话呢，那么左手边的这边的接受端呢。可以去偷（steal）右手边的resources，这里的resources 就是指他里头的东西啦！！</p> <p>真正要copy的东西，可以偷！！	这个字，很形象——去偷它。而不需要，rather then 而不需要去执行一个allocation 的动作。你要把这个东西赋值或者拷贝到另外一个地方去。那个另外一个地方那边呢，<strong>可以不必做：重新分配一块内存来放</strong>。<strong>他可以去偷原来的这一边</strong>。那这个一定要发生在指针的这个事情上面！！！</p> <p>这不我们等一下会继续把它弄得非常的清楚。</p> <p><strong>所以非必要的拷贝其实就是去偷！</strong>！那怎么偷呢？</p> <ul><li>现在我们现在解释一下左值（Lvalue）跟右值差别</li></ul> <p>左值：就是变量。我们一般在代码里面声明一个变量，变量是可变的，他可以接受你赋值进去。可以是在一个赋值符号的左手边，所以叫左值，，变量就是左值。</p> <p>那右值呢？他就不能放在左边的叫做右值。</p> <p>我们先来看这个例子。</p> <p>我有a b 两个变量，所以它都是左值。</p> <p>你看，a 可以放在左手边，b 也可以放在左手边，他都是左值。左值也可以放在右边啊，这个无所谓，他是可以出现在左边的。
那右值呢：<strong>只能</strong>出现在右边</p> <ul><li>这个就是右值：红色的这个：a +b 加完之后，你不能再赋值进去！这个语法这个怎么解释？</li></ul> <p>所以这个，a +b 这样就是一个右值，我们继续往下看。当然你会想说，我在代码里面不根本就不会去写这种动作嘛。我写学习写代码的第一天我就知道我不会去写这种动作！！
那这只是一个例子啊！！右值是这个形式，但是右值也可能是其他的形式。我们继续说。如果以这个为蓝本；我换那个，我不要用整数，我用其他的东西来实验一下。用字符串。或者用复数，我最喜欢就是拿这两个来试验：标准库已经提供了和我们一起。</p> <p>复数：这一个呢，它里头只有实部和虚部，他不带指针。
字符串：这个呢这里头只有一根指针，至于这个字符串本身是放在另外一个地方，用这根指针去指着他。所以这是非常典型的两种例子。</p> <p>好，我就按照这个整数的方式，我再写一遍，我们分析一下，现在我有两个字符串。我就是要模拟这个动作。这边整数编译的时候会失败嘛！！
但是我现在这样编译过去，我磨砺他呢却成功了却成功了。竟然通过编译。</p> <p>这个就很有趣。那我就想：<strong>这不就推翻了，我们的理解了嘛，对右值的理解</strong>！！
好，那我就。既然成功，那我打印出来看看好了，看看这个赋值进去是什么结果。你可以你可以体会一下这个执行结果。
还有一种情况——这个是一个临时对象。</p> <p>好，现在我来解释，右值的除了像这样之外，另外一个是我们常常写代码会出现的。就是这种临时对象。临时对象就是一个右值！！<strong>你可以这样想象：帮助你理解，右值，他没有名称。那没有名称，你怎么赋值给他呢？？</strong>？
这样子你比较容易接受这种观念，所以这个临时对象却赋值给他，竟然也可以通过，这个太奇怪了，竟然可以对临时对象赋值！！
<strong>所以我用字符串这个class 完全推翻了对整数的认识。</strong></p> <p>那我们再看看另外一个经典的例子，复数好了。好，这里呢我有两个复数。
都有默认值了。不是默认值那么多，指定给他赋值了。然后我也是模拟整数的这个加法，在这个地方，竟然也通过了！！
这边，这两个相加，可以当左值吗？？？这个是通过的，所以这个答案是yes！！！</p> <p>可以，你的讲义就把它把它打上可以！！！</p> <p>然后也是按照刚刚的方式，既然可以，那我就打印出来看看执行结果是什么？好了，那这个执行结果已经不重要了。。。
下一行，我也一样画葫芦的，以这种方式，我写出这一行临时对象把它赋值，竟然也可以，<strong>所以这两个经典的class 呢都推翻了我们对整数的理解</strong>。</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/23_02.png" alt="22_01"></p> <p>这边有一段话可以这样解释：：<strong>c ++在夹带着，他的这个，它自己定义的这一些class，每个class都是一个type。会引来一些很隐晦的，很不太能想象的一些对于modify 一些改变内容或者是赋值动作的一些，，一些让人意想不到的。大吃一惊的情况。那就会造成对于这个定义的一个不正确性，，什么定义？？？这里出现问题。（指着左上角的左值和右值的那段英语））</strong></p> <p>也就是我们对整数的理解!</p> <p>不过在这个地方无所谓，我们还是要回到我们最基本的态度来。</p> <p>就是右值是，不可以出现在左边的。
<strong>而什么是右值呢？最常见的就是临时对象。他就是右值。</strong>
虽然呢，这里推翻了这个概念！！但是因为这两个是这2个是<strong>这个标准库的作者，他自己写出来的，它没有去非常严谨的遵循这一个概念。</strong></p> <ul><li>那我们不管他。</li></ul> <p>好，所以这一页最重要的就是2件事。</p> <p>1、临时对象就是一种右值
2、右值不可以放在左边。</p> <p>我们再往下看。那这个呢。
像这样，这是一个函数，函数返回一个整数。
下面这样，我们只要分析左边跟右边就好了，这个是一个赋值操作。x 是个变量，所以放在左边当然是ok。</p> <p>第2行，这个就不ok 了。P这个变量是没有问题。问题是：这个是什么东西？
你可能会想，那这个好像是一个对函数取地址，对函数取地址就是取出函数的那个起点。你可能会这样想，那个是对的呀，从c 以来就可以了。c 的函数名称。其实就是函数的起点。也就是函数的位置——地址。『那你加不上加不加上这个取地址符号都无所谓，这个以前就可以通过，现在为什么通不过呢？』』</p> <p>因为这个并不是你想象中的那个——这个是什么。<strong>你想象的那个是没有小括号的</strong>。那他没有小括号，那就是函数的名称也就是函数的地址。
现在是有小括号，所以<strong>这意思是这一个函数的返回的东西</strong>，return value 返回一个东西，要取地址。
<strong>但是，函数返回的东西是个右值</strong>！
你对右值再去取地址？是不可以的。</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/23_03.png" alt="22_01"></p> <p>新的新的：：：可是<strong>现在发展</strong>出一个新的语法：对右值要去取地址哦，来引用！！
好，所以：右值放在等号赋值符号的右手边，天经地义。</p> <p><strong>但是当他放在右手边的时候。c++2.0现在说希望给我们一个新的语</strong>法！！！
『『让我们能够去取他的reference！！带来什么好处呢？』』</p> <p>接下去就要谈。我们等一下再来回来看这2句话。</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/23_04.png" alt="22_01"></p> <p>好，我们先来看这张图。
右手边这个代码就是我在前面我们的第1讲里面，当时在谈到一个主题的时候还谈到。模模板模板参数。
那一个主题。</p> <p>1、所以这样子放进去之后呢，首先<strong>要有一种语法</strong>。去通知这个函数。
说。你来偷吧，我让你偷，就这个函数在哪里？
这个是容器，这个c 就是这里存进来的that。
因为这张很复杂嘛，你要从这里看起。好，这个v 成见就是这个c。
这个c 就是现在这里的c 所以调用的就是that the insert。
that could the insert. 我花在这边。
去看看他的源代码，它的insert有两个版本。
我们熟知的是这一个。『标号为1的』</p> <p>现在，是2.0，有新的语法，并且实现出这个词作，实现是什么呢？这个版本。
<strong>什么新语法？这里出现两个这个<code>&amp;&amp;</code>特殊符号</strong>。这样的意思就是说：如果传进来的，现在有两个版本。
如果传进来是Rvalue reference.，那就是这个就会跑到这里来！
右值引用就会跑到这里来，不是的话就会跑到上面这里。</p> <p>在过去以来都只有这个吗？现在新增加这一个。
我现在就画了这条线。告诉你他就会跑到这里，为什么呢？
这一个就是右值啊。</p> <p>面对右值的时候，编译器面对临时对象。一定把它当成是一个右值引用跑到这里。
跑到这里来以后做什么事情了？
这个insert，它里头开始要把一个元素放到容器之中某一个位置。in vector 来讲，我们现在这个例子是在。放进去之后，要往往尾巴推。
这个推的过程，会一再的发生copy。
所以这个insert里头，我这边画法形象的让大家了解这个理念可能是很多很多次很多次。当然也可能一次都没有啊，如果你映射到最尾巴的话。</p> <p>好，这里头呢？被一再的既然要发生copy，**他会去调用你传进来的这个东西，他的type。**也就是他的class的constructor『『注意：』』
insert 为了要copy 会去调用拷贝构造，拷贝构造呢，这一个呢，就是这一个元素的类型。我们也要写出2个版本出来：</p> <p>1、一个是跟拷贝有关的，大家以前熟悉的东西。
2、一个是专门让你来偷的。</p> <p>所以『以前』的这1个拷贝，他是一他会做这种事情：就是他真的会去分配另外一块内存啊，假设是原本是这样的话。要做拷贝的话，除了把这个要分配一个这一个啊，那指针呢要不要拷贝过来，不要拷贝过来，要另外分配一块内存，去放去放这里拷贝过来，这个也就是指针的深拷贝。『『『原理如此，原来我先前以为全是浅拷贝的，也不是，因为真的有深拷贝？？』啊，这是过去的情况。</p> <p>现在说我有这个新版本哦，那这边调用的时候已经明白的告诉我你来偷我吧。
好，所以怎么抽呢？现在偷的对象是谁？就是，你现在放进去的这个Mystring。
Mystring这个中间有个过程啊，我就不去讲他这个事实上这个例子我们前面已经带</p> <p>呃，这个就是my string。所以这边说我现在要放一个my streng 进去，而且欢迎你来偷。好，这个我来了。</p> <ul><li>这个容器确实有一个版本是准备来偷的。</li></ul> <p>他里头就一再一再的去偷</p> <p>所以他就会跑到这里来了：
至于怎么偷呢，我们先简单谈一下概念，后面就有真正的代码，他当时copy 是这样。那偷是怎么样？只要把指针拷贝过来就好了。
不用另外分配一块，像这样分配一块新的那一组。
也不用把这个内容拷贝过来，都不必，只要把指针指过去就好。</p> <p>这样就叫做偷，谁偷谁呢？新的这个东西偷了旧的这个东西，什么叫做偷呢？我指针指过去。我指导和你们一样的东西，那我就算是借用一下：：在这里形**象的说是偷。**所以我跟你，从此就指向同一个东西了，我们共享，这件事情当然是危险！</p> <p>你同一个内容有两个指针指着他。有两个人在看同一栋房子好了。呃，另外一个人决定摧毁他，放火烧掉它。a 跟b 啊，那那a 吧把它烧掉，那bb 就没有了，什么都没有了，因为他们自己成同一个房子。所以这是危险。这是危险。呃，危险怎么办呢？所以这边有一个打叉的动作。这个指针拷贝过来之后，其实这是指针的浅拷贝了。所谓偷。<strong>所谓move搬离，就是指针的浅拷贝。</strong></p> <p><strong>这个浅拷贝完成了之后，这一根指针要打断。打断就安全了，没打断就危险</strong>！！
所以打算以后他原来这个东西就没有用了，没错！</p> <p>没错，所以整个在反推回去呢，你作为右值的人，那去使用之后，他就不能再用了，<strong>他被偷了，他不能再用，所以一定要有这个认知</strong>。你一定要认识一个事情。被move之后，被偷之后呢？原来那个东西不能再用，再用就危险。在用的时候，这个指针已经打叉了。等一下真正把这个代码写完，这个点点点，你就会看到这里。我把这个指针拿掉。</p> <p>再回来检讨一下：当初说如果我决定告诉这个说：：我是一个右值，那么我接下来就不能再使用它了！！这个黄色这个东西被用了。你要想象他被偷了，接下来不能用。在这一件，现在这个点上呢。</p> <blockquote><p>临时对象是：右值的原因！！</p></blockquote> <p><strong>右值本来自己是一个临时对象，他临时对象根本没有名称，所以接下去『根本不可能用到它』。那非常好非常好！！也正是因为这样</strong>，所以编译器看到临时对象<strong>一定</strong>把它当成右值，一定走。我刚刚走这些路，一定去偷。</p> <p>另外有一种情况是：我要insert。
我这个东西不是临时对象！！不是，所以他是左值，但是我自己很清楚，接下来我不会再用这个左值，左值就是讲成变量啊，<strong>我接下来不会再去用这个变量</strong>！！</p> <p><strong>那这种情况下，我也可以想办法让他走这一条</strong>路！！这条路是用偷的方式，那显然可以大幅节省时间了！！</p> <blockquote><p>move函数的作用！！</p></blockquote> <p>我怎么去，<strong>我明明是一个左值，我却要把自己当成右值！那要怎么办呢？？？</strong> <strong>标准库就给了你一个东西叫</strong>做这个：<code>move</code> ，你只要把你的左值，你的变量。
放到这里头去！！ <strong>就相当于</strong>拿到了他的Rvalue ref. 那就会走这条路。</p> <p>很快的很短时间整理一下这概念啊。
我作为一个<strong>动作的发起者</strong>，我要调用insert，所以我是动作的发起者。我放的是一个右值</p> <p><strong>所以在2.0之前。容器的insert只有这样一个版本，现在多了这个版本</strong>！于是通知他跑到这个版本，这个版本要怎么偷呢？？？他所谓偷，是要来处理你给他的东西呀。
那你现在这个例子，你给他的是这一种：这个在当初的发起端其实是一个my String，这个是我设计的，我就得在my 村里面。
也写出一个，专门针对的版本move的版本！！！所以当他要偷要做拷贝的时候，或者拷贝赋值，或者拷贝构造都是拷贝。他会发现哦，确实有一个可以让我偷的版本，他就跑到这里了。</p> <p><strong>所以这个是新的，这个标准库里面这一段这是新的，我们写代码要搭配它，这一段是新的</strong>。
那么整个发起的动作是临时对象，一定是右值，，万一你有一个左值，你可以用这种方式<code>move</code>，这也是新的，来引发整个，这种右值move的这种动作</p> <p>说你要有右值引用可以被偷，你现在已经知道要写两个版本了。呃，语法的这个地方，但是真正要怎么写出来呢？我们就会看到一个实际的例子。</p> <h2 id="⏳24-完美转发"><a href="#⏳24-完美转发" class="header-anchor">#</a> ⏳24.完美转发</h2> <ul><li><strong>Perfect Forwarding</strong>，完美转发</li></ul> <p><img src="img/C++%E6%A0%87%E5%87%8611/24_01.png" alt="22_01"></p> <p>尤其是move 这个动作对于vector特别重要。vector的这两个版本。把他的源代码挖出来给你看。
因此好吧，这个是<strong>2.9，也就是我拿来做代表，就是C++2.0之前</strong>，只有这个版本，他接受的是Pass by reference。刚刚在上1页，就这，就这个版本。
那么第2个版本呢。</p> <p>是4.9，我呢它还代表2.0之后，涉及到2.0之后的那他就有他就有两个版本。
一个是by reference。
一个呢，是传递by Rvalue reference（右值引用）。这个两个版本。</p> <p>但是这都不是重点，我们的重点是二点零之前只有一个版本，二点零之后就可以利用这个新的语法了。右值引用的新语法，设计出两个版本出来。这一张是对刚刚我们花很多时间的这一夜的这个地方做一个补充。</p> <p>那他是一个临时对象，而他会被解释为幼稚。
引用这个传进去这个tape。传到这里来之后，这里**又调用过去，所以有点像是一个快递啊。**我把这个type 传过去，就转交到这里去，这个地方再转再去调用，也就是再把这个Type 再转交到这里来，在这个过程里面呢：：遗失了一些信息。
也就是这个Type 经过这种动作，而不是如果他是直接到某1个地方去，在那边做处理。那很好，可是现在是到这里来这里再到这里来。</p> <p>你把一个东西交给顺丰快递，总不能顺丰快递说啊，对不起啊，<strong>我交到他客户手上的时候遗漏了一些东西，这里能忍受吗</strong>？</p> <p>你不能忍受！！更何况这个遗漏的东西是一个最重要的东西。在现代所谈的这种move语义之中！！</p> <p>所以到底发生了什么事情呢？如果没有一个特殊设计的话。这个转交的动作Forward转交传递的这个动作呢是一个不完美的！！刚刚就是说遗漏了一些性质。
一些信息，不完美！！
<strong>所以我们要发展出一个完美的传递的机制。</strong></p> <p>我来看看什么是不完美，是不是完美？？？</p> <p>好，所以我们往下看。啊，刚刚进行到这呃这一页嘛，这是源代码。那么下面这个呢，只是先提一下的，我们要发展的。</p> <p>我现在，我的放进去的元素类型，除了有刚刚的，copy constructor和copy move constructor。</p> <p>记住这2个我不太知道这个move呢是因为这个新东西，我们到底要中文要翻译为什么呢？我不是很有把握我，所以我们讲原文哈。</p> <blockquote><p>学习：：：</p></blockquote> <p>『『『copy和move 这两个版本。这两个版本，不但在<strong>构造函</strong>数身上要分为两个，在<strong>赋值操作</strong>上也要分为2个，也要有新的这个！！</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/24_02.png" alt="22_01"></p> <p>》</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/24_03.png" alt="22_01"></p> <p>然后我们下去看所谓的<strong>完美的转交</strong>，完美的快递。这一页上面所谈的。
其实是已经是结果了，就是这个。当使用:标准库的这个东西<code>Forward</code>就可以达到一个完美的快递。</p> <p>》 不完美的转发</p> <p>但是什么是不完美的，还不知道呢！！所以我们先看下一页。</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/24_04.png" alt="22_01"></p> <p>不完美的forwarding。我们来看看这个小例子。我写了两个函数就process
这两个函数，一个是这种版本。一个是这种版本。</p> <p>我准备一些东西，看看他会变到哪一个版本。这个我有一个左值。</p> <p>那这个呢。a 是一个左值。
但是加上move之后，标准库有一个这个东西，加上幕布之后,他变成右值了
或者说请把他的亲把我当成右值，我a 啊，请你们把我当右值吧。所以这样调用到的是右值的版本。
都非常好。</p> <p><strong>接下来再设计一个中介者叫Forward</strong></p> <p>这里呢将要调用Forward而<strong>Forward 里头再去调用process。</strong>
我们刚不是说一个快递的动作吗？他快递的观点嘛，我调用你，你再用他，这个转接的过程中。我们就想模拟这个事情。
再看一次，我这边有个Forward</p> <p>糟糕了。不完美的转交。快递完美的快递。
**再讲一次，这是明明是一个右值。**放进来之后再放上去，却变成了左值
可见这个Forward设计一定有问题！！！
这不是我们要的！！！
这边有讲！
好，那怎么去解释它呢？我这里有个解释，但是就算你。也不是很懂这个解释无所谓。<strong>总之我们其实要求的是一个完美的转交，但是这里做不到</strong>。</p> <p>那这个到底该怎么设计才好？</p> <p>已经到了一种非常让人，，啊可能会让你觉得非常枯燥无谓的 <strong>一些非常底层的语言上的探讨</strong>。所以我也不打算在这里讲啊。
啊，<strong>我只表现什么给你看。：标准库做出来的东西给你看</strong>。
他说。刚刚我们说这个是失败的！！！</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/24_05.png" alt="22_01"></p> <p>那么他做成什么样子呢？在这一个头文件里头，如果你有兴趣挖出来，其实这个我已经超出来了。这里头有Forward一个，这是一个模板啊。
这服务第二个，这是一个模板。
通过这2。就可以做到完美的Forward『『『学习学习』』</p> <p><img src="img/C++%E6%A0%87%E5%87%8611/24_06.png" alt="22_01"></p> <p>我刚刚说我们不想去细谈这里头的这些动作。这个非常的枯燥无味。
但是你在看一些代码的时候。标准库的代码。你这是你是使用者，然后你想去看看代码，你会发现。怎么他会调用move，move调用之前，又调用这个Forward，原因就是我们现在所在谈的。借着这样子的设计。才能够做到完美的转交，完美的快递。</p> <p>我们整理一下。我们<strong>最终目的是希望我设计一个类型呢</strong>。
<strong>这他声称他是可以被偷的，这样的话就可以对容器的效率有大幅度的提升</strong>。所以这是我们的目标这个。</p> <p>他是在探讨这个事情之前，我们已经认识了右值引用的语法，，以及这个标准库提供的这个东西。以及。
散落在很多标准库的其他地方的。
什么东西呢？
Forward的这种东西，这Forward和move</p> <p>所有的基础呢都铺成好了，我们可以开始来写我们这个可被偷的或者叫<strong>可被搬的move aware</strong></p> <p>move aware,<strong>有move意识</strong>的这一种元素类型，我们接下来就要来学习怎么写这种东西。</p> <h2 id="⏳25-写一个-move-aware-class"><a href="#⏳25-写一个-move-aware-class" class="header-anchor">#</a> ⏳25.写一个 Move-aware class</h2> <ul><li>我们现在要设计1个class，它是带着move这种轶事的，，它是可以被move在有必要的情况之下，它可以被move</li></ul> <p>那我设计好这个class之后，我打算把它当成元素的类型！！这样它带着这种轶事，将来容器需要做copy的时候，一看你有这个意识哦，，它就会用move来取代真正的拷贝！！『『1分钟』</p> <p>这个东西现在叫my stream。
想一想，你要设计一个字符串，当然了，标准库有现成的字符串可以用啊，不过现在我就是要自己设计一个。
你设计一个字符串。
你会做什么事呢？你会有一个指针。
那这个例子里头我就设计了一个长度。
所以就是两个变量，一个是指针，一个是长度。
过去的设计，你会有一个由于是指针。
一定要设计fix three。
前面我提过big three 这个这个字啊，这个意思就是这是这有人这么说，用了这个字眼我觉得挺好的，我觉得我也就引用就是那几个特殊函数。
那么拷贝构造了拷贝赋值啦，吸构函数啦这些。
这个叫three。
所以。
既然这是有指针，我一定要写出big three 出来。
好，那所以在哪里呢？
咖啡搞错的。
我们来看看怎么做，你一定已经很熟悉的，我们很快看一下，因为要对比于它的幕府另外一个版本，这是copy 的版本，只是move 的版本。
我们看一下咖啡come soft 要怎么做呢？宝贝构造。
这里头。
呃，我把一个剂量加加这件事情跟本来跟本原本的设计无关。由于我等一下。
做这个测试。
啊，他到底被调用几次，所以我有一个counter。
我有好几个counter 不同的函数被调用这个剂量计算机器呢就会累加一。最后我就可以看看到底哪一个函数被调用了多少。
这些都是静态的数据，这一段这些都是。
跟原本设计无关的是，我为了要测试用。
所以我现在跟进入这个函数，我就把相对应的这个边这个静态的数据加加。
然后我真正做的咖啡动作，我把它切割到这里来。
所以我们来看一下。
这是原来的字符串，是这样。
现在要作为一个拷贝。
那就。
看图说故事就分配一块新的空间啊，原来的内容拷贝过来，这样就好了。
我看看。
进来呢分配一块。
足够大的空间，就原来的长度加一是因为最后是一个零的符号，作为一个结束符啊。
这样两块就一样大了。
缪完之后呢，memory copy 就是这个动作。
他闭完了之后。
啊，最后那一个设为零，这样这个字符串就完整了。
那当初new 得到的指针指向。
把它记起来。
就是这一个喽。
所以现在就形成这种状态。
原来的还在，但是我现在有个新的，这是深拷贝。
好，这是过去大家熟悉的东西。
幕府呢？
呃，这个整个源代码分为两页。
我这边有一些箭头标示，从这里开始看起这个讲完了之后到这里来，这个继续下去之后到下一页。
下一页下下一页的这边，然后玩的又到右手边，最后到这里结束，总共两页。
好，刚刚已经看了cap concert，我们现在看木。
呃，呃不是木。
那个副词操作。
在。
在在这里拷贝赋值。
这是大家熟悉的东西拷贝赋值做的事情是什么？首先把对应的counter 佳佳。
然后这边会做一个自我赋词的检测动作。如果自己父子给自己，那就什么事都不必做呀。所以如果我等于又。
左等也有自己复制给自己的话，这个特殊上跳出来else b 错。
如果不是自己复制给自己呢，那就先把自己杀掉。
这个东西要复制到我身上来，我本来有东西的，我先清干净，然后再copy 过来。这就是这里的动作，先把自己杀掉。
杀掉之后再做一次深拷贝。
好，所以这个也是在做拷贝，这个也是在做拷贝，这都是大家熟悉的东西。
他们两个都有自己的一个兄弟版本，就是无物的版本。
啊，这边有一个。
下一页这边也有一个。
我们现在重点就是要学习这个怎么写。
首先。
他兄弟之间要区隔开来。
靠这个区隔。
这个就是柚子引用嘛。
这个是什么？
reference.
这个是r value reference 这两者。
靠这样来趣阁。
下一个也下夜也是。
好。
怎么样偷呢？这两个move 版本都是在偷东西，怎么去偷呢？
这里头。
啊。
既然要付，要要以这个为为来源端。
所以这一行这是一个初值设定啊，来源端来云端不是也有两笔数据嘛，就这个指针根长度嘛。
把指针。
设过了啊，长度射过来。
那就好了，那就是这个图形了。
指针相同，意思是指向同一块内存。
长度呢长度也是好的，相同就是这一张图。
在初值设定的时候，已经完成了货物的动作。
进来之后把康腿夹夹。
那把原来的长度。
这是原来的东西。
长度设为零，因为这个东西已经。
不认为还可以备用。
省委里。
设为零。接下来这件事情很重要。
一般人可能会忽略掉，可能会想。
嗯，作为零的话，那要不要把他自己清掉算了，免得后面被误用。
不应该在这里做。
是应该要清除了。
但是这个清除动作。
应该交给destruct 析构函数去做，所以不应该在振作。
啊，因为吸构函数。
这边吸构函数是要做比列特的动作。
把那个指针给你的标。
啊，回到我我弄错投影片，所以回到这里刚讲的这个地方。
所以一般很多的朋友呢可能就会忽略说啊，那这样的话呢这个指针也是过来了，长度也设为零了。可以的。
这就结束了。
可是这样会引发一个大问题，如果你没有写这一行的。
会怎么样呢？
我们先跳了两页，到这里来看看，这又是在那个测试城市。
当初引发的动作在这里。
虽然不是刚刚那一夜啊，但是我相信你还有印象这个。
所以这一个东西被传递出去之后。
然后啊我们回到刚刚那一页好了，这跟这个很像啊，但是刚刚已经看过那个图画的更清楚。我们回到刚刚这边来。
这里。
这个传输具备因设这个函数要去继续去做处理。这个处理完之后做什么？
就是这一个了，你看他跑到这里来，这里就跑到这个木板。本来有两个兄弟嘛，他跑到木粉，本来里头做这个动作。
当爱已经解解释过了。
刚刚说很重要的就是这个要设为null，把它打断的意思。
很多人忽略没打断没打断的话呢。
这个。
执行完毕之后，这个临时对象。
临时对象的生命。
我们要了解他就是这一行存在于这一行。
做了阴式动作完毕之后，再往下再再波路跑回去。再往下的时候，他的生命就消失了。
他的生命力消失，吸构函数就会被吊起来。
七构函数被调用起来呢，就会把这个这个是这个。
就会把这根这个地方杀掉，is it?
那就糟糕了。
这个一点例子就把这一块也等于是一起杀掉了。这两个人在看同一款。
所以这是不能抵烈的，现在现阶段不能抵。
所以。
必须在这边把它视为大闹打断。
并且配套的在吸构函数那边。
做什么事呢？
我们现在回到刚刚的源代码这边。
好，要不要再讲，这也行。
这个打断。
并且在吸构函数这边呃，这里。
看看现在这个是闹么？
不是now 才去做比例的。
如果是now，当然就不要迪力的。
那这样子两边配合。
就很好。
再回到刚刚的那张画面来。
啊，这个地方。
所以这一个这样子设好一个浅拷贝之后，这一根指针打断了。而这个生命接下去消失了。
消失的时候会调用析构函数，而吸构函数会看哦，这个指针是now，所以就不对。
那非常好。
非常好这个东西本身这一个东西临时对象其实是他只占这一块。
这一块的生命会消失掉。
但是这个指针是now，所以不会影响真正放内放机放字符串的这一块不会。
也不该影响，因为现在有另外一个人指责他呢。
啊，两边设计配套，这样就很完整了。我们再一次回到这个代码这边。
好，刚刚讲这一行重要。
这就是我们。
第一次终于面对我们要怎么写一个copy 版本的兄弟版本目。
啊，要这么写。
的字符串这个例子里头我们是这样。
继续往下。
赋值呢赋值操作也有咖啡版本，我们看下一页也有幕府版本。
莫版本怎么做啊？
好，这刚才的分析都一样，进来就打括号进来之后，康德先加加。
我刚才已经讲好几次了，这个家家这些动作跟本身无关，是因为我要测试，我要看他的可以这样次数。
里头做的事情这边有一个框起来的自我父子的坚持检查，这是一个副词动作吗？
是跟他的兄弟正业。
这是咖啡版完全一样。
里头的细节没有什么不同呢，就是概念都一样。那这里做的是一个浅拷贝。
看看他的兄弟做了这个深拷贝。
这里是浅拷贝，什么叫浅拷贝，刚刚都已经看过了，就是长度也是。
这个我。
这个来源端的长度瘦到目的端来来源端的指针，瘦到目的端呢，这样就是一个浅拷贝。
你叫什么？
那这样就是一个头部的动作。
这个目的端去偷了来源端的东西，我跟你共享。
当成是我偷了吧。
然后偷完之后呢，那来源端着把它把自己的状态设一下，长度设为零。
指针设为null。我这边又一次告诉你这一行重要。
设为呢这个打包。
所以这里就可以看出他的配套了，这里设为null 之后呢，吸构函数这边就会去检查。
不是闹的情况下才给力。
这就是他的完整故事。
一个。
对，move 有意识的一种。好吧。
好。
还有什么小地方没讲吗？这个讲完了，这个西瓜函数讲完了，回到刚刚呢嗯是都讲过了。
好。
这一个元素类型。
由于我等一下做测试的时候。
我要以不同的容器人。
都放这种元素来来测一下这个这个。
测了一下这个效率。
当我把它放到关联式的容器的时候。
关联式容器是什么？就像。
set 拉map 了。
啊，这个。
h, h, set, he should know.
不过这个hash 这个东西到了二点零有新的名称，这等一下再说。像这一种容器的，它都要检测。
个元素的大小。
为了应付这个事情。
为了应付这个融这个元素放到那种特殊容器身上，所以我在继续发展。他写一个这个小鱼的动作。
汗写一个等于的动作。
这两件事情跟这个move a away are 是没有关系的。
只是为了测试，我这边有喜，为了set。
with the set. 因为我等一下要带着做测试。
所以我们就不去讲他了。
我去讲他那这个地方，我是借用。
由于我这里头。
是一个c 风格的字符串，我这个my string 是个t 风格，this style 字符串。
我就借用把它当做把它转换为c 加加的string。
那cj 叫st string 本身就已经可以比大小了。我借用这个让我的写代码更更简单一点。
在现实中，你当然不会这么做。
我现在的人是因为我要撤。
实习学习这些东西怎么吸，而这个不是我的主要。
所以我借这个标准库。
在现实生活中，你想说我已经有标准会字符串的，我干嘛自己写一个字符串的。
好。
这是这个函数啊这个函数。
那这边有一个小函数，就是要去取得里面的那根指针。
是做什么用？是为了下面蓝色这一块。
这等一下再说，继续往下。
前面有一些counter。
它是静态的数据，所以我必须在class 的外头。
把它定义出来，并且全部我现在把它全部设为零。
v 零吗？
那下面这一个呢？
由于我等一下测试的时候，我不但把它放在我把它放在各种容器其中我会把它set。
set 的背后是一个his table，而his h table 需要也是扣的h 方式这个概念等一下会提。
所以我必须写出一个黑市方选出来叫蓝色的这一块。
啊，这个跟现在这个主题无关，所以我们都先跳过。我只解释说我必须写出这些东西。</p> <h2 id="⏳26-move-aware-class-对容器的效能测试"><a href="#⏳26-move-aware-class-对容器的效能测试" class="header-anchor">#</a> ⏳26.Move-aware class 对容器的效能测试</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>⏳27. 容器—结构与分类_旧与新的比较 — 关于实现手法

⏳28. 容器 array

⏳29. 容器 Hashtable
- 哈希表

⏳30无Unordered
- unordered

⏳31无Hash function
- 哈希函数

⏳32无forward_list『单链表』
- 单链表

⏳33无一个万用的Hash Function

⏳34. Tuple
- STL新特性，

⏳无5.35.shared_pointer
- 共享指针

⏳无5.36.Type traits
- 类型萃取
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.2faae0a0.js" defer></script><script src="/assets/js/83.eb3feba5.js" defer></script>
  </body>
</html>

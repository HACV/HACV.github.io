<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++98核心详解 | HACV</title>
    <meta name="description" content="Personal Blog Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.8eb0d87d.css" as="style"><link rel="preload" href="/assets/js/app.931cd8a0.js" as="script"><link rel="preload" href="/assets/js/91.40c4bfd2.js" as="script"><link rel="prefetch" href="/assets/js/10.6c715741.js"><link rel="prefetch" href="/assets/js/100.52dd9baf.js"><link rel="prefetch" href="/assets/js/101.0ec31e5d.js"><link rel="prefetch" href="/assets/js/102.a9e33e5e.js"><link rel="prefetch" href="/assets/js/11.03c97e4e.js"><link rel="prefetch" href="/assets/js/12.dfa489c1.js"><link rel="prefetch" href="/assets/js/13.582089a9.js"><link rel="prefetch" href="/assets/js/14.92cda26d.js"><link rel="prefetch" href="/assets/js/15.8a5be307.js"><link rel="prefetch" href="/assets/js/16.0b214665.js"><link rel="prefetch" href="/assets/js/17.78f67bcf.js"><link rel="prefetch" href="/assets/js/18.513610fb.js"><link rel="prefetch" href="/assets/js/19.98ef82a5.js"><link rel="prefetch" href="/assets/js/2.4d947c59.js"><link rel="prefetch" href="/assets/js/20.c29df3ed.js"><link rel="prefetch" href="/assets/js/21.39ce053b.js"><link rel="prefetch" href="/assets/js/22.b5beee61.js"><link rel="prefetch" href="/assets/js/23.6e7fd055.js"><link rel="prefetch" href="/assets/js/24.cc1406fb.js"><link rel="prefetch" href="/assets/js/25.f74145d3.js"><link rel="prefetch" href="/assets/js/26.9839c339.js"><link rel="prefetch" href="/assets/js/27.915e0f35.js"><link rel="prefetch" href="/assets/js/28.7f985807.js"><link rel="prefetch" href="/assets/js/29.68a37d26.js"><link rel="prefetch" href="/assets/js/3.3fb3d2e0.js"><link rel="prefetch" href="/assets/js/30.32e5b09d.js"><link rel="prefetch" href="/assets/js/31.324b00fd.js"><link rel="prefetch" href="/assets/js/32.8e71514d.js"><link rel="prefetch" href="/assets/js/33.8c516b0e.js"><link rel="prefetch" href="/assets/js/34.67aee3e3.js"><link rel="prefetch" href="/assets/js/35.aec44f16.js"><link rel="prefetch" href="/assets/js/36.b15f2ea0.js"><link rel="prefetch" href="/assets/js/37.c40cf4c2.js"><link rel="prefetch" href="/assets/js/38.5297c5fa.js"><link rel="prefetch" href="/assets/js/39.0ace46bb.js"><link rel="prefetch" href="/assets/js/4.ba66f53b.js"><link rel="prefetch" href="/assets/js/40.fc53401a.js"><link rel="prefetch" href="/assets/js/41.af307c31.js"><link rel="prefetch" href="/assets/js/42.7f800696.js"><link rel="prefetch" href="/assets/js/43.968c95f5.js"><link rel="prefetch" href="/assets/js/44.7a96a8b6.js"><link rel="prefetch" href="/assets/js/45.0dfeb8a2.js"><link rel="prefetch" href="/assets/js/46.f828055c.js"><link rel="prefetch" href="/assets/js/47.e7b243ae.js"><link rel="prefetch" href="/assets/js/48.aece5823.js"><link rel="prefetch" href="/assets/js/49.d65c2de6.js"><link rel="prefetch" href="/assets/js/5.9548bdbb.js"><link rel="prefetch" href="/assets/js/50.60d6dc35.js"><link rel="prefetch" href="/assets/js/51.c8ce8a69.js"><link rel="prefetch" href="/assets/js/52.33d22328.js"><link rel="prefetch" href="/assets/js/53.dec50ab2.js"><link rel="prefetch" href="/assets/js/54.c5ef8d8d.js"><link rel="prefetch" href="/assets/js/55.c2c79fe4.js"><link rel="prefetch" href="/assets/js/56.f971622e.js"><link rel="prefetch" href="/assets/js/57.cffcf419.js"><link rel="prefetch" href="/assets/js/58.0434262c.js"><link rel="prefetch" href="/assets/js/59.86f9bfd1.js"><link rel="prefetch" href="/assets/js/6.30af0bc8.js"><link rel="prefetch" href="/assets/js/60.f8207ce5.js"><link rel="prefetch" href="/assets/js/61.068a8672.js"><link rel="prefetch" href="/assets/js/62.daeb7d00.js"><link rel="prefetch" href="/assets/js/63.bc00694c.js"><link rel="prefetch" href="/assets/js/64.097aa60f.js"><link rel="prefetch" href="/assets/js/65.de9f6fdd.js"><link rel="prefetch" href="/assets/js/66.13530542.js"><link rel="prefetch" href="/assets/js/67.af4337ca.js"><link rel="prefetch" href="/assets/js/68.3221d0b3.js"><link rel="prefetch" href="/assets/js/69.94bc13de.js"><link rel="prefetch" href="/assets/js/7.97fcd6bf.js"><link rel="prefetch" href="/assets/js/70.0b17d9e3.js"><link rel="prefetch" href="/assets/js/71.0320bcba.js"><link rel="prefetch" href="/assets/js/72.355e4cd9.js"><link rel="prefetch" href="/assets/js/73.30bf9e55.js"><link rel="prefetch" href="/assets/js/74.a2492a3b.js"><link rel="prefetch" href="/assets/js/75.ac1937fe.js"><link rel="prefetch" href="/assets/js/76.c4b1b617.js"><link rel="prefetch" href="/assets/js/77.23895ad5.js"><link rel="prefetch" href="/assets/js/78.cd94e8ad.js"><link rel="prefetch" href="/assets/js/79.03c29d47.js"><link rel="prefetch" href="/assets/js/8.45d0f99c.js"><link rel="prefetch" href="/assets/js/80.8bdeccca.js"><link rel="prefetch" href="/assets/js/81.12ec4606.js"><link rel="prefetch" href="/assets/js/82.7e1dc9b9.js"><link rel="prefetch" href="/assets/js/83.0235d3ad.js"><link rel="prefetch" href="/assets/js/84.992b478b.js"><link rel="prefetch" href="/assets/js/85.6dff6467.js"><link rel="prefetch" href="/assets/js/86.57dd451f.js"><link rel="prefetch" href="/assets/js/87.3d217a21.js"><link rel="prefetch" href="/assets/js/88.80ca4ba2.js"><link rel="prefetch" href="/assets/js/89.d1183ec5.js"><link rel="prefetch" href="/assets/js/9.234da0a7.js"><link rel="prefetch" href="/assets/js/90.e46c9498.js"><link rel="prefetch" href="/assets/js/92.9b194108.js"><link rel="prefetch" href="/assets/js/93.c9b17bc8.js"><link rel="prefetch" href="/assets/js/94.77549315.js"><link rel="prefetch" href="/assets/js/95.100fa452.js"><link rel="prefetch" href="/assets/js/96.566b12dd.js"><link rel="prefetch" href="/assets/js/97.f1953d03.js"><link rel="prefetch" href="/assets/js/98.e4ee72ef.js"><link rel="prefetch" href="/assets/js/99.1c372332.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8eb0d87d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HACV</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/01.About/" class="nav-link">✡️About</a></div><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件和编译</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link router-link-active">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/01.About/" class="nav-link">✡️About</a></div><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件和编译</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link router-link-active">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>C++98核心详解</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#📑-目录" class="sidebar-link">📑 目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#⭐️3加1对比" class="sidebar-link">⭐️3加1对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）class" class="sidebar-link">（1）class</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）struct『c-中』" class="sidebar-link">（2）struct『C++中』</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（3）union『c-中』" class="sidebar-link">（3）union『C++中』</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（4）enum『只有它不是特殊的类』" class="sidebar-link">（4）enum『只有它不是特殊的类』</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#💾-c-98关键字" class="sidebar-link">💾 C++98关键字</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🐾工程术语" class="sidebar-link">🐾工程术语</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）『接口类、抽象类、聚合类』" class="sidebar-link">（1）『接口类、抽象类、聚合类』</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）『反射』" class="sidebar-link">（2）『反射』</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#访问private" class="sidebar-link">访问private</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（3）内存泄漏" class="sidebar-link">（3）内存泄漏</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（4）可以将『布尔值』与『整数』进行比较吗-？" class="sidebar-link">（4）可以将『布尔值』与『整数』进行比较吗 ？</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🍉类的『成员变量』和『非成员变量』" class="sidebar-link">🍉类的『成员变量』和『非成员变量』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）成员变量" class="sidebar-link">（1）成员变量</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）非成员变量" class="sidebar-link">（2）非成员变量</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#⏰类的『成员函数』和『非成员函数』" class="sidebar-link">⏰类的『成员函数』和『非成员函数』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）成员函数" class="sidebar-link">（1）成员函数</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#big-three讲解" class="sidebar-link">Big Three讲解</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#『1』构造函数详解" class="sidebar-link">『1』构造函数详解</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#『2』析构函数详解" class="sidebar-link">『2』析构函数详解</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）非成员函数" class="sidebar-link">（2）非成员函数</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🍀命名空间" class="sidebar-link">🍀命名空间</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）namespace命名空间" class="sidebar-link">（1）namespace命名空间</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🥇重载（overload）和重写（override）" class="sidebar-link">🥇重载（overload）和重写（override）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🐾六、调试工具" class="sidebar-link">🐾六、调试工具</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）valgrind" class="sidebar-link">（1）Valgrind</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）mtrace" class="sidebar-link">（2）mtrace</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🐾c-核心基础" class="sidebar-link">🐾C++核心基础</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#一、面向对象难点" class="sidebar-link">一、面向对象难点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）类型转换函数" class="sidebar-link">（1）类型转换函数</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#二、辨析：重写-override-与重载-overload-与重定义" class="sidebar-link">二、辨析：重写(Override)与重载(Overload)与重定义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#三、多态与虚函数" class="sidebar-link">三、多态与虚函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）虚函数相关" class="sidebar-link">（1）虚函数相关</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）虚函数能不能inline" class="sidebar-link">（2）虚函数能不能inline</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（3）非多态" class="sidebar-link">（3）非多态</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#三、『运算符重载』详解" class="sidebar-link">三、『运算符重载』详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）重载的2种函数类型" class="sidebar-link">（1）重载的2种函数类型</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）可以重载，但建议不要重载的运算符" class="sidebar-link">（2）可以重载，但建议不要重载的运算符</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（3）不能重载的5个运算符记忆" class="sidebar-link">（3）不能重载的5个运算符记忆</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#♻️c-中对c的const关键字增强" class="sidebar-link">♻️C++中对C的const关键字增强</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）问题导入" class="sidebar-link">（1）问题导入</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）底层原理分析" class="sidebar-link">（2）底层原理分析</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（3）结论和补充" class="sidebar-link">（3）结论和补充</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（4）补充疑问" class="sidebar-link">（4）补充疑问</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（5）详解c-中const常见用途" class="sidebar-link">（5）详解C++中const常见用途</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（6）const导致的函数重载" class="sidebar-link">（6）const导致的函数重载</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="c-98核心详解"><a href="#c-98核心详解" class="header-anchor">#</a> C++98核心详解</h1> <h2 id="📑-目录"><a href="#📑-目录" class="header-anchor">#</a> 📑 目录</h2> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">-</span> C<span class="token operator">++</span>中的<span class="token keyword">const</span>
<span class="token operator">-</span> 命名空间
<span class="token operator">-</span> <span class="token keyword">static</span>成员
<span class="token operator">-</span> 到底什么是成员函数
<span class="token operator">-</span> <span class="token number">05.</span>C语言中的流和缓冲器的概念
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h2 id="⭐️3加1对比"><a href="#⭐️3加1对比" class="header-anchor">#</a> ⭐️3加1对比</h2> <h3 id="（1）class"><a href="#（1）class" class="header-anchor">#</a> （1）class</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、继承，默认是『<span class="token keyword">private</span>继承』
<span class="token number">2</span>、内部可以放成员变量，成员函数，默认成员变量访问控制是：『<span class="token keyword">private</span>』
<span class="token number">3</span>、成员函数类：
    有』构造函数
    有』析构函数
    有』虚函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="（2）struct『c-中』"><a href="#（2）struct『c-中』" class="header-anchor">#</a> （2）struct『C++中』</h3> <blockquote><p>本质：<strong>是一种class</strong></p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、继承，默认是『<span class="token keyword">public</span>继承』____
<span class="token number">2</span>、内部可以放成员变量，成员函数，默认成员变量访问控制是：『<span class="token keyword">public</span>』__
<span class="token number">3</span>、成员函数类：
    有』构造函数
    有』析构函数
    有』虚函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

		<span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;a=&quot;</span><span class="token operator">&lt;&lt;</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;die AAA&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;*AAA******&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//struct B : private A</span>
<span class="token comment">//下面的写法，等价于，struct B : public A</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span>  <span class="token base-clause"><span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">888</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;b=&quot;</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;die BBB&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;*BBBB******&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

	<span class="token comment">//因为加上了system(&quot;pause&quot;);所以需要下面这样挂掉B，才能知道B的析构函数被调用</span>

	<span class="token punctuation">{</span>
		A one<span class="token punctuation">;</span>
		one<span class="token punctuation">.</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		B two<span class="token punctuation">;</span>
		two<span class="token punctuation">.</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

		A <span class="token operator">*</span> pointer<span class="token operator">=</span><span class="token keyword">new</span> B<span class="token punctuation">;</span>
		pointer<span class="token operator">-&gt;</span><span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br></div></div><h3 id="（3）union『c-中』"><a href="#（3）union『c-中』" class="header-anchor">#</a> （3）union『C++中』</h3> <blockquote><p>本质：它是一种<strong>特殊的类</strong></p></blockquote> <ul><li>参考《后台开发》</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、继承：继承自别人<span class="token operator">/</span>能给别人继承都『不可以』______
<span class="token number">2</span>、内部可以放成员变量，成员函数，默认成员变量访问控制是：『<span class="token keyword">public</span>』__
<span class="token number">3</span>、成员函数类：
    有』构造函数
    有』析构函数
    不可以有』虚函数______
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="（4）enum『只有它不是特殊的类』"><a href="#（4）enum『只有它不是特殊的类』" class="header-anchor">#</a> （4）enum『只有它不是特殊的类』</h3> <blockquote><p>枚举类型<strong>是1种基本类型</strong>，不是1种构造类型，因为它不能再分解为任何其他基本类型『比如，class,struct,union』</p></blockquote> <h2 id="💾-c-98关键字"><a href="#💾-c-98关键字" class="header-anchor">#</a> 💾 C++98关键字</h2> <ul><li><p>1、static</p> <ul><li>修改变量或函数存储的形式，比如.date，.bss</li></ul></li> <li><p>2、const</p> <ul><li>修改变量or函数的只读方式</li></ul></li> <li><p>3、inline</p> <ul><li>建议在“编译期”，直接将整个函数的代码插入调用语句处</li></ul></li> <li><p>4、friend</p> <ul><li>声明友元，包括，友元函数，友元类</li></ul></li></ul> <h2 id="🐾工程术语"><a href="#🐾工程术语" class="header-anchor">#</a> 🐾工程术语</h2> <h3 id="（1）『接口类、抽象类、聚合类』"><a href="#（1）『接口类、抽象类、聚合类』" class="header-anchor">#</a> （1）『接口类、抽象类、聚合类』</h3> <ul><li>接口类：<strong>仅仅</strong>含有含有pure virtual （纯虚函数）的类</li> <li>抽象类：含有pure virtual （纯虚函数）的类</li></ul> <blockquote><p>So，抽象类和接口都<strong>不能</strong>被实例化</p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>类不可以多继承，而接口可以多实现
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="（2）『反射』"><a href="#（2）『反射』" class="header-anchor">#</a> （2）『反射』</h3> <ul><li>C++ 本身<strong>并不支持</strong>反射，而 Java 支持反射机制</li></ul> <h3 id="访问private"><a href="#访问private" class="header-anchor">#</a> 访问private</h3> <p>类中的数据域使用private修饰为私有变量
反射也可以访问
什么是反射访问？？？</p> <ul><li>通过类的层面，来取得类中方法</li></ul> <h3 id="（3）内存泄漏"><a href="#（3）内存泄漏" class="header-anchor">#</a> （3）内存泄漏</h3> <ul><li>内存泄漏是不仅仅出现在C/C++程序的问题，<strong>Java程序也会内存泄漏</strong>！</li> <li>java是自动管理内存的，但是也会有内存泄露，比如加入HashMap的对象hash值改变了就无法从HashMap中remove，这就造成了内存泄露</li></ul> <h3 id="（4）可以将『布尔值』与『整数』进行比较吗-？"><a href="#（4）可以将『布尔值』与『整数』进行比较吗-？" class="header-anchor">#</a> （4）可以将『布尔值』与『整数』进行比较吗 ？</h3> <ul><li>Java不可以！</li> <li>C++可以</li></ul> <h2 id="🍉类的『成员变量』和『非成员变量』"><a href="#🍉类的『成员变量』和『非成员变量』" class="header-anchor">#</a> 🍉类的『成员变量』和『非成员变量』</h2> <h3 id="（1）成员变量"><a href="#（1）成员变量" class="header-anchor">#</a> （1）成员变量</h3> <p><strong>书中记载</strong>：</p> <ul><li>nonstatic member 非静态成员
<ul><li>普通数据成员</li> <li>const数据成员</li></ul></li> <li>static member 静态成员</li></ul> <p><strong>static成员变量</strong></p> <ul><li>c++的一个类中『<strong>声明</strong>』一个static成员变量，static是加了访问控制的全局变量，不被继承</li> <li>类和子类对象，static变量占有一份内存</li></ul> <blockquote><p>重点理解：<strong>静态成员变量的初始化一定要在『类外』</strong></p></blockquote> <p>原因： 因为静态成员变量本身在main函数未开始时已经存在。不要让成员变量的初始化依赖于对象。不用对象，难到就不能用这一变量了吗？如果将初始化放在类内。那么<strong>当不声明对象时</strong>，无法使用这一静态变量。编译器报错为‘undeclared identifier’</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>类中的声明和定义辨析：（重点、难点）
笔者的看法是：
1、逻辑上说明是一起，只能表示可以『声明』在一起。（声明的门槛很低）
2、具体内存在哪分配，这个决定『能不能在类内』进行『定义』

比如：
1、友元函数在『类内』声明，不能在『类内』定义，能在『类外』定义
2、static成员变量在『类内』声明，不能在『类内』定义，能在『类外』定义
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>参考自：<a href="https://www.huaweicloud.com/articles/4637f3d11eb3fd9a38e017041e23e50a.html" target="_blank" rel="noopener noreferrer">华为云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p><strong>static和非static特点</strong></p> <ul><li>静态成员存在于<strong>内存</strong>，非静态成员需要实例化才会分配内存（注意，也就是在虚拟内存空间中，表示的是.bss和.data段中）</li> <li>非静态成员的生存期决定于该类的生存期，而静态成员生存期则与程序生命期相同</li></ul> <h3 id="（2）非成员变量"><a href="#（2）非成员变量" class="header-anchor">#</a> （2）非成员变量</h3> <h2 id="⏰类的『成员函数』和『非成员函数』"><a href="#⏰类的『成员函数』和『非成员函数』" class="header-anchor">#</a> ⏰<strong>类的『成员函数』和『非成员函数』</strong></h2> <blockquote><p>我的<a href="http://naotu.baidu.com/file/02d2413a51829d0c29226a23718613ad?token=d83f2eb1c2d887a6" target="_blank" rel="noopener noreferrer">百度脑图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>说明：成员函数的分类，需要考虑排序组合，<strong>是很多，很复杂</strong>的，不然就只能一个一个维度去分类。</p></blockquote> <ul><li>到底什么是成员函数</li></ul> <p>类的成员函数
类的非成员函数</p> <hr> <p>静态成员函数static
常量成员函数const
虚函数
友元函数</p> <ul><li>类的成员函数：是定义为<strong>类的一部分</strong>的函数，有时也被称为方法。（C++primer第5版，P20）</li> <li>各类函数中：构造函数、析构函数、拷贝初始化构造函数等是类的成员函数。</li></ul> <h3 id="（1）成员函数"><a href="#（1）成员函数" class="header-anchor">#</a> （1）成员函数</h3> <ul><li>成员函数分下面3类（应该说是2类，纯虚函数属于虚函数的子集的话）</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、非虚函数（non-virtual 函数）：
你『不希望』派生类（derived class）重新定义 (override, 复写) 它.

2、虚函数（virtual 函數）：
你希望 derived class 重新定义 (override, 复写) 它，且你对它已有『默认』定义。


3、纯虚函数（pure virtual 函數）：
你希望 derived class 『一定』要重新定义 (override 复写)
它，你对它沒有默认定义。

PS：我们把不是纯的虚函数的虚函数叫作（impure virtual函数）
PS：在语法上，我们只要在任何一个函数前面加上virtual这样一个关键字，它就成为一个虚函数。
数据可以被继承下来，就是占它用了内存。
函数的继承如何理解？但是不应该从内存角度理解，函数的继承，继承的是调用权利

PS：其实纯虚函数是可以有定义的！！
&gt; 出处：《C++Primer》中文版第五版541页第22行。
我们可以为纯虚函数提供定义，不过函数体『必须定义在类的外部』。若定义在类的内部，会出现错误：pure-specifier on function-definition。
》 虚函数是可以定义『在类的内部的』，外部也可以！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>参考自：侯捷</p></blockquote> <ul><li><p><strong>override</strong>这个术语，在这个主题不能随便用！！</p></li> <li><p>这个术语，<strong>一定是用在『虚函数』被重新定义，才能够叫（override）</strong></p></li> <li><p>🐾无法继承的『static函数』</p></li> <li><p><strong>纯虚函数</strong>：只提供一个<strong>接口</strong>，具体实现方法需要<strong>派生类</strong>自己去实现，纯虚函数本身不可以有实现</p></li> <li><p><strong>非虚函数</strong>：提供接口，并且强制<strong>实现</strong>方法</p></li></ul> <blockquote><p>根据《<strong>深度探索C++对象模型</strong>》一书所说：</p></blockquote> <p>原始的“C with Classes”只支持，<strong>（Nonstatic member function）非静态成员函数</strong></p> <p><strong>（Virtual function）虚函数</strong>，是在20世纪80年代中期加入进来的。</p> <p><strong>（Static member function）静态成员函数</strong>是最后被引入的一种函数类型!</p> <p>书中说道：<font style="background:blue;">C++支持3种类型的**（member function）成员函数**</font>『记住下面的』</p> <ul><li>1、static member function</li> <li>2、nonstatic member function
<ul><li>1、普通的成员函数</li> <li>2、const成员函数</li></ul></li> <li>3、virtual member function</li></ul> <p>成员函数中<strong>易错</strong>：</p> <ul><li>由于成员函数中的const成员函数，const<strong>实际</strong>上修饰的是<strong>this指针</strong>。</li> <li>所以<strong>在成员函数</strong>中，<strong>static</strong>和<strong>const不能同时</strong>修饰同一个成员函数，因为static成员函数没有this指针。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">//这行没错</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">1000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token comment">//修饰变量，这行却没错</span>
		<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
  
    	<span class="token comment">//下面会出错，[Error] static member function 'static void A::demo()' cannot have cv-qualifier</span>
		<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> 
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">A</span><span class="token operator">::</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="big-three讲解"><a href="#big-three讲解" class="header-anchor">#</a> Big Three讲解</h3> <h3 id="『1』构造函数详解"><a href="#『1』构造函数详解" class="header-anchor">#</a> 『1』构造函数详解</h3> <h4 id="_1-普通ctor（普通构造函数）"><a href="#_1-普通ctor（普通构造函数）" class="header-anchor">#</a> 1.普通ctor（普通构造函数）</h4> <ul><li>1、无参的普通构造函数</li> <li>2、有参的普通构造函数
<ul><li>（1）类型转换构造函数：只有1个参数的普通构造函数一般都可以称作『类型转换构造函数』</li> <li>（2）其他有参的普通构造函数</li></ul></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token comment">//无参的『普通构造函数』</span>
    	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    	<span class="token comment">//有参的『普通构造函数』，并且由于只有1个参数，也叫『类型转换构造函数』</span>
    	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          	cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Int Constructor calles&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    	<span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Copy ctor&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
            <span class="token comment">//拷贝构造函数，原因是参数是『本类类型的引用』</span>
        <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h4 id="_2-copy-ctor"><a href="#_2-copy-ctor" class="header-anchor">#</a> 2.copy ctor</h4> <ul><li>又称；复制构造函数/拷贝构造函数/拷贝初始化构造函数</li></ul> <p>分为：</p> <ul><li>1、默认的『copy ctor』</li> <li>2、如果你自行编写了新的copy ctor，那么默认的copy ctor就不存在了</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Demo <span class="token function">c2</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//会调用copy ctor，初始化</span>
Demo c2<span class="token operator">=</span>c1<span class="token punctuation">;</span><span class="token comment">//会调用copy ctor，注意是初始化，不是赋值！</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="『2』析构函数详解"><a href="#『2』析构函数详解" class="header-anchor">#</a> 『2』析构函数详解</h3> <ul><li><strong>没有</strong>virtual的析构函数</li></ul> <blockquote><p>又称：<strong>一般</strong>的析构函数</p></blockquote> <ul><li><strong>有</strong>virtual的析构函数</li></ul> <h3 id="（2）非成员函数"><a href="#（2）非成员函数" class="header-anchor">#</a> （2）非成员函数</h3> <h4 id="_1、友元函数"><a href="#_1、友元函数" class="header-anchor">#</a> 1、友元函数</h4> <ul><li>注意：友元函数不是类的成员函数！（<strong>欢聚时代</strong>）</li></ul> <p>1、友元函数的『<strong>声明</strong>』可以放在类<strong>声明</strong>的任何地方，不受访问限定关键字private、protected、public的限制</p> <p>2、尽管友元函数的<strong>原型</strong>有在<strong>类的定义</strong>中出现过，但是<strong>友元函数并不是成员函数</strong>。</p> <p>3、友元是一种<strong>定义在类外部</strong>的普通函数，但它需要在类体内进行<strong>说明『声明』</strong>，为了与该类的成员函数加以区别，在说明时前面加以关键字friend</p> <blockquote><p>参考自：菜鸟教程<a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html" target="_blank" rel="noopener noreferrer">C++ 友元函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h4 id="_2、友元"><a href="#_2、友元" class="header-anchor">#</a> 2、友元</h4> <p>友元函数是不能被继承的
友元函数没有this指针
友元只是破坏了类的隐藏性和封装性，可以直接调用，不需要通过对象或者指针</p> <ul><li><p>一个基类的声明中有纯虚函数，该基类派生类一定不再是抽象类（错误）</p></li> <li><p>如果在派生类中没有对所有纯虚函数进行定义，则此派生类仍然是抽象类，不能用来定义对象。所以A错.</p></li> <li><p>构造函数不能被覆盖</p></li></ul> <h2 id="🍀命名空间"><a href="#🍀命名空间" class="header-anchor">#</a> 🍀命名空间</h2> <h3 id="（1）namespace命名空间"><a href="#（1）namespace命名空间" class="header-anchor">#</a> （1）namespace命名空间</h3> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>- namespace，是指标识符的各种可见范围

- C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。

  一 ：&lt;iostream&gt;和&lt;iostream.h&gt;格式不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在**全局空间**里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。 因此。

- 1、命名空间主要是将[全局空间]『』『『划分为更加小块的全局空间
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="🥇重载（overload）和重写（override）"><a href="#🥇重载（overload）和重写（override）" class="header-anchor">#</a> 🥇重载（overload）和重写（override）</h2> <ul><li>虚成员函数不可能是static 成员函数</li></ul> <h2 id="🐾六、调试工具"><a href="#🐾六、调试工具" class="header-anchor">#</a> 🐾六、调试工具</h2> <h3 id="（1）valgrind"><a href="#（1）valgrind" class="header-anchor">#</a> （1）Valgrind</h3> <blockquote><p>1款内存分析工具，是『1套』Linux下的开放源代码的仿真调试工具的集合。</p></blockquote> <ul><li><p>开源链接：<a href="https://github.com/svn2github/valgrind" target="_blank" rel="noopener noreferrer">https://github.com/svn2github/valgrind<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></li> <li><p>『可用于，检查“内存泄漏”』</p></li></ul> <h3 id="（2）mtrace"><a href="#（2）mtrace" class="header-anchor">#</a> （2）mtrace</h3> <ul><li>开源链接：<a href="https://github.com/aclements/mtrace" target="_blank" rel="noopener noreferrer">https://github.com/aclements/mtrace<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>『可用于，检查“内存泄漏”』</li></ul> <h2 id="🐾c-核心基础"><a href="#🐾c-核心基础" class="header-anchor">#</a> 🐾C++核心基础</h2> <h2 id="一、面向对象难点"><a href="#一、面向对象难点" class="header-anchor">#</a> 一、面向对象难点</h2> <ul><li>面向对象的三大基本特征：封装、继承、多态</li> <li>面向对象的五大基本原则：</li> <li>单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则</li></ul> <h3 id="（1）类型转换函数"><a href="#（1）类型转换函数" class="header-anchor">#</a> （1）类型转换函数</h3> <ul><li><p>带非默认参数的构造函数可以把基本类型数据转换成类类型对象。</p></li> <li><p>类型转换函数可以把类类型对象转换为其他指定类型对象。</p></li> <li><p>类型转换函数只能定义为一个类的成员函数，不能定义为类的友元函数。</p></li></ul> <h2 id="二、辨析：重写-override-与重载-overload-与重定义"><a href="#二、辨析：重写-override-与重载-overload-与重定义" class="header-anchor">#</a> 二、辨析：重写(Override)与重载(Overload)与重定义</h2> <ul><li><strong>重载(Overload)</strong>：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。</li> <li><strong>重定义</strong>：也叫做隐藏，子类<strong>重新定义</strong>父类中有相同名称的<font style="background:yellow;">『<strong>非虚函数</strong>』 </font>( 参数列表可以不同 ) ，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。</li> <li><strong>重写(Override)</strong>：也叫做<strong>覆盖</strong>，也叫<strong>复写</strong>，一般发生在子类和父类继承关系之间。子类<strong>重新定义</strong>父类中有相同名称和参数的<font style="background:yellow;">『<strong>虚函数</strong>』</font>。</li></ul> <blockquote><p>参考：<a href="https://blog.csdn.net/u010275850/article/details/45583705" target="_blank" rel="noopener noreferrer">C++_重载、重写和重定义的区别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>PS：但是，从很多英语教材上面，来说，重定义和重写都是单词（override），理解参考第4节</p> <h2 id="三、多态与虚函数"><a href="#三、多态与虚函数" class="header-anchor">#</a> 三、多态与虚函数</h2> <h3 id="（1）虚函数相关"><a href="#（1）虚函数相关" class="header-anchor">#</a> （1）虚函数相关</h3> <ul><li>1、（static）静态函数不可以是虚函数</li> <li>2、（inline）虚函数可以声明为inline，但是编译器不会将其作为inline函数处理</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">a</span>
<span class="token punctuation">{</span>
    <span class="token keyword">inline</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
尽管以上写法是没有语法错误的，并且可以执行，但其实test函数已经不是内联函数了，因为<span class="token keyword">inline</span>只是对编译器的一个建议而已。
搞清本质就好。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>多态是为了<strong>接口</strong>重用，封装和继承是为了代码重用</p> <p>子类重新定义父类虚函数的方法叫做覆写</p> <h3 id="（2）虚函数能不能inline"><a href="#（2）虚函数能不能inline" class="header-anchor">#</a> （2）虚函数能不能inline</h3> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Q:虚函数不能内联，但是语法不出错？

A:不是的，虚函数在没有表现多态的时候是可以内联的，表现多态的时候不能
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><ul><li>虚函数不可以内联，因为虚函数是在运行期的时候确定具体调用的函数，内联是在编译期的时候进行代码展开，两者冲突，所以没有一起使用的做法。</li> <li>内联只是对编译器的一种请求，是否真正内联要看编译器的处理，虚函数是可以内联的，但是编译器不会响应内联请求，即他会忽略内联说明，将其当做普通虚函数处理。</li></ul> <p><strong>在C++中，为了让某个类只能通过new来创建（即如果直接创建对象，编译器将报错），应该</strong>（）</p> <ul><li>将析构函数设为私有</li></ul> <h3 id="（3）非多态"><a href="#（3）非多态" class="header-anchor">#</a> （3）非多态</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;AAA&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;BBB&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>	
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	
	A <span class="token operator">*</span> p<span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span><span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> 

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br></div></div><h2 id="三、『运算符重载』详解"><a href="#三、『运算符重载』详解" class="header-anchor">#</a> 三、『运算符重载』详解</h2> <blockquote><p>（本质还是函数重载）</p></blockquote> <h3 id="（1）重载的2种函数类型"><a href="#（1）重载的2种函数类型" class="header-anchor">#</a> （1）重载的2种函数类型</h3> <ul><li>1、成员函数</li> <li>2、友元函数『属于，非成员函数』</li></ul> <blockquote><p>易错：有的运算符，只能重载为『成员函数』</p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">=</span> 			
<span class="token punctuation">[</span><span class="token punctuation">]</span>			<span class="token comment">//重载，下标运算符，比如重载后，返回当前vetor中的元素，需要this指针，而非成员函数是没有this指针的233</span>
<span class="token punctuation">(</span><span class="token punctuation">)</span>			<span class="token comment">//重载，函数调用运算符，</span>
<span class="token operator">-&gt;</span>
上面<span class="token number">4</span>个，『只能』通过成员函数进行重载
我的理解，备注如上
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="（2）可以重载，但建议不要重载的运算符"><a href="#（2）可以重载，但建议不要重载的运算符" class="header-anchor">#</a> （2）可以重载，但建议不要重载的运算符</h3> <ul><li><code>&amp;&amp;</code>和<code>||</code>很建议不要重载『会出点问题』</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、因为，重载运算符，也就意味着靠函数重载来完成，操作数会作为『函数参数，传递』
<span class="token number">2</span>、C<span class="token operator">++</span>的『函数参数都会被求值，无法实现（短路规则）』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="（3）不能重载的5个运算符记忆"><a href="#（3）不能重载的5个运算符记忆" class="header-anchor">#</a> （3）不能重载的5个运算符记忆</h3> <ul><li><p>百度招聘考过。</p></li> <li><p>1、第1个，也是我们常常忘记是运算符的<code>sizeof</code></p></li> <li><p>2、其他4个，记住只要挂<code>.</code>的运算符<strong>均不能被重载</strong></p></li></ul> <blockquote><p>第2点，参考自用户讨论：@<a href="https://www.nowcoder.com/profile/2887214" target="_blank" rel="noopener noreferrer">牛客2887214号<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>C<span class="token operator">++</span>不能重载的总共五个：
（<span class="token number">1</span>）<span class="token string">&quot;.&quot;</span>（类成员访问运算符） 
（<span class="token number">2</span>）<span class="token string">&quot; .*&quot;</span>（类成员指针访问运算符） 
（<span class="token number">3</span>）<span class="token string">&quot;::&quot;</span>（域运算符） 
（<span class="token number">4</span>）<span class="token string">&quot;siezof&quot;</span>（长度运算符） 
（<span class="token number">5</span>）<span class="token string">&quot; ?:&quot;</span>（条件运算符）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="♻️c-中对c的const关键字增强"><a href="#♻️c-中对c的const关键字增强" class="header-anchor">#</a> ♻️C++中对C的const关键字增强</h2> <p>title: C++的const底层机制
date: 2020-05-31 08:11:04
summary: C++对C的const关键字增强的底层机制</p> <h3 id="（1）问题导入"><a href="#（1）问题导入" class="header-anchor">#</a> （1）问题导入</h3> <p>背景：
我们总说C语言中const修饰的变量看上去似乎是常量，其实是个“冒牌货”，应该叫”常变量”，比如用指针间接赋值，就能改变了。</p> <p>代码测试：
将指针间接修改变量值的代码放到C语言编译器和C++编译器去测试</p> <p>DevC++的C语言编译器</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">//demo.c </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
	p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>结果：
<img src="/photos/2020.5.30_31/01.png" width="80%"></p> <p>DevC++的C++语言编译器</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//test.cpp </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
	p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>结果：
<img src="/photos/2020.5.30_31/02.png" width="80%"></p> <p>奇特的结果：
我们要是写了这样的函数在银行程序中，要是用不同编译器，那么对账就对不上了。
总结：
C中的const是个常变量，变量的值能够被间接修改。
C++中的const是一个真正的常量！</p> <p>Tips：</p> <table><td bgcolor="#FFFF" FF>
以上两次测试，都没有显示warning和error</td></table> <p>那么，我们或许会疑惑：
Q：我们说C++中的是一个真正的常量，那为什么，没有C++编译器对我们”用指针间接修改”的行为，没有报warning或者error呢？
A：C++要兼容C，所以，它认为这个语法是可以的
Q：那么问题又来了，那他既然兼容，那么为什么最后却没改变那个变量的值呢？
A：因为C++只是兼容那种语法写法，但是底层的实现却对const关键字进行了加强。</p> <h3 id="（2）底层原理分析"><a href="#（2）底层原理分析" class="header-anchor">#</a> （2）底层原理分析</h3> <h4 id="_1、c-编译器对const做了一些加强，做了一些特殊的处理"><a href="#_1、c-编译器对const做了一些加强，做了一些特殊的处理" class="header-anchor">#</a> 1、C++编译器对const做了一些加强，做了一些特殊的处理</h4> <p>当C++编译器，扫描到常量声明时，它不再像C语言那样，把这个const给它单独分配内存。</p> <p>在我们先前的//test.cpp中。
C++进行了如下操作：</p> <blockquote><ul><li>1）扫描到这一行，const int a=98;
C++编译器会把这个<b>变量a</b>放在一个<b>符号表（键值-值对）</b>里面
<b>此时，并没有分配内存！！！</b>
注意：这样的话，key和value是定了，不能修改的了。
符号表具体的实现和我们的内存中的，栈，堆不是同一套实现机制。
有很多常量就都放在这个里面了。
Tips：
当你去<b>使用</b>这个a的时候，它就给你从符号表里面给你把这个98给拿出来，供你<b>使用</b></li></ul></blockquote> <table><td bgcolor="#FFFF" FF>
注意&quot;使用&quot;一词</td></table> <blockquote><ul><li>2）遇到类似这样的情况，此时才给a变量另外分配一个内存。
扫描到这一句p=(int <em>)&amp;a;
当你对这个a变量取地址的时候，C++编译器，会为这个a再<b>单独的开辟一块内存空间</b>，然后你把这个内存空间，赋给了p，相当于一个指针P指向了这里。然后你通过</em>p去间接的修改的地址，不再是原来的值（value）,而是我们新开辟的空间的值（注意理解）
所以，当你再使用a的时候，你打印的还是98（符号表中的a）
<img src="/photos/2020.5.30_31/03.png" width="90%"></li></ul></blockquote> <h4 id="_2、证明"><a href="#_2、证明" class="header-anchor">#</a> 2、证明</h4> <p>我们现在来证明这个开辟的内存空间的存在</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//solution.cpp </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
	p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span> 
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;a=%d\n&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;*p=%d&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>打印的是:
<img src="/photos/2020.5.30_31/04.png" width="80%"></p> <p><b>注意：</b></p> <table><td bgcolor="#FFFF" FF>
C++编译器虽然可能为const常量分配空间，但不会<b>使用</b>其存储空间中的值，除非你用指针操作。</td></table> <h3 id="（3）结论和补充"><a href="#（3）结论和补充" class="header-anchor">#</a> （3）结论和补充</h3> <p>1）C语言中的const变量
C语言中const变量是只读变量，<b>有自己的存储空间</b>
2）C++中的const常量</p> <table><td bgcolor="#FFFF" FF>
注意：可能分配存储空间,也可能不分配存储空间!</td></table> <p>编译过程中若发现<b>使用常量</b>则直接以符号表中的值替换</p> <p>Tips：
只有下面两种的时候，它才会分配空间</p> <blockquote><ul><li>当const常量为全局，并且需要在其它文件中使用,即使用了<b>extern</b>操作符</li> <li>当使用&amp;操作符取const常量的地址，编译过程中若发现对const使用了<b>&amp;操作符</b>，则给对应的常量分配存储空间（兼容C）</li></ul></blockquote> <h3 id="（4）补充疑问"><a href="#（4）补充疑问" class="header-anchor">#</a> （4）补充疑问</h3> <p>Q：那么要是分配内存，C++中那个const的分配内存是在什么时候分配的呢？是在编译器<b>编译阶段</b>，还是在<b>执行阶段</b>分配？</p> <table><td bgcolor="#FFFF" FF>
Ａ：C++中const分配内存的时机，是在编译期间！（记住！）</td></table> <p>证明的代码：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//test.cpp </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;a=%d\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;b=%d\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用了取地址 </span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;c=%d\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div> <img src="/photos/2020.5.30_31/05.png" width="80%"> <p>结果表明：
const int b的地址在a和c之间，符合我们局部变量申请内存的<b>压栈的顺序</b>，<b>它并没有因为，&amp;b这句话写到int c后面，就先分配a，c最后才b</b>，而是，它扫描完之后，看到这里有&amp;b了，就分配地址了。</p> <h3 id="（5）详解c-中const常见用途"><a href="#（5）详解c-中const常见用途" class="header-anchor">#</a> （5）详解C++中const常见用途</h3> <p>C++对C语言的const关键字进行了增强！
<font color="red" size="3">
特点：
C++中的const修饰的变量，变成了真正的常量，所以叫const常量</font></p> <blockquote><ul><li>区别：</li></ul> <blockquote><ul><li>1）C语言中的const变量
C语言中const变量是只读变量，<b>有自己的存储空间</b></li> <li>2）C++中的const常量
注意：<b>可能分配存储空间,也可能不分配存储空间!</b></li></ul></blockquote></blockquote> <p>Tips:要想了解C++中const实现机制，请移步《C++中对C的const关键字增强》一文</p> <h4 id="_1、const成员函数"><a href="#_1、const成员函数" class="header-anchor">#</a> 1、const成员函数</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> itslength<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">//成员函数声明为常量</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当成员函数被声明为const时，如果这个const成员函数试图修改这个对象的数据，编译器将视为错误。
因为：你都和我约定了不能修改，那就得履行。</p> <h4 id="_2、指向const对象的指针"><a href="#_2、指向const对象的指针" class="header-anchor">#</a> 2、指向const对象的指针</h4> <p>如果声明了一个<b>指向const对象</b>的指针，则通过该指针只能调用const方法（成员函数）。</p> <blockquote><p>-因为：const就是用来规定，<b>属于这个对象</b>的是不能有改变的</p> <blockquote><ul><li>const成员函数（常量成员函数），不会去修改这个对象任何<b>非静态成员变量</b>的值。</li> <li>static成员函数（静态成员函数），也不会去修改这个对象任何<b>非静态成员变量</b>(毕竟，静态成员函数和静态成员变量其实本质是全局变量嘛，不需要作用在具体的对象上，<b>我们写在类里面，只是为了彰显和这个类有紧密的关系</b>)</li> <li>因此，我们指向const对象的指针，能够调用的是const成员函数和static成员函数</li> <li>普通成员函数，内部可以实现修改非静态成员变量的语句，所以<b>可能会破坏const对象规定的，不能改变我的内部数据的原则</b>。</li></ul></blockquote></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Rectangle<span class="token operator">*</span> pRect <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>
<span class="token keyword">const</span> Rectangle <span class="token operator">*</span> pConstRect <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>     <span class="token comment">//指向const对象</span>
Rectangle<span class="token operator">*</span> <span class="token keyword">const</span> pConstPtr <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>
<span class="token comment">// pConstRect是指向const对象的指针，它只能使用声明为const的成员函数，如GetLength（）。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_3、const-修饰函数的返回值"><a href="#_3、const-修饰函数的返回值" class="header-anchor">#</a> 3、const 修饰函数的返回值</h4> <p>函数返回值采用“引用传递”的场合,出现在类的赋值函数中，目的是为了实现链式表达。
例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
A <span class="token operator">&amp;</span> operate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 赋值函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span> <span class="token comment">// a, b, c 为A 的对象</span>
a <span class="token operator">=</span> b <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 正常的链式赋值</span>
<span class="token punctuation">(</span>a <span class="token operator">=</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 不正常的链式赋值，但合法</span>
<span class="token comment">//如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_4、补充"><a href="#_4、补充" class="header-anchor">#</a> 4、补充</h4> <blockquote><ul><li>非const对象可以访问<b>任意的</b>成员函数,自然包括const成员函数,静态成员函数</li> <li>const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.</li> <li>const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查。</li> <li>然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</li></ul></blockquote> <p>补充杂项：</p> <blockquote><ul><li>const 修饰引用（&amp;）修饰输入参数的用法：</li></ul> <blockquote><ul><li>1-对于<b>非内部数据类型</b>的输入参数，应该将“<b>值传递</b>”的方式改为“<b>const 引用传递</b>”，目的是提高效率。例如将<code>void Func(A a)</code> 改为<code>void Func(const A &amp;a)</code>。当然，虽然这样的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</li> <li>2-对于<b>内部数据类型</b>的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如<code>void Func(int x)</code> 不应该改为<code>void Func(const int &amp;x)</code>。（如何理解？？？）</li></ul></blockquote></blockquote> <blockquote><ul><li>const 修饰星号（*）用法：</li></ul> <blockquote><ul><li>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数</li></ul></blockquote></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
如下语句将出现编译错误：
<span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
正确的用法是
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="（6）const导致的函数重载"><a href="#（6）const导致的函数重载" class="header-anchor">#</a> （6）const导致的函数重载</h3> <p>1、C++不允许仅根据函数的返回类型重载函数名称；
2、可以编写两个名称相同，参数也相同的函数，其中一个是<strong>const</strong>，另一个不是。</p> <ul><li>没用参数的两个函数是不能重载的.说法是不正确的，因为还有const</li></ul></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.931cd8a0.js" defer></script><script src="/assets/js/91.40c4bfd2.js" defer></script>
  </body>
</html>

<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>C++98核心详解 | HACV</title>
    <meta name="description" content="Personal Blog Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.8eb0d87d.css" as="style"><link rel="preload" href="/assets/js/app.b0d3f774.js" as="script"><link rel="preload" href="/assets/js/3.15e8b4af.js" as="script"><link rel="prefetch" href="/assets/js/10.9f12aa84.js"><link rel="prefetch" href="/assets/js/11.efe5693b.js"><link rel="prefetch" href="/assets/js/12.ba81f444.js"><link rel="prefetch" href="/assets/js/13.ab81d384.js"><link rel="prefetch" href="/assets/js/14.60dbb38c.js"><link rel="prefetch" href="/assets/js/15.ed38fa09.js"><link rel="prefetch" href="/assets/js/16.3c5d4ef4.js"><link rel="prefetch" href="/assets/js/17.9972b8eb.js"><link rel="prefetch" href="/assets/js/18.c9db9a32.js"><link rel="prefetch" href="/assets/js/19.f6e77355.js"><link rel="prefetch" href="/assets/js/2.43bd8d8d.js"><link rel="prefetch" href="/assets/js/20.212e0126.js"><link rel="prefetch" href="/assets/js/21.c14639d8.js"><link rel="prefetch" href="/assets/js/22.6e5b2f67.js"><link rel="prefetch" href="/assets/js/23.10a4855b.js"><link rel="prefetch" href="/assets/js/24.f0f7c5a8.js"><link rel="prefetch" href="/assets/js/25.a1706472.js"><link rel="prefetch" href="/assets/js/26.8cb3457c.js"><link rel="prefetch" href="/assets/js/27.be37cbcd.js"><link rel="prefetch" href="/assets/js/28.68c4ebbd.js"><link rel="prefetch" href="/assets/js/29.36fe9412.js"><link rel="prefetch" href="/assets/js/30.6408b0e0.js"><link rel="prefetch" href="/assets/js/31.a1777dcc.js"><link rel="prefetch" href="/assets/js/32.cc830263.js"><link rel="prefetch" href="/assets/js/33.eef672e3.js"><link rel="prefetch" href="/assets/js/34.02f45034.js"><link rel="prefetch" href="/assets/js/35.91415ee3.js"><link rel="prefetch" href="/assets/js/36.8de67fea.js"><link rel="prefetch" href="/assets/js/37.8196dfe6.js"><link rel="prefetch" href="/assets/js/38.5c145cab.js"><link rel="prefetch" href="/assets/js/39.9acd762f.js"><link rel="prefetch" href="/assets/js/4.a42b7175.js"><link rel="prefetch" href="/assets/js/40.88d33359.js"><link rel="prefetch" href="/assets/js/41.0dcb9549.js"><link rel="prefetch" href="/assets/js/42.97870c21.js"><link rel="prefetch" href="/assets/js/43.7a79755c.js"><link rel="prefetch" href="/assets/js/44.c0e016d6.js"><link rel="prefetch" href="/assets/js/45.6db387b0.js"><link rel="prefetch" href="/assets/js/46.166ff235.js"><link rel="prefetch" href="/assets/js/47.cf279ad5.js"><link rel="prefetch" href="/assets/js/48.b6d66d1f.js"><link rel="prefetch" href="/assets/js/49.b99f5db0.js"><link rel="prefetch" href="/assets/js/5.9b316b6f.js"><link rel="prefetch" href="/assets/js/50.189d7537.js"><link rel="prefetch" href="/assets/js/51.9967e8d3.js"><link rel="prefetch" href="/assets/js/52.f26dfffc.js"><link rel="prefetch" href="/assets/js/53.0ef2c2ad.js"><link rel="prefetch" href="/assets/js/54.189ff7f1.js"><link rel="prefetch" href="/assets/js/55.4d3d74f4.js"><link rel="prefetch" href="/assets/js/56.957769ba.js"><link rel="prefetch" href="/assets/js/57.2170a64b.js"><link rel="prefetch" href="/assets/js/58.49fde817.js"><link rel="prefetch" href="/assets/js/59.978a2e4e.js"><link rel="prefetch" href="/assets/js/6.54fcdc8d.js"><link rel="prefetch" href="/assets/js/60.79c422eb.js"><link rel="prefetch" href="/assets/js/61.2e885ec1.js"><link rel="prefetch" href="/assets/js/62.2eac06ad.js"><link rel="prefetch" href="/assets/js/63.284bf11c.js"><link rel="prefetch" href="/assets/js/64.7a4e53a4.js"><link rel="prefetch" href="/assets/js/65.4f0d2f3b.js"><link rel="prefetch" href="/assets/js/66.c656a98b.js"><link rel="prefetch" href="/assets/js/67.6f850b9d.js"><link rel="prefetch" href="/assets/js/68.da833a96.js"><link rel="prefetch" href="/assets/js/69.3552a6ad.js"><link rel="prefetch" href="/assets/js/7.8075d0ae.js"><link rel="prefetch" href="/assets/js/70.c1b7b1ae.js"><link rel="prefetch" href="/assets/js/71.a6f0a617.js"><link rel="prefetch" href="/assets/js/72.84127077.js"><link rel="prefetch" href="/assets/js/73.962f760f.js"><link rel="prefetch" href="/assets/js/74.4b1c87e2.js"><link rel="prefetch" href="/assets/js/75.18e0072b.js"><link rel="prefetch" href="/assets/js/76.a7361629.js"><link rel="prefetch" href="/assets/js/77.d186be57.js"><link rel="prefetch" href="/assets/js/78.a5d3f3e9.js"><link rel="prefetch" href="/assets/js/79.92d6cdda.js"><link rel="prefetch" href="/assets/js/8.21fc4e67.js"><link rel="prefetch" href="/assets/js/80.116c7d45.js"><link rel="prefetch" href="/assets/js/81.a60ad420.js"><link rel="prefetch" href="/assets/js/82.bb296fd8.js"><link rel="prefetch" href="/assets/js/83.37394721.js"><link rel="prefetch" href="/assets/js/84.5af93683.js"><link rel="prefetch" href="/assets/js/85.cec13447.js"><link rel="prefetch" href="/assets/js/86.16268cf5.js"><link rel="prefetch" href="/assets/js/87.4608d6f7.js"><link rel="prefetch" href="/assets/js/88.489dda2e.js"><link rel="prefetch" href="/assets/js/89.4dccc6ea.js"><link rel="prefetch" href="/assets/js/9.f72c9269.js"><link rel="prefetch" href="/assets/js/90.627d9cac.js"><link rel="prefetch" href="/assets/js/91.0699a273.js"><link rel="prefetch" href="/assets/js/92.a3560914.js"><link rel="prefetch" href="/assets/js/93.06392e3f.js"><link rel="prefetch" href="/assets/js/94.ff4f11c6.js"><link rel="prefetch" href="/assets/js/95.f90d8a38.js"><link rel="prefetch" href="/assets/js/96.fe01526f.js"><link rel="prefetch" href="/assets/js/97.a4117e68.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8eb0d87d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HACV</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/01.About/" class="nav-link">✡️About</a></div><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件和编译</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link router-link-active">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/01.About/" class="nav-link">✡️About</a></div><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">⭐️硬件和编译</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link router-link-active">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>C++98核心详解</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#📑-目录" class="sidebar-link">📑 目录</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅c和c-从来就不是一个东西！" class="sidebar-link">✅C和C++从来就不是一个东西！</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#⭐️3加1对比" class="sidebar-link">⭐️3加1对比</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）class" class="sidebar-link">（1）class</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）struct『c-中』" class="sidebar-link">（2）struct『C++中』</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（3）union『c-中』" class="sidebar-link">（3）union『C++中』</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（4）enum『只有它不是特殊的类』" class="sidebar-link">（4）enum『只有它不是特殊的类』</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#⭐️类的『成员变量』和『非成员变量』" class="sidebar-link">⭐️类的『成员变量』和『非成员变量』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）成员变量" class="sidebar-link">（1）成员变量</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）非成员变量" class="sidebar-link">（2）非成员变量</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#⭐️类的『成员函数』和『非成员函数』" class="sidebar-link">⭐️类的『成员函数』和『非成员函数』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）成员函数" class="sidebar-link">（1）成员函数</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）非成员函数" class="sidebar-link">（2）非成员函数</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🍀big-three讲解" class="sidebar-link">🍀Big Three讲解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#『1』构造函数详解" class="sidebar-link">『1』构造函数详解</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#『2』析构函数详解" class="sidebar-link">『2』析构函数详解</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🍀namespace命名空间" class="sidebar-link">🍀namespace命名空间</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🐾一、面向对象难点" class="sidebar-link">🐾一、面向对象难点</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）类型转换函数" class="sidebar-link">（1）类型转换函数</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🥇二、辨析：重写-override-与重载-overload-与重定义" class="sidebar-link">🥇二、辨析：重写(Override)与重载(Overload)与重定义</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🐾三、多态与虚函数" class="sidebar-link">🐾三、多态与虚函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（0）static变量的说明" class="sidebar-link">（0）static变量的说明</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）虚函数相关" class="sidebar-link">（1）虚函数相关</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）虚函数能不能inline" class="sidebar-link">（2）虚函数能不能inline</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅『多态神器』-多态3条件" class="sidebar-link">✅『多态神器』-多态3条件</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#例题1、条件1和条件2不满足『非多态』" class="sidebar-link">例题1、条件1和条件2不满足『非多态』</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#例题2、条件3不满足『非多态』" class="sidebar-link">例题2、条件3不满足『非多态』</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#例题3-虚析构函数" class="sidebar-link">例题3-虚析构函数</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#例题4——多态情况下，不调用多态" class="sidebar-link">例题4——多态情况下，不调用多态</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#例题5-静态绑定" class="sidebar-link">例题5-静态绑定</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#例题6-const对象" class="sidebar-link">例题6-const对象</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🐾四、『运算符重载』详解" class="sidebar-link">🐾四、『运算符重载』详解</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）重载的2种函数类型" class="sidebar-link">（1）重载的2种函数类型</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）可以重载，但建议不要重载的运算符" class="sidebar-link">（2）可以重载，但建议不要重载的运算符</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（3）不能重载的5个运算符记忆" class="sidebar-link">（3）不能重载的5个运算符记忆</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#♻️五、c-中对c的const关键字增强" class="sidebar-link">♻️五、C++中对C的const关键字增强</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）问题导入" class="sidebar-link">（1）问题导入</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）底层原理分析" class="sidebar-link">（2）底层原理分析</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（3）结论和补充" class="sidebar-link">（3）结论和补充</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（4）补充疑问" class="sidebar-link">（4）补充疑问</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（5）详解c-中const常见用途" class="sidebar-link">（5）详解C++中const常见用途</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（6）const导致的函数重载" class="sidebar-link">（6）const导致的函数重载</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#♻️六、c-中『栈』和『堆』" class="sidebar-link">♻️六、C++中『栈』和『堆』</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#♻️七、小知识" class="sidebar-link">♻️七、小知识</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#常量表达式" class="sidebar-link">常量表达式</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#switch语法" class="sidebar-link">switch语法</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（1）switch" class="sidebar-link">（1）switch</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#（2）c-编译器好智能化" class="sidebar-link">（2）C++编译器好智能化</a></li><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#树——常考题型之一" class="sidebar-link">树——常考题型之一</a></li></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#🍉笔试—编程系列" class="sidebar-link">🍉笔试—编程系列</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#💾-c-98关键字" class="sidebar-link">💾 C++98关键字</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#✅访问属性" class="sidebar-link">✅访问属性</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/09.Language/Part04.C%2B%2B98%E6%A0%B8%E5%BF%83%E8%AF%A6%E8%A7%A3.html#内部访问和对象访问" class="sidebar-link">内部访问和对象访问</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="c-98核心详解"><a href="#c-98核心详解" class="header-anchor">#</a> C++98核心详解</h1> <h2 id="📑-目录"><a href="#📑-目录" class="header-anchor">#</a> 📑 目录</h2> <h2 id="✅c和c-从来就不是一个东西！"><a href="#✅c和c-从来就不是一个东西！" class="header-anchor">#</a> ✅C和C++从来就不是一个东西！</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>C++部分兼容C
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>参考<a href="https://www.nowcoder.com/profile/2876549" target="_blank" rel="noopener noreferrer">牛油的回答<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>如 <span class="token keyword">int</span> <span class="token operator">*</span>a<span class="token punctuation">;</span> a <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 在C<span class="token operator">++</span>中要强制转换才行
个人测试C99中有些特性在C<span class="token operator">++</span>中也没有
如下面的代码： 定义一个二维变长数组作参数的函数。gcc、clang可以编译运行通过。g<span class="token operator">++</span>、clang<span class="token operator">++</span>编译不通过。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h2 id="⭐️3加1对比"><a href="#⭐️3加1对比" class="header-anchor">#</a> ⭐️3加1对比</h2> <ul><li>class</li> <li>struct</li> <li>union</li> <li>enum『枚举类型<strong>是1种基本类型</strong>，不是1种构造类型，因为它不能再分解为任何其他基本类型，比如，<code>class</code>，<code>struct</code>，<code>union</code>』</li></ul> <h3 id="（1）class"><a href="#（1）class" class="header-anchor">#</a> （1）<code>class</code></h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、继承，默认是『<span class="token keyword">private</span>继承』
<span class="token number">2</span>、内部可以放成员变量，成员函数，默认成员变量访问控制是：『<span class="token keyword">private</span>』
<span class="token number">3</span>、成员函数类：
    有』构造函数
    有』析构函数
    有』虚函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="（2）struct『c-中』"><a href="#（2）struct『c-中』" class="header-anchor">#</a> （2）<code>struct</code>『C++中』</h3> <blockquote><p>本质：<strong>是一种class</strong></p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、继承，默认是『<span class="token keyword">public</span>继承』____
<span class="token number">2</span>、内部可以放成员变量，成员函数，默认成员变量访问控制是：『<span class="token keyword">public</span>』__
<span class="token number">3</span>、成员函数类：
    有』构造函数
    有』析构函数
    有』虚函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">struct</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">private</span><span class="token operator">:</span>
		<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">a</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">99</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

		<span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;a=&quot;</span><span class="token operator">&lt;&lt;</span><span class="token keyword">this</span><span class="token operator">-&gt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>

		<span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;die AAA&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;*AAA******&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token comment">//struct B : private A</span>
<span class="token comment">//下面的写法，等价于，struct B : public A</span>
<span class="token keyword">struct</span> <span class="token class-name">B</span> <span class="token operator">:</span>  <span class="token base-clause"><span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> b<span class="token punctuation">;</span>
	<span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token function">b</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">888</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

	<span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;b=&quot;</span><span class="token operator">&lt;&lt;</span>b<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;die BBB&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token punctuation">{</span>
		cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;*BBBB******&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
	
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>

	<span class="token comment">//因为加上了system(&quot;pause&quot;);所以需要下面这样挂掉B，才能知道B的析构函数被调用</span>

	<span class="token punctuation">{</span>
		A one<span class="token punctuation">;</span>
		one<span class="token punctuation">.</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

		B two<span class="token punctuation">;</span>
		two<span class="token punctuation">.</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 

		A <span class="token operator">*</span> pointer<span class="token operator">=</span><span class="token keyword">new</span> B<span class="token punctuation">;</span>
		pointer<span class="token operator">-&gt;</span><span class="token function">myPoly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>

	<span class="token function">system</span><span class="token punctuation">(</span><span class="token string">&quot;pause&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br></div></div><h3 id="（3）union『c-中』"><a href="#（3）union『c-中』" class="header-anchor">#</a> （3）<code>union</code>『C++中』</h3> <blockquote><p>本质：它是一种<strong>特殊的类</strong></p></blockquote> <ul><li>参考《后台开发》</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、继承：继承自别人<span class="token operator">/</span>能给别人继承都『不可以』______
<span class="token number">2</span>、内部可以放成员变量，成员函数，默认成员变量访问控制是：『<span class="token keyword">public</span>』__
<span class="token number">3</span>、成员函数类：
    有』构造函数
    有』析构函数
    不可以有』虚函数______
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="（4）enum『只有它不是特殊的类』"><a href="#（4）enum『只有它不是特殊的类』" class="header-anchor">#</a> （4）<code>enum</code>『只有它不是特殊的类』</h3> <blockquote><p>枚举类型<strong>是1种基本类型</strong>，不是1种构造类型，因为它不能再分解为任何其他基本类型『比如，<code>class</code>，<code>struct</code>，<code>union</code>』</p></blockquote> <h2 id="⭐️类的『成员变量』和『非成员变量』"><a href="#⭐️类的『成员变量』和『非成员变量』" class="header-anchor">#</a> ⭐️类的『成员变量』和『非成员变量』</h2> <img src="/assets/img/成员变量和非成员变量.42a8c1de.png"> <h3 id="（1）成员变量"><a href="#（1）成员变量" class="header-anchor">#</a> （1）成员变量</h3> <p><strong>书中记载</strong>：</p> <ul><li>nonstatic member 非静态成员
<ul><li>普通数据成员</li> <li>const数据成员</li></ul></li> <li>static member 静态成员</li></ul> <p><strong>static成员变量</strong></p> <ul><li>c++的一个类中『<strong>声明</strong>』一个static成员变量，static是加了访问控制的全局变量，不被继承</li> <li>类和子类对象，static变量占有一份内存</li></ul> <blockquote><p>重点理解：<strong>静态成员变量的初始化一定要在『类外』</strong></p></blockquote> <p>原因： 因为静态成员变量本身在main函数未开始时已经存在。不要让成员变量的初始化依赖于对象。不用对象，难到就不能用这一变量了吗？如果将初始化放在类内。那么<strong>当不声明对象时</strong>，无法使用这一静态变量。编译器报错为‘undeclared identifier’</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>类中的声明和定义辨析：（重点、难点）
笔者的看法是：
1、逻辑上说明是一起，只能表示可以『声明』在一起。（声明的门槛很低）
2、具体内存在哪分配，这个决定『能不能在类内』进行『定义』

比如：
1、友元函数在『类内』声明，不能在『类内』定义，能在『类外』定义
2、static成员变量在『类内』声明，不能在『类内』定义，能在『类外』定义
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><blockquote><p>参考自：<a href="https://www.huaweicloud.com/articles/4637f3d11eb3fd9a38e017041e23e50a.html" target="_blank" rel="noopener noreferrer">华为云<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p><strong>static和非static特点</strong></p> <ul><li>静态成员存在于<strong>内存</strong>，非静态成员需要实例化才会分配内存（注意，也就是在虚拟内存空间中，表示的是.bss和.data段中）</li> <li>非静态成员的生存期决定于该类的生存期，而静态成员生存期则与程序生命期相同</li></ul> <h3 id="（2）非成员变量"><a href="#（2）非成员变量" class="header-anchor">#</a> （2）非成员变量</h3> <h2 id="⭐️类的『成员函数』和『非成员函数』"><a href="#⭐️类的『成员函数』和『非成员函数』" class="header-anchor">#</a> ⭐️<strong>类的『成员函数』和『非成员函数』</strong></h2> <img src="/assets/img/成员函数和非成员函数.f80615b8.png"> <blockquote><p>我的<a href="http://naotu.baidu.com/file/02d2413a51829d0c29226a23718613ad?token=d83f2eb1c2d887a6" target="_blank" rel="noopener noreferrer">百度脑图<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <p>说明：成员函数的分类，需要考虑排序组合，<strong>是很多，很复杂</strong>的，不然就只能一个一个维度去分类。</p></blockquote> <h3 id="（1）成员函数"><a href="#（1）成员函数" class="header-anchor">#</a> （1）成员函数</h3> <ul><li>到底什么是成员函数？</li> <li>类的成员函数：是定义为<strong>类的一部分</strong>的函数，有时也被称为方法。（C++primer第5版，P20）</li> <li>各类函数中：构造函数、析构函数、拷贝初始化构造函数等是类的成员函数。</li> <li>成员函数分下面3类（应该说是2类，纯虚函数属于虚函数的子集的话）</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、非虚函数（non-virtual 函数）：
你『不希望』派生类（derived class）重新定义 (override, 复写) 它.



2、虚函数（virtual 函數）：
你希望 derived class 重新定义 (override, 复写) 它，且你对它已有『默认』定义。
3、纯虚函数（pure virtual 函數）：
你希望 derived class 『一定』要重新定义 (override 复写)
它，你对它沒有默认定义。

PS：我们把不是纯的虚函数的虚函数叫作（impure virtual函数）
PS：在语法上，我们只要在任何一个函数前面加上virtual这样一个关键字，它就成为一个虚函数。
数据可以被继承下来，就是占它用了内存。
函数的继承如何理解？但是不应该从内存角度理解，函数的继承，继承的是调用权利

PS：其实纯虚函数是可以有定义的！！
&gt; 出处：《C++Primer》中文版第五版541页第22行。
我们可以为纯虚函数提供定义，不过函数体『必须定义在类的外部』。若定义在类的内部，会出现错误：pure-specifier on function-definition。
》 虚函数是可以定义『在类的内部的』，外部也可以！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><blockquote><p>参考自：侯捷</p></blockquote> <ul><li><p><strong>override</strong>这个术语，在这个主题不能随便用！！</p></li> <li><p>这个术语，<strong>一定是用在『虚函数』被重新定义，才能够叫（override）</strong></p></li> <li><p>🐾<font style="background:yellow;">无法继承的『static成员函数』</font></p></li> <li><p><strong>纯虚函数</strong>：只提供一个<strong>接口</strong>，具体实现方法需要<strong>派生类</strong>自己去实现，纯虚函数本身不可以有实现</p></li> <li><p><strong>非虚函数</strong>：提供接口，并且强制<strong>实现</strong>方法</p></li></ul> <blockquote><p>根据《<strong>深度探索C++对象模型</strong>》一书所说：</p></blockquote> <p>原始的“C with Classes”只支持，<strong>（Nonstatic member function）非静态成员函数</strong></p> <p><strong>（Virtual function）虚函数</strong>，是在20世纪80年代中期加入进来的。</p> <p><strong>（Static member function）静态成员函数</strong>是最后被引入的一种函数类型!</p> <p>书中说道：<font style="background:blue;">C++支持3种类型的**（member function）成员函数**</font>『记住下面的』</p> <ul><li>1、static member function</li> <li>2、nonstatic member function
<ul><li>1、普通的成员函数</li> <li>2、const成员函数</li></ul></li> <li>3、virtual member function</li></ul> <p>成员函数中<strong>易错</strong>：</p> <ul><li>由于成员函数中的const成员函数，const<strong>实际</strong>上修饰的是<strong>this指针</strong>。</li> <li><font style="background:yellow;">所以<strong>在成员函数</strong>中，<strong>static</strong>和<strong>const不能同时</strong>修饰同一个成员函数</font>，因为static成员函数没有this指针。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token comment">//这行没错</span>
<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> maxn<span class="token operator">=</span><span class="token number">1000</span><span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token comment">//修饰变量，这行却没错</span>
		<span class="token keyword">static</span> <span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">9</span><span class="token punctuation">;</span>
  
    	<span class="token comment">//下面会出错，[Error] static member function 'static void A::demo()' cannot have cv-qualifier</span>
		<span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">const</span> 
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span>a<span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token class-name">A</span><span class="token operator">::</span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="（2）非成员函数"><a href="#（2）非成员函数" class="header-anchor">#</a> （2）非成员函数</h3> <h4 id="_1、友元函数"><a href="#_1、友元函数" class="header-anchor">#</a> 1、友元函数</h4> <ul><li>注意：<font style="background:yellow;">友元函数不是类的成员函数！</font>（<strong>欢聚时代</strong>）</li></ul> <p>1、友元函数的『<strong>声明</strong>』可以放在类<strong>声明</strong>的任何地方，不受访问限定关键字private、protected、public的限制</p> <p>2、尽管友元函数的<strong>原型</strong>有在<strong>类的定义</strong>中出现过，但是<strong>友元函数并不是成员函数</strong>。</p> <p>3、友元是一种<strong>定义在类外部</strong>的普通函数（友元函数既可以在类的内部，也可以在类的外部定义《<strong>C++primer</strong>》中说了），但它需要在类体内进行<strong>说明『声明』</strong>，为了与该类的成员函数加以区别，在说明时前面加以关键字friend</p> <blockquote><p>参考自：菜鸟教程<a href="https://www.runoob.com/cplusplus/cpp-friend-functions.html" target="_blank" rel="noopener noreferrer">C++ 友元函数<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <h4 id="_2、友元"><a href="#_2、友元" class="header-anchor">#</a> 2、友元</h4> <p>『『<font style="background:yellow;">友元函数是不能被继承的</font>——解释，你父亲的朋友不能继承给你？』』，<font style="background:yellow;">友元函数没有this指针</font>
友元只是破坏了类的隐藏性和封装性，<font style="background:yellow;">可以直接调用，不需要通过对象或者指针</font></p> <ul><li>一个基类的声明中有纯虚函数，该基类派生类一定不再是抽象类（错误）</li> <li>如果在派生类中没有对所有纯虚函数进行定义，则此派生类仍然是抽象类，不能用来定义对象。所以A错.</li> <li>构造函数不能被覆盖</li></ul> <h2 id="🍀big-three讲解"><a href="#🍀big-three讲解" class="header-anchor">#</a> 🍀Big Three讲解</h2> <h3 id="『1』构造函数详解"><a href="#『1』构造函数详解" class="header-anchor">#</a> 『1』构造函数详解</h3> <h4 id="_1-普通ctor（普通构造函数）"><a href="#_1-普通ctor（普通构造函数）" class="header-anchor">#</a> 1.普通ctor（普通构造函数）</h4> <ul><li>1、无参的普通构造函数</li> <li>2、有参的普通构造函数
<ul><li>（1）类型转换构造函数：只有1个参数的普通构造函数一般都可以称作『类型转换构造函数』</li> <li>（2）其他有参的普通构造函数</li></ul></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
    <span class="token keyword">public</span><span class="token operator">:</span>
    	<span class="token comment">//无参的『普通构造函数』</span>
    	<span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    	<span class="token comment">//有参的『普通构造函数』，并且由于只有1个参数，也叫『类型转换构造函数』</span>
    	<span class="token function">A</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
          	cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Int Constructor calles&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>  
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
    	<span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;</span> a<span class="token punctuation">)</span>
        <span class="token punctuation">{</span>
            cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;Copy ctor&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
            <span class="token comment">//拷贝构造函数，原因是参数是『本类类型的引用』</span>
        <span class="token punctuation">}</span>
    
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><h4 id="_2-copy-ctor"><a href="#_2-copy-ctor" class="header-anchor">#</a> 2.copy ctor</h4> <ul><li>又称；复制构造函数/拷贝构造函数/拷贝初始化构造函数</li></ul> <p>分为：</p> <ul><li>1、默认的『copy ctor』</li> <li>2、如果你自行编写了新的copy ctor，那么默认的copy ctor就不存在了</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Demo <span class="token function">c2</span><span class="token punctuation">(</span>c1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//会调用copy ctor，初始化</span>
Demo c2<span class="token operator">=</span>c1<span class="token punctuation">;</span><span class="token comment">//会调用copy ctor，注意是初始化，不是赋值！</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="『2』析构函数详解"><a href="#『2』析构函数详解" class="header-anchor">#</a> 『2』析构函数详解</h3> <ul><li><strong>没有</strong>virtual的析构函数</li></ul> <blockquote><p>又称：<strong>一般</strong>的析构函数</p></blockquote> <ul><li><p><strong>有</strong>virtual的析构函数</p></li> <li><p>析构时 区别 delete 和 delete[]</p></li></ul> <h5 id="在c-中，为了让某个类只能通过new来创建（即如果直接创建对象，编译器将报错），应该"><a href="#在c-中，为了让某个类只能通过new来创建（即如果直接创建对象，编译器将报错），应该" class="header-anchor">#</a> 在C++中，为了让某个类只能通过new来创建（即如果直接创建对象，编译器将报错），应该</h5> <ul><li>将析构函数设为私有</li></ul> <h2 id="🍀namespace命名空间"><a href="#🍀namespace命名空间" class="header-anchor">#</a> 🍀<code>namespace</code>命名空间</h2> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>- namespace，是指标识符的各种可见范围

- C++标准程序库中的所有标识符都被定义于一个名为std的namespace中。

  一 ：&lt;iostream&gt;和&lt;iostream.h&gt;格式不一样，前者没有后缀，实际上，在你的编译器include文件夹里面可以看到，二者是两个文件，打开文件就会发现，里面的代码是不一样的。后缀为.h的头文件c++标准已经明确提出不支持了，早些的实现将标准库功能定义在**全局空间**里，声明在带.h后缀的头文件里，c++标准为了和C区别开，也为了正确使用命名空间，规定头文件不使用后缀.h。 因此。

- 1、命名空间主要是将[全局空间]『』『『划分为更加小块的全局空间
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="🐾一、面向对象难点"><a href="#🐾一、面向对象难点" class="header-anchor">#</a> 🐾一、面向对象难点</h2> <ul><li>面向对象的三大基本特征：封装、继承、多态</li> <li>面向对象的五大基本原则：</li> <li>单一职责原则、开放封闭原则、里氏替换原则、依赖倒置原则、接口隔离原则</li></ul> <h3 id="（1）类型转换函数"><a href="#（1）类型转换函数" class="header-anchor">#</a> （1）类型转换函数</h3> <ul><li><p>带非默认参数的构造函数可以把基本类型数据转换成类类型对象。</p></li> <li><p>『类型转换函数』可以把类类型对象转换为其他指定类型对象。</p></li> <li><p>『类型转换函数』只能定义为一个类的成员函数，<strong>不能</strong>定义为类的<strong>友元函数。</strong></p></li></ul> <h2 id="🥇二、辨析：重写-override-与重载-overload-与重定义"><a href="#🥇二、辨析：重写-override-与重载-overload-与重定义" class="header-anchor">#</a> 🥇二、辨析：重写(Override)与重载(Overload)与重定义</h2> <ul><li><strong>重载(Overload)</strong>：函数名相同，函数的参数个数、参数类型或参数顺序三者中必须至少有一种不同。函数返回值的类型可以相同，也可以不相同。发生在一个类内部。</li> <li><strong>重定义</strong>：也叫做隐藏，子类<strong>重新定义</strong>父类中有相同名称的<font style="background:yellow;">『<strong>非虚函数</strong>』 </font>( 参数列表可以不同 ) ，指派生类的函数屏蔽了与其同名的基类函数。可以理解成发生在继承中的重载。</li> <li><strong>重写(Override)</strong>：也叫做<strong>覆盖</strong>，也叫<strong>复写</strong>，一般发生在子类和父类继承关系之间。子类<strong>重新定义</strong>父类中有相同名称和参数的<font style="background:yellow;">『<strong>虚函数</strong>』</font>。</li></ul> <blockquote><p>参考：<a href="https://blog.csdn.net/u010275850/article/details/45583705" target="_blank" rel="noopener noreferrer">C++_重载、重写和重定义的区别<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <p>PS：但是，从很多英语教材上面，来说，重定义和重写都是单词（override），理解参考第4节</p> <p>子类重新定义父类虚函数的方法叫做覆写</p> <p>多态是为了<strong>接口</strong>重用，封装和继承是为了代码重用</p> <h2 id="🐾三、多态与虚函数"><a href="#🐾三、多态与虚函数" class="header-anchor">#</a> 🐾三、多态与虚函数</h2> <h3 id="（0）static变量的说明"><a href="#（0）static变量的说明" class="header-anchor">#</a> （0）<code>static</code>变量的说明</h3> <p>c++的一个类中声明一个<strong>static成员变量</strong>，下面描述正确的是</p> <ul><li>static是加了访问控制的全局变量，『<strong>不被继承</strong>』，类和子类对象，static变量占有一份内存</li></ul> <h3 id="（1）虚函数相关"><a href="#（1）虚函数相关" class="header-anchor">#</a> （1）虚函数相关</h3> <ul><li>1、（static）静态函数不可以是虚函数『虚成员函数不可能是static 成员函数』</li> <li>2、（inline）虚函数可以声明为inline，但是编译器不会将其作为inline函数处理『有的选择题故意为难，但是其实虚函数是可以声明为inline的，但是分情况』』</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">a</span>
<span class="token punctuation">{</span>
    <span class="token keyword">inline</span> <span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
尽管以上写法是没有语法错误的，并且可以执行，但其实test函数已经不是内联函数了，因为<span class="token keyword">inline</span>只是对编译器的一个建议而已。
搞清本质就好。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="（2）虚函数能不能inline"><a href="#（2）虚函数能不能inline" class="header-anchor">#</a> （2）虚函数能不能inline</h3> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>Q:虚函数不能内联，但是语法不出错？

A:不是的，虚函数在『『没有表现多态的时候』』是可以内联的，表现多态的时候不能

『没有表现多态的时候』:内联只是对编译器的一种请求，是否真正内联要看编译器的处理，虚函数是可以内联的，但是编译器不会响应内联请求，即他会忽略内联说明，将其当做普通虚函数处理。

有说法说：
虚函数不可以内联，因为虚函数是在运行期的时候确定具体调用的函数，内联是在编译期的时候进行代码展开，两者冲突，所以没有一起使用的做法。『『这是不严谨的』』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="✅『多态神器』-多态3条件"><a href="#✅『多态神器』-多态3条件" class="header-anchor">#</a> ✅『多态神器』-多态3条件</h2> <ul><li>『『<code>动态绑定3条件</code>』』</li></ul> <blockquote><p>C++编译器，看到一个函数调用，他有2个考量，静态还是动态绑定：</p></blockquote> <ul><li>静态被编译成：<code>call</code></li> <li><font style="background:yellow;">动态绑定：符合某些条件就会做动态绑定，<strong>3个条件</strong></font></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、通过指针来调用『注意，引用显然也是的，因为底层也是指针』
<span class="token number">2</span>、这个指针是向上转型up cast了。『比如，派生类赋值给基类指针，基类指针调用』
<span class="token number">3</span>、调用虚函数
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="例题1、条件1和条件2不满足『非多态』"><a href="#例题1、条件1和条件2不满足『非多态』" class="header-anchor">#</a> 例题1、条件1和条件2不满足『非多态』</h3> <ul><li>牛客上配套习题：<a href="https://www.nowcoder.com/test/question/done?tid=44172669&qid=15197#summary" target="_blank" rel="noopener noreferrer">传送门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>题解：
这一题中，最后一个c，是相当于强制类型转换，『或许叫：向下转型？？』，然后没有通过指针来调用

用牛油的一个解释：动态绑定（多态）只有在指针和引用时才有效，其他情况下无效。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h3 id="例题2、条件3不满足『非多态』"><a href="#例题2、条件3不满足『非多态』" class="header-anchor">#</a> 例题2、条件3不满足『非多态』</h3> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;AAA&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>
		
<span class="token punctuation">}</span><span class="token punctuation">;</span>


<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
		<span class="token punctuation">{</span>
			cout<span class="token operator">&lt;&lt;</span><span class="token string">&quot;BBB&quot;</span><span class="token operator">&lt;&lt;</span>endl<span class="token punctuation">;</span>
		<span class="token punctuation">}</span>	
<span class="token punctuation">}</span><span class="token punctuation">;</span> 

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	
	A <span class="token operator">*</span> p<span class="token operator">=</span> <span class="token keyword">new</span> B<span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span><span class="token function">mytest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token comment">//输出的是AAA</span>
    
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
 <span class="token punctuation">}</span> 

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br></div></div><ul><li>本题不是动态绑定原因分析：</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>1、通过指针来调用『注意，引用显然也是的，因为底层也是指针』————满足，用了p-&gt;mytest();
2、这个指针是向上转型up cast了。『比如，派生类赋值给基类指针，基类指针调用』————满足，A是B的基类
3、调用虚函数——不满足，因为p指针是A类型的，但是在classA中该函数还不是『虚函数』，所以想走虚函数指针——虚函数表的路径走不通。。。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><h3 id="例题3-虚析构函数"><a href="#例题3-虚析构函数" class="header-anchor">#</a> 例题3-虚析构函数</h3> <ul><li>虚析构函数，是为了解决基类的指针指向派生类对象，并且用『基类指针』删除派生类对象。</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;iostream&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;1&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">A</span><span class="token punctuation">(</span>A <span class="token operator">&amp;</span>a<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;2&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">virtual</span> <span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;3&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
    <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;4&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">B</span><span class="token punctuation">(</span>B <span class="token operator">&amp;</span>b<span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;5&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token operator">~</span><span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">{</span>
        cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;6&quot;</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    A <span class="token operator">*</span>pa <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">delete</span> pa<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//输出是：1 4 6 3</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br></div></div><div class="language-txt line-numbers-mode"><pre class="language-text"><code>考察的是对继承体系中的构造和析构函数调用顺序的理解。
在调用new B()的时候，因为B继承A，所以会首先调用其父类的构造函数，输出1
然后调用自己的构造函数，输出4

//析构的时候，是会调用的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>对比，下面，如果去除掉A的析构函数的，虚函数</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">~</span><span class="token function">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-txt line-numbers-mode"><pre class="language-text"><code>输出为：1 4 3
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><ul><li>原因：静态绑定，this指针直接调用了A的析构，B的没有。</li> <li>很显然，有的时候，会出问题。</li></ul> <h3 id="例题4——多态情况下，不调用多态"><a href="#例题4——多态情况下，不调用多态" class="header-anchor">#</a> 例题4——多态情况下，不调用多态</h3> <ul><li>牛客网<a href="https://www.nowcoder.com/test/question/done?tid=44308742&qid=180817#summary" target="_blank" rel="noopener noreferrer">题目<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>：</li> <li>类B是类A的公有派生类，类A和类B中都定义了虚函数<code>func()</code>,p是一个指向类A对象的指针，则<code>p-&gt;A::func()</code>将</li></ul> <h3 id="例题5-静态绑定"><a href="#例题5-静态绑定" class="header-anchor">#</a> 例题5-静态绑定</h3> <ul><li>易错的题目<a href="https://www.nowcoder.com/test/question/done?tid=44470246&qid=44536#summary" target="_blank" rel="noopener noreferrer">传送门<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>

<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
	<span class="token keyword">public</span><span class="token operator">:</span>
		<span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> 
		<span class="token punctuation">{</span> 
			<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;test A&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 
		<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	A <span class="token operator">*</span>pA <span class="token operator">=</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
	pA<span class="token operator">-&gt;</span><span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><ul><li>有4个选项</li></ul> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>问你选什么？
编译出错
程序运行奔溃
输出&quot;test A&quot;
输出乱码
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><ul><li>答案：<strong>输出&quot;test A&quot;</strong></li> <li>原因：因为<strong>对于非虚成员函数，Ｃ++这门语言是静态绑定的</strong>。这也是Ｃ++语言和其它语言Java, Python的一个显著区别</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//pA-&gt;test();</span>

这语句的意图是：调用对象 pA 的 test 成员函数。如果这句话在Java或Python等动态绑定的语言之中，编译器生成的代码大概是：
找到 pA 的 test 成员函数，调用它。（注意，这里的找到是程序运行的时候才找的，这也是所谓动态绑定的含义：运行时才绑定这个函数名与其对应的实际代码。有些地方也称这种机制为迟绑定，晚绑定。）
但是对于C<span class="token operator">++</span>。为了保证程序的运行时效率，Ｃ<span class="token operator">++</span>的设计者认为凡是编译时能确定的事情，就不要拖到运行时再查找了。所以C<span class="token operator">++</span>的编译器看到这句话会这么干：
１：查找 pA 的类型，发现它有一个非虚的成员函数叫 test 。（编译器干的）
２：找到了，在这里生成一个函数调用，直接调<span class="token class-name">A</span><span class="token operator">::</span> <span class="token function">test</span> <span class="token punctuation">(</span> pA <span class="token punctuation">)</span>。
所以到了运行时，由于 <span class="token function">test</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>函数里面并没有任何需要解引用 pA 指针的代码，所以真实情况下也不会引发segment fault。这里对成员函数的解析，和查找其对应的代码的工作都是在编译阶段完成而非运行时完成的，这就是所谓的静态绑定，也叫早绑定。
正确理解C<span class="token operator">++</span>的静态绑定可以理解一些特殊情况下C<span class="token operator">++</span>的行为。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><h3 id="例题6-const对象"><a href="#例题6-const对象" class="header-anchor">#</a> 例题6-const对象</h3> <ul><li>题目来源和<a href="https://www.nowcoder.com/test/question/done?tid=44470458&qid=1318#summary" target="_blank" rel="noopener noreferrer">参考资料<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;bits/stdc++.h&gt;</span></span>
<span class="token keyword">using</span> <span class="token keyword">namespace</span> std<span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A::f() &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;A::f() const &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token operator">:</span> <span class="token base-clause"><span class="token keyword">public</span> <span class="token class-name">A</span></span>
<span class="token punctuation">{</span>
<span class="token keyword">public</span><span class="token operator">:</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f() &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
	<span class="token keyword">void</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span> cout <span class="token operator">&lt;&lt;</span> <span class="token string">&quot;B::f() const &quot;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">void</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">*</span>a<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	a<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	A <span class="token operator">*</span>p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token function">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
	p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//多态</span>
	<span class="token function">g</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//先转换为const指针，由于只能调用const函数，所以不是多态了</span>
	<span class="token keyword">delete</span> <span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//输出</span>
<span class="token comment">//B::f() A::f() const</span>
<span class="token comment">//输出前面是因为多态</span>
<span class="token comment">//输出后面是因为不是多态！！！（注意）</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><ul><li>解释原因</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>由于<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>在基类中声明为虚的，则p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>根据『对象类型』<span class="token punctuation">(</span>B<span class="token punctuation">)</span>调用<span class="token class-name">B</span><span class="token operator">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>，此时编译器对虚方法使用动态联编，输出<span class="token class-name">B</span><span class="token operator">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span>。
    
由于<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>在基类中未声明为虚的，故p<span class="token operator">-&gt;</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> 『根据指针类型』<span class="token punctuation">(</span>A<span class="token punctuation">)</span>调用<span class="token class-name">A</span><span class="token operator">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>，此时编译器对非虚方法使用静态联编，输出<span class="token class-name">A</span><span class="token operator">::</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span>。

</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h2 id="🐾四、『运算符重载』详解"><a href="#🐾四、『运算符重载』详解" class="header-anchor">#</a> 🐾四、『运算符重载』详解</h2> <blockquote><p>（本质还是函数重载）</p></blockquote> <h3 id="（1）重载的2种函数类型"><a href="#（1）重载的2种函数类型" class="header-anchor">#</a> （1）重载的2种函数类型</h3> <ul><li>1、成员函数</li> <li>2、友元函数『属于，非成员函数』</li></ul> <blockquote><p>易错：有的运算符，只能重载为『成员函数』</p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token operator">=</span> 			
<span class="token punctuation">[</span><span class="token punctuation">]</span>			<span class="token comment">//重载，下标运算符，比如重载后，返回当前vetor中的元素，需要this指针，而非成员函数是没有this指针的233</span>
<span class="token punctuation">(</span><span class="token punctuation">)</span>			<span class="token comment">//重载，函数调用运算符，</span>
<span class="token operator">-&gt;</span>
上面<span class="token number">4</span>个，『只能』通过成员函数进行重载
我的理解，备注如上
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h3 id="（2）可以重载，但建议不要重载的运算符"><a href="#（2）可以重载，但建议不要重载的运算符" class="header-anchor">#</a> （2）可以重载，但建议不要重载的运算符</h3> <ul><li><code>&amp;&amp;</code>和<code>||</code>很建议不要重载『会出点问题』</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token number">1</span>、因为，重载运算符，也就意味着靠函数重载来完成，操作数会作为『函数参数，传递』
<span class="token number">2</span>、C<span class="token operator">++</span>的『函数参数都会被求值，无法实现（短路规则）』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><h3 id="（3）不能重载的5个运算符记忆"><a href="#（3）不能重载的5个运算符记忆" class="header-anchor">#</a> （3）不能重载的5个运算符记忆</h3> <ul><li><p>百度招聘考过。</p></li> <li><p>1、第1个，也是我们常常忘记是运算符的<code>sizeof</code></p></li> <li><p>2、其他4个，记住只要挂<code>.</code>的运算符<strong>均不能被重载</strong></p></li></ul> <blockquote><p>第2点，参考自用户讨论：@<a href="https://www.nowcoder.com/profile/2887214" target="_blank" rel="noopener noreferrer">牛客2887214号<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>C<span class="token operator">++</span>不能重载的总共五个：
（<span class="token number">1</span>）<span class="token string">&quot;.&quot;</span>（类成员访问运算符） 
（<span class="token number">2</span>）<span class="token string">&quot; .*&quot;</span>（类成员指针访问运算符） 
（<span class="token number">3</span>）<span class="token string">&quot;::&quot;</span>（域运算符） 
（<span class="token number">4</span>）<span class="token string">&quot;siezof&quot;</span>（长度运算符） 
（<span class="token number">5</span>）<span class="token string">&quot; ?:&quot;</span>（条件运算符）
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><h2 id="♻️五、c-中对c的const关键字增强"><a href="#♻️五、c-中对c的const关键字增强" class="header-anchor">#</a> ♻️五、C++中对C的const关键字增强</h2> <p>date: 2020-05-31
summary: C++对C的const关键字增强的底层机制</p> <h3 id="（1）问题导入"><a href="#（1）问题导入" class="header-anchor">#</a> （1）问题导入</h3> <p>背景：
我们总说C语言中const修饰的变量看上去似乎是常量，其实是个“冒牌货”，应该叫”常变量”，比如用指针间接赋值，就能改变了。</p> <p>代码测试：
将指针间接修改变量值的代码放到C语言编译器和C++编译器去测试</p> <p>DevC++的C语言编译器</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token comment">//demo.c </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
	p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>结果：
<img src="/photos/2020.5.30_31/01.png" width="80%"></p> <p>DevC++的C++语言编译器</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//test.cpp </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
	p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span>
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;%d&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>结果：
<img src="/photos/2020.5.30_31/02.png" width="80%"></p> <p>奇特的结果：
我们要是写了这样的函数在银行程序中，要是用不同编译器，那么对账就对不上了。
总结：
C中的const是个常变量，变量的值能够被间接修改。
C++中的const是一个真正的常量！</p> <p>Tips：</p> <table><td bgcolor="#FFFF" FF>
以上两次测试，都没有显示warning和error</td></table> <p>那么，我们或许会疑惑：
Q：我们说C++中的是一个真正的常量，那为什么，没有C++编译器对我们”用指针间接修改”的行为，没有报warning或者error呢？
A：C++要兼容C，所以，它认为这个语法是可以的
Q：那么问题又来了，那他既然兼容，那么为什么最后却没改变那个变量的值呢？
A：因为C++只是兼容那种语法写法，但是底层的实现却对const关键字进行了加强。</p> <h3 id="（2）底层原理分析"><a href="#（2）底层原理分析" class="header-anchor">#</a> （2）底层原理分析</h3> <h4 id="_1、c-编译器对const做了一些加强，做了一些特殊的处理"><a href="#_1、c-编译器对const做了一些加强，做了一些特殊的处理" class="header-anchor">#</a> 1、C++编译器对const做了一些加强，做了一些特殊的处理</h4> <p>当C++编译器，扫描到常量声明时，它不再像C语言那样，把这个const给它单独分配内存。</p> <p>在我们先前的//test.cpp中。
C++进行了如下操作：</p> <blockquote><ul><li>1）扫描到这一行，const int a=98;
C++编译器会把这个<b>变量a</b>放在一个<b>符号表（键值-值对）</b>里面
<b>此时，并没有分配内存！！！</b>
注意：这样的话，key和value是定了，不能修改的了。
符号表具体的实现和我们的内存中的，栈，堆不是同一套实现机制。
有很多常量就都放在这个里面了。
Tips：
当你去<b>使用</b>这个a的时候，它就给你从符号表里面给你把这个98给拿出来，供你<b>使用</b></li></ul></blockquote> <table><td bgcolor="#FFFF" FF>
注意&quot;使用&quot;一词</td></table> <blockquote><ul><li>2）遇到类似这样的情况，此时才给a变量另外分配一个内存。
扫描到这一句p=(int <em>)&amp;a;
当你对这个a变量取地址的时候，C++编译器，会为这个a再<b>单独的开辟一块内存空间</b>，然后你把这个内存空间，赋给了p，相当于一个指针P指向了这里。然后你通过</em>p去间接的修改的地址，不再是原来的值（value）,而是我们新开辟的空间的值（注意理解）
所以，当你再使用a的时候，你打印的还是98（符号表中的a）
<img src="/photos/2020.5.30_31/03.png" width="90%"></li></ul></blockquote> <h4 id="_2、证明"><a href="#_2、证明" class="header-anchor">#</a> 2、证明</h4> <p>我们现在来证明这个开辟的内存空间的存在</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//solution.cpp </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> a<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>
	
	<span class="token keyword">int</span> <span class="token operator">*</span>p<span class="token operator">=</span><span class="token constant">NULL</span><span class="token punctuation">;</span>
	p<span class="token operator">=</span><span class="token punctuation">(</span><span class="token keyword">int</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>a<span class="token punctuation">;</span>
	<span class="token operator">*</span>p<span class="token operator">=</span><span class="token number">100</span><span class="token punctuation">;</span> 
	
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;a=%d\n&quot;</span><span class="token punctuation">,</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;*p=%d&quot;</span><span class="token punctuation">,</span><span class="token operator">*</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>打印的是:
<img src="/photos/2020.5.30_31/04.png" width="80%"></p> <p><b>注意：</b></p> <table><td bgcolor="#FFFF" FF>
C++编译器虽然可能为const常量分配空间，但不会<b>使用</b>其存储空间中的值，除非你用指针操作。</td></table> <h3 id="（3）结论和补充"><a href="#（3）结论和补充" class="header-anchor">#</a> （3）结论和补充</h3> <p>1）C语言中的const变量
C语言中const变量是只读变量，<b>有自己的存储空间</b>
2）C++中的const常量</p> <table><td bgcolor="#FFFF" FF>
注意：可能分配存储空间,也可能不分配存储空间!</td></table> <p>编译过程中若发现<b>使用常量</b>则直接以符号表中的值替换</p> <p>Tips：
只有下面两种的时候，它才会分配空间</p> <blockquote><ul><li>当const常量为全局，并且需要在其它文件中使用,即使用了<b>extern</b>操作符</li> <li>当使用&amp;操作符取const常量的地址，编译过程中若发现对const使用了<b>&amp;操作符</b>，则给对应的常量分配存储空间（兼容C）</li></ul></blockquote> <h3 id="（4）补充疑问"><a href="#（4）补充疑问" class="header-anchor">#</a> （4）补充疑问</h3> <p>Q：那么要是分配内存，C++中那个const的分配内存是在什么时候分配的呢？是在编译器<b>编译阶段</b>，还是在<b>执行阶段</b>分配？</p> <table><td bgcolor="#FFFF" FF>
Ａ：C++中const分配内存的时机，是在编译期间！（记住！）</td></table> <p>证明的代码：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token comment">//test.cpp </span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;cstdio&gt;</span></span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
	<span class="token keyword">int</span> a<span class="token punctuation">;</span>
	<span class="token keyword">const</span> <span class="token keyword">int</span> b<span class="token operator">=</span><span class="token number">98</span><span class="token punctuation">;</span>
	<span class="token keyword">int</span> c<span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;a=%d\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;b=%d\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//用了取地址 </span>
	<span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;&amp;c=%d\n&quot;</span><span class="token punctuation">,</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>
	
	<span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div> <img src="/photos/2020.5.30_31/05.png" width="80%"> <p>结果表明：
const int b的地址在a和c之间，符合我们局部变量申请内存的<b>压栈的顺序</b>，<b>它并没有因为，&amp;b这句话写到int c后面，就先分配a，c最后才b</b>，而是，它扫描完之后，看到这里有&amp;b了，就分配地址了。</p> <h3 id="（5）详解c-中const常见用途"><a href="#（5）详解c-中const常见用途" class="header-anchor">#</a> （5）详解C++中const常见用途</h3> <p>C++对C语言的const关键字进行了增强！
<font color="red" size="3">
特点：
C++中的const修饰的变量，变成了真正的常量，所以叫const常量</font></p> <blockquote><ul><li>区别：</li></ul> <blockquote><ul><li>1）C语言中的const变量
C语言中const变量是只读变量，<b>有自己的存储空间</b></li> <li>2）C++中的const常量
注意：<b>可能分配存储空间,也可能不分配存储空间!</b></li></ul></blockquote></blockquote> <p>Tips:要想了解C++中const实现机制，请移步《C++中对C的const关键字增强》一文</p> <h4 id="_1、const成员函数"><a href="#_1、const成员函数" class="header-anchor">#</a> 1、const成员函数</h4> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span> <span class="token function">GetLength</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">const</span> <span class="token punctuation">{</span><span class="token keyword">return</span> itslength<span class="token punctuation">;</span><span class="token punctuation">}</span>  <span class="token comment">//成员函数声明为常量</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>当成员函数被声明为const时，如果这个const成员函数试图修改这个对象的数据，编译器将视为错误。
因为：你都和我约定了不能修改，那就得履行。</p> <h4 id="_2、指向const对象的指针"><a href="#_2、指向const对象的指针" class="header-anchor">#</a> 2、指向const对象的指针</h4> <p>如果声明了一个<b>指向const对象</b>的指针，则通过该指针只能调用const方法（成员函数）。</p> <blockquote><p>-因为：const就是用来规定，<b>属于这个对象</b>的是不能有改变的</p> <blockquote><ul><li>const成员函数（常量成员函数），不会去修改这个对象任何<b>非静态成员变量</b>的值。</li> <li>static成员函数（静态成员函数），也不会去修改这个对象任何<b>非静态成员变量</b>(毕竟，静态成员函数和静态成员变量其实本质是全局变量嘛，不需要作用在具体的对象上，<b>我们写在类里面，只是为了彰显和这个类有紧密的关系</b>)</li> <li>因此，我们指向const对象的指针，能够调用的是const成员函数和static成员函数</li> <li>普通成员函数，内部可以实现修改非静态成员变量的语句，所以<b>可能会破坏const对象规定的，不能改变我的内部数据的原则</b>。</li></ul></blockquote></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>Rectangle<span class="token operator">*</span> pRect <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>
<span class="token keyword">const</span> Rectangle <span class="token operator">*</span> pConstRect <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>     <span class="token comment">//指向const对象</span>
Rectangle<span class="token operator">*</span> <span class="token keyword">const</span> pConstPtr <span class="token operator">=</span> <span class="token keyword">new</span> Rectangle<span class="token punctuation">;</span>
<span class="token comment">// pConstRect是指向const对象的指针，它只能使用声明为const的成员函数，如GetLength（）。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><h4 id="_3、const-修饰函数的返回值"><a href="#_3、const-修饰函数的返回值" class="header-anchor">#</a> 3、const 修饰函数的返回值</h4> <p>函数返回值采用“引用传递”的场合,出现在类的赋值函数中，目的是为了实现链式表达。
例如：</p> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">class</span> <span class="token class-name">A</span>
<span class="token punctuation">{</span>
A <span class="token operator">&amp;</span> operate <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">const</span> A <span class="token operator">&amp;</span>other<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 赋值函数</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
A a<span class="token punctuation">,</span> b<span class="token punctuation">,</span> c<span class="token punctuation">;</span> <span class="token comment">// a, b, c 为A 的对象</span>
a <span class="token operator">=</span> b <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 正常的链式赋值</span>
<span class="token punctuation">(</span>a <span class="token operator">=</span> b<span class="token punctuation">)</span> <span class="token operator">=</span> c<span class="token punctuation">;</span> <span class="token comment">// 不正常的链式赋值，但合法</span>
<span class="token comment">//如果将赋值函数的返回值加const 修饰，那么该返回值的内容不允许被改动。上例中，语句 a = b = c 仍然正确，但是语句 (a = b) = c 则是非法的。</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h4 id="_4、补充"><a href="#_4、补充" class="header-anchor">#</a> 4、补充</h4> <blockquote><ul><li>非const对象可以访问<b>任意的</b>成员函数,自然包括const成员函数,静态成员函数</li> <li>const对象的成员是不可修改的,然而const对象通过指针维护的对象却是可以修改的.</li> <li>const成员函数不可以修改对象的数据,不管对象是否具有const性质.它在编译时,以是否修改成员数据为依据,进行检查。</li> <li>然而加上mutable修饰符的数据成员,对于任何情况下通过任何手段都可修改,自然此时的const成员函数是可以修改它的</li></ul></blockquote> <p>补充杂项：</p> <blockquote><ul><li>const 修饰引用（&amp;）修饰输入参数的用法：</li></ul> <blockquote><ul><li>1-对于<b>非内部数据类型</b>的输入参数，应该将“<b>值传递</b>”的方式改为“<b>const 引用传递</b>”，目的是提高效率。例如将<code>void Func(A a)</code> 改为<code>void Func(const A &amp;a)</code>。当然，虽然这样的确能提高效率。但此时千万千万要小心，一定要搞清楚函数究竟是想返回一个对象的“拷贝”还是仅返回“别名”就可以了，否则程序会出错。</li> <li>2-对于<b>内部数据类型</b>的输入参数，不要将“值传递”的方式改为“const 引用传递”。否则既达不到提高效率的目的，又降低了函数的可理解性。例如<code>void Func(int x)</code> 不应该改为<code>void Func(const int &amp;x)</code>。（如何理解？？？）</li></ul></blockquote></blockquote> <blockquote><ul><li>const 修饰星号（*）用法：</li></ul> <blockquote><ul><li>如果给以“指针传递”方式的函数返回值加const 修饰，那么函数返回值（即指针）的内容不能被修改，该返回值只能被赋给加const 修饰的同类型指针。例如函数</li></ul></blockquote></blockquote> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
如下语句将出现编译错误：
<span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
正确的用法是
<span class="token keyword">const</span> <span class="token keyword">char</span> <span class="token operator">*</span>str <span class="token operator">=</span> <span class="token function">GetString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><h3 id="（6）const导致的函数重载"><a href="#（6）const导致的函数重载" class="header-anchor">#</a> （6）const导致的函数重载</h3> <p>1、C++不允许仅根据函数的返回类型重载函数名称；
2、可以编写两个名称相同，参数也相同的函数，其中一个是<strong>const</strong>，另一个不是。</p> <ul><li><strong>没用参数</strong>的两个函数是不能重载的.说法是不正确的，因为还有const</li></ul> <h2 id="♻️六、c-中『栈』和『堆』"><a href="#♻️六、c-中『栈』和『堆』" class="header-anchor">#</a> ♻️六、C++中『栈』和『堆』</h2> <ul><li>源代码的重要性+编译器底层理解的重要性！</li></ul> <blockquote><p>（1）如何定义1个『只能』在『堆』上生成对象的类？</p></blockquote> <ul><li>在C++中，为了让某个类只能通过new来创建（即如果直接创建对象，编译器将报错），应该（）</li> <li>将『析构函数』设为『私有』</li> <li>原因：C++是静态</li></ul> <blockquote><p>（2）如何定义1个『只能』在『栈』上生成对象的类？</p></blockquote> <ul><li>将new和delete重载为『私有』</li> <li>原因：在堆上生成对象，使用new关键字操作。看过源代码知道过程是2步！！</li> <li>1、使用operator new在『堆』上找可用的内存，分配给对象</li> <li>2、调用构造函数生成对象</li> <li>所以，如果将new操作设置为『私有』，那么第1阶段就不能完成。『就不能在堆上生成对象』</li></ul> <h2 id="♻️七、小知识"><a href="#♻️七、小知识" class="header-anchor">#</a> ♻️七、小知识</h2> <h3 id="常量表达式"><a href="#常量表达式" class="header-anchor">#</a> 常量表达式</h3> <ul><li>《<a href="https://www.nowcoder.com/test/question/done?tid=43575799&qid=67992" target="_blank" rel="noopener noreferrer">C++Primer<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>》</li></ul> <h3 id="switch语法"><a href="#switch语法" class="header-anchor">#</a> switch语法</h3> <ul><li><a href="https://www.nowcoder.com/questionTerminal/07016c63465442fe858a1f323eb3fa0e" target="_blank" rel="noopener noreferrer">switch(c)语句中，c不可以是什么类型（）<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span>
<span class="token keyword">long</span>
<span class="token keyword">char</span>
<span class="token keyword">float</span>
    
选D <span class="token keyword">float</span>
    
这个题目很好
<span class="token keyword">switch</span>相当于枚举，<span class="token keyword">int</span> <span class="token keyword">long</span> <span class="token keyword">char</span>这些整型都是又穷个数的
<span class="token keyword">float</span>有无穷多个，因此不能用<span class="token keyword">float</span>类型

『我在C<span class="token operator">++</span>primer上面也看到，只要整型和<span class="token keyword">enum</span>』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h3 id="（1）switch"><a href="#（1）switch" class="header-anchor">#</a> （1）switch</h3> <ul><li>switch语句判断条件可以接受的数据类型有哪些？</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code><span class="token keyword">int</span>
byte
<span class="token keyword">char</span>
<span class="token keyword">short</span>
都可以，但是byte不是C<span class="token operator">++</span>的。。。

此外，<span class="token keyword">enum</span>也不是构造类型，它是一个基本类型，
    我们可以将一个<span class="token keyword">enum</span>作为<span class="token keyword">switch</span>语句的表达式！！！『C<span class="token operator">++</span> primer』说的
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="（2）c-编译器好智能化"><a href="#（2）c-编译器好智能化" class="header-anchor">#</a> （2）C++编译器好智能化</h3> <ul><li>牛客<a href="https://www.nowcoder.com/test/question/done?tid=44174655&qid=305235#summary" target="_blank" rel="noopener noreferrer">例题<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></li> <li>但我决定可能不仅仅是这些，可能还要更多的，比如C++11引入</li></ul> <div class="language-cpp line-numbers-mode"><pre class="language-cpp"><code>如果你只是声明一个空类，不做任何事情的话
    编译器会自动为你生成：
    <span class="token number">1</span>、一个默认构造函数『构造函数』
    <span class="token number">2</span>、一个拷贝默认构造函数『拷贝构造函数』
    <span class="token number">3</span>、一个默认拷贝赋值操作符『拷贝赋值操作符函数』
    <span class="token number">4</span>、一个默认析构函数。『析构函数』
这些函数只有在第一次被调用时，才会别编译器创建。
    『『所有这些函数都是<span class="token keyword">inline</span>和<span class="token keyword">public</span>的。』』
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h3 id="树——常考题型之一"><a href="#树——常考题型之一" class="header-anchor">#</a> 树——常考题型之一</h3> <ul><li><a href="https://www.nowcoder.com/questionTerminal/cafc86b72f2c42b8aacb47178b045026" target="_blank" rel="noopener noreferrer">完全二叉树<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>共有700结点，该二叉树有多少个叶子结点？</li></ul> <h2 id="🍉笔试—编程系列"><a href="#🍉笔试—编程系列" class="header-anchor">#</a> 🍉笔试—编程系列</h2> <ul><li>环形链表的约瑟夫问题</li></ul> <p>这题的数学解法，还是剑指offer上的写的比《具体数学》上面的好</p> <h2 id="💾-c-98关键字"><a href="#💾-c-98关键字" class="header-anchor">#</a> 💾 C++98关键字</h2> <ul><li><p>1、<code>static</code></p> <ul><li>修改变量或函数存储的形式，比如<code>.data</code>，<code>.bss</code></li></ul></li> <li><p>查了一下，『『C#和Java中有静态类』』，『C++中没有静态类』</p> <ul><li>参考：牛客网：<a href="https://www.nowcoder.com/test/question/done?tid=44308658&qid=14302#summary" target="_blank" rel="noopener noreferrer">关于static用途说法正确的是<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>？</li></ul></li> <li><p>2、<code>const</code></p> <ul><li>修改变量or函数的只读方式</li></ul></li> <li><p>3、<code>inline</code></p> <ul><li>建议在“编译期”，直接将整个函数的代码插入调用语句处</li></ul></li> <li><p>4、<code>friend</code></p> <ul><li>声明友元，包括，友元函数，友元类</li></ul></li></ul> <h2 id="✅访问属性"><a href="#✅访问属性" class="header-anchor">#</a> ✅访问属性</h2> <h3 id="内部访问和对象访问"><a href="#内部访问和对象访问" class="header-anchor">#</a> 内部访问和对象访问</h3> <ul><li>类的成员有三种访问属性，分别是public、protected、private，<a href="https://www.nowcoder.com/test/question/done?tid=44308742&qid=1618#summary" target="_blank" rel="noopener noreferrer">子类能够访问的成员<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>是</li></ul> <blockquote><p>参考牛客的答案：</p></blockquote> <img src="/assets/img/访问权限.ce788b0d.png"></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.b0d3f774.js" defer></script><script src="/assets/js/3.15e8b4af.js" defer></script>
  </body>
</html>

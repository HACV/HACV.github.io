(window.webpackJsonp=window.webpackJsonp||[]).push([[126],{291:function(a,t,e){"use strict";e.r(t);var v=e(0),r=Object(v.a)({},(function(){var a=this.$createElement;this._self._c;return this._m(0)}),[function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("div",{staticClass:"content"},[e("h2",{attrs:{id:"c-11月08号"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#c-11月08号"}},[a._v("#")]),a._v(" C++11月08号")]),a._v(" "),e("h3",{attrs:{id:"一、c-中"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#一、c-中"}},[a._v("#")]),a._v(" 一、C++中")]),a._v(" "),e("ul",[e("li",[a._v("纯虚函数：只提供一个接口，具体实现方法需要派生类自己去实现")]),a._v(" "),e("li",[a._v("纯虚函数不可以有实现")]),a._v(" "),e("li",[a._v("含有纯虚函数的类叫抽象类C++中")]),a._v(" "),e("li",[a._v("非虚函数：提供接口，强制实现方法")])]),a._v(" "),e("h3",{attrs:{id:"二、函数重载"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#二、函数重载"}},[a._v("#")]),a._v(" 二、函数重载")]),a._v(" "),e("p",[a._v("1、C++不允许仅根据函数的返回类型重载函数名称；\n2、可以编写两个名称相同，参数也相同的函数，其中一个是"),e("strong",[a._v("const")]),a._v("，另一个不是。")]),a._v(" "),e("ul",[e("li",[a._v("没用参数的两个函数是不能重载的.说法是不正确的，因为还有const")])]),a._v(" "),e("h3",{attrs:{id:"三、访问private"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#三、访问private"}},[a._v("#")]),a._v(" 三、访问private")]),a._v(" "),e("p",[a._v("类中的数据域使用private修饰为私有变量\n反射也可以访问\n什么是反射访问？？？")]),a._v(" "),e("ul",[e("li",[a._v("通过类的层面，来取得类中方法")])]),a._v(" "),e("h3",{attrs:{id:"对c-中重载（overload）和重写（override）描述正确的有（）"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#对c-中重载（overload）和重写（override）描述正确的有（）"}},[a._v("#")]),a._v(" 对C++中重载（overload）和重写（override）描述正确的有（）")]),a._v(" "),e("h3",{attrs:{id:"虚成员函数不可能是static-成员函数"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#虚成员函数不可能是static-成员函数"}},[a._v("#")]),a._v(" 虚成员函数不可能是static 成员函数")]),a._v(" "),e("h3",{attrs:{id:"内存泄漏是不仅仅出现在c-c-程序的问题，java程序也会内存泄漏"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#内存泄漏是不仅仅出现在c-c-程序的问题，java程序也会内存泄漏"}},[a._v("#")]),a._v(" 内存泄漏是不仅仅出现在C/C++程序的问题，Java程序也会内存泄漏")]),a._v(" "),e("ul",[e("li",[a._v("E：java是自动管理内存的，但是也会有内存泄露，比如加入HashMap的对象hash值改变了就无法从HashMap中remove，这就造成了内存泄露")])]),a._v(" "),e("h3",{attrs:{id:"析构时-区别-delete-和-delete"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#析构时-区别-delete-和-delete"}},[a._v("#")]),a._v(" 析构时 区别 delete 和 delete[]")]),a._v(" "),e("h3",{attrs:{id:"友元"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#友元"}},[a._v("#")]),a._v(" 友元")]),a._v(" "),e("p",[a._v("友元函数是不能被继承的\n友元函数没有this指针\n友元只是破坏了类的隐藏性和封装性，可以直接调用，不需要通过对象或者指针")]),a._v(" "),e("ul",[e("li",[e("p",[a._v("一个基类的声明中有纯虚函数，该基类派生类一定不再是抽象类（错误）")])]),a._v(" "),e("li",[e("p",[a._v("如果在派生类中没有对所有纯虚函数进行定义，则此派生类仍然是抽象类，不能用来定义对象。所以A错.")])]),a._v(" "),e("li",[e("p",[a._v("构造函数不能被覆盖")])])])])}],!1,null,null,null);t.default=r.exports}}]);
(window.webpackJsonp=window.webpackJsonp||[]).push([[17],{182:function(v,_,t){"use strict";t.r(_);var a=t(0),n=Object(a.a)({},(function(){var v=this.$createElement;this._self._c;return this._m(0)}),[function(){var v=this,_=v.$createElement,t=v._self._c||_;return t("div",{staticClass:"content"},[t("h1",{attrs:{id:"ccf：第4题套路"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#ccf：第4题套路"}},[v._v("#")]),v._v(" CCF：第4题套路")]),v._v(" "),t("h2",{attrs:{id:"_4-题图论。"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_4-题图论。"}},[v._v("#")]),v._v(" 4.题图论。")]),v._v(" "),t("p",[v._v("思路：")]),v._v(" "),t("p",[v._v("（1）审题，理清题意，选好存储结构，一般图论题用多维vector数组配合结构体存储。")]),v._v(" "),t("p",[v._v("（2）想清楚题目的考点，一般的考点有：")]),v._v(" "),t("p",[v._v("最小生成树、迪杰斯特拉算符，并查集，DFS，BFS暴力搜图等。理清考点后，才比较容易下手。")]),v._v(" "),t("p",[v._v("（3）注意多维数组的使用，一维不行用二维，二维不行用三维，特别是涉及到的元素比较多的时候，思路应该多往这边靠。")]),v._v(" "),t("h2",{attrs:{id:"知识点讲解"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#知识点讲解"}},[v._v("#")]),v._v(" 知识点讲解")]),v._v(" "),t("p",[v._v("最小生产树：\n最小生成树可以用kruskal（克鲁斯卡尔）算法或prim（普里姆）算法求出。\n在一给定的无向图G = (V, E) 中，(u, v) 代表连接顶点 u 与顶点 v 的边（即），而 w(u, v) 代表此边的权重，若存在 T 为 E 的子集（即）且为无循环图，使得\n的 w(T) 最小，则此 T 为 G 的最小生成树。")]),v._v(" "),t("p",[v._v("最小生成树其实是最小权重生成树的简称。\nKruskal算法简述\n假设 WN=(V,{E}) 是一个含有 n 个顶点的连通网，则按照克鲁斯卡尔算法构造最小生成树的过程为：先构造一个只含 n 个顶点，而边集为空的子图，若将该子图中各个顶点看成是各棵树上的根结点，则它是一个含有 n 棵树的一个森林。之后，从网的边集 E 中选取一条权值最小的边，若该条边的两个顶点分属不同的树，则将其加入子图，也就是说，将这两个顶点分别所在的两棵树合成一棵树；反之，若该条边的两个顶点已落在同一棵树上，则不可取，而应该取下一条权值最小的边再试之。依次类推，直至森林中只有一棵树，也即子图中含有 n-1条边为止。 [1]\nPrime算法简介：")]),v._v(" "),t("p",[v._v("最小生成树和最短路径一样，都是在实际中非常常见的图算法问题。")]),v._v(" "),t("p",[v._v("同样也有专门的算法来构造图的最小生成树。")]),v._v(" "),t("p",[v._v("Prime算法是求解最小生成树问题最常用的算法，思想和上次讲解的 最短路径Dijkstra算法 有些接近。")]),v._v(" "),t("p",[v._v("1 把所有节点分成两类，一类是已经加入到了 当前的生成树中（集合 Y） ，一类是还没有加入当前的生成树中（集合N）。")]),v._v(" "),t("p",[v._v("PS: 显然，这种分类可以用flag来设置。")]),v._v(" "),t("p",[v._v("2 最终的生成树是一步一步构造的，所以说是 “当前的”生成树。")]),v._v(" "),t("p",[v._v("从 Y 中取得一个节点 Vy, 从 N 中取得一个节点 Vn. 使其满足 Vy和Vn之间边的权值最小。")]),v._v(" "),t("p",[v._v("3、 找到满足上述条件的节点后，把Vn结点从 N 移入 Y中。")]),v._v(" "),t("p",[v._v("Ps： 具体代码实现是，flag值修改即可。 （最原始的做法，后续会有改进方式）")]),v._v(" "),t("p",[v._v("重复上述 2. 3. 两步，直到所有节点全部加入Y中。")])])}],!1,null,null,null);_.default=n.exports}}]);
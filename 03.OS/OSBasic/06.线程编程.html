<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>线程编程 | HACV</title>
    <meta name="description" content="Personal Blog Website">
    <link rel="icon" href="/images/photo.jpg">
  <link rel="manifest" href="/images/photo.jpg">
  <link rel="apple-touch-icon" href="/images/photo.jpg">
  <meta http-quiv="pragma" cotent="no-cache">
  <meta http-quiv="pragma" cotent="no-cache,must-revalidate">
  <meta http-quiv="expires" cotent="0">
    
    <link rel="preload" href="/assets/css/0.styles.8eb0d87d.css" as="style"><link rel="preload" href="/assets/js/app.c10be5f5.js" as="script"><link rel="preload" href="/assets/js/54.6f595df2.js" as="script"><link rel="prefetch" href="/assets/js/10.8bbeb718.js"><link rel="prefetch" href="/assets/js/100.ee7a4c46.js"><link rel="prefetch" href="/assets/js/101.42a286e0.js"><link rel="prefetch" href="/assets/js/102.7f9859de.js"><link rel="prefetch" href="/assets/js/103.298b9272.js"><link rel="prefetch" href="/assets/js/104.78fa45f8.js"><link rel="prefetch" href="/assets/js/105.251d6fbc.js"><link rel="prefetch" href="/assets/js/106.3bc5425b.js"><link rel="prefetch" href="/assets/js/107.22d066f5.js"><link rel="prefetch" href="/assets/js/108.b6a81045.js"><link rel="prefetch" href="/assets/js/109.2cd373a7.js"><link rel="prefetch" href="/assets/js/11.390e9c09.js"><link rel="prefetch" href="/assets/js/110.6b58e579.js"><link rel="prefetch" href="/assets/js/111.1122d15d.js"><link rel="prefetch" href="/assets/js/112.72b4df6d.js"><link rel="prefetch" href="/assets/js/113.bdcdb1ed.js"><link rel="prefetch" href="/assets/js/114.d687fa49.js"><link rel="prefetch" href="/assets/js/115.6cf5d742.js"><link rel="prefetch" href="/assets/js/116.b1535253.js"><link rel="prefetch" href="/assets/js/117.3fcd2638.js"><link rel="prefetch" href="/assets/js/118.db1ca4b5.js"><link rel="prefetch" href="/assets/js/119.c454f58a.js"><link rel="prefetch" href="/assets/js/12.47752e11.js"><link rel="prefetch" href="/assets/js/120.30eb7327.js"><link rel="prefetch" href="/assets/js/121.d51eea05.js"><link rel="prefetch" href="/assets/js/122.ca886807.js"><link rel="prefetch" href="/assets/js/123.697a4ac0.js"><link rel="prefetch" href="/assets/js/124.52bc65ad.js"><link rel="prefetch" href="/assets/js/125.4a6317fa.js"><link rel="prefetch" href="/assets/js/126.63241c6a.js"><link rel="prefetch" href="/assets/js/127.3a30ef80.js"><link rel="prefetch" href="/assets/js/128.a43fa6f0.js"><link rel="prefetch" href="/assets/js/129.168fa034.js"><link rel="prefetch" href="/assets/js/13.9ab56618.js"><link rel="prefetch" href="/assets/js/130.4589bf48.js"><link rel="prefetch" href="/assets/js/131.c1884fad.js"><link rel="prefetch" href="/assets/js/132.0d2b7cb4.js"><link rel="prefetch" href="/assets/js/133.618ee210.js"><link rel="prefetch" href="/assets/js/134.63f25538.js"><link rel="prefetch" href="/assets/js/135.0d97304f.js"><link rel="prefetch" href="/assets/js/136.3b0b8612.js"><link rel="prefetch" href="/assets/js/137.b7766757.js"><link rel="prefetch" href="/assets/js/138.1904a273.js"><link rel="prefetch" href="/assets/js/139.d6099530.js"><link rel="prefetch" href="/assets/js/14.62a5eff5.js"><link rel="prefetch" href="/assets/js/140.ccc635b6.js"><link rel="prefetch" href="/assets/js/141.a78d121e.js"><link rel="prefetch" href="/assets/js/142.6a2673a5.js"><link rel="prefetch" href="/assets/js/143.22db839b.js"><link rel="prefetch" href="/assets/js/144.f675638d.js"><link rel="prefetch" href="/assets/js/145.a1880528.js"><link rel="prefetch" href="/assets/js/146.354b06cd.js"><link rel="prefetch" href="/assets/js/147.83a109af.js"><link rel="prefetch" href="/assets/js/148.01c0ba2f.js"><link rel="prefetch" href="/assets/js/149.3585c1da.js"><link rel="prefetch" href="/assets/js/15.7d2d48ae.js"><link rel="prefetch" href="/assets/js/150.2613cc4c.js"><link rel="prefetch" href="/assets/js/151.c958e8d6.js"><link rel="prefetch" href="/assets/js/152.315024ad.js"><link rel="prefetch" href="/assets/js/153.e24034f9.js"><link rel="prefetch" href="/assets/js/16.8786bc8f.js"><link rel="prefetch" href="/assets/js/17.5312e725.js"><link rel="prefetch" href="/assets/js/18.0627885a.js"><link rel="prefetch" href="/assets/js/19.110980f3.js"><link rel="prefetch" href="/assets/js/2.858e80da.js"><link rel="prefetch" href="/assets/js/20.fada5d94.js"><link rel="prefetch" href="/assets/js/21.fef9831b.js"><link rel="prefetch" href="/assets/js/22.312e3a38.js"><link rel="prefetch" href="/assets/js/23.33f46c53.js"><link rel="prefetch" href="/assets/js/24.00a66de9.js"><link rel="prefetch" href="/assets/js/25.2f188985.js"><link rel="prefetch" href="/assets/js/26.68654ac5.js"><link rel="prefetch" href="/assets/js/27.6cab9932.js"><link rel="prefetch" href="/assets/js/28.754b96e8.js"><link rel="prefetch" href="/assets/js/29.d1ed41d5.js"><link rel="prefetch" href="/assets/js/3.53ecd128.js"><link rel="prefetch" href="/assets/js/30.056a1a2e.js"><link rel="prefetch" href="/assets/js/31.274d0f03.js"><link rel="prefetch" href="/assets/js/32.d1ec2cf6.js"><link rel="prefetch" href="/assets/js/33.80d80fee.js"><link rel="prefetch" href="/assets/js/34.e1287e62.js"><link rel="prefetch" href="/assets/js/35.047e41da.js"><link rel="prefetch" href="/assets/js/36.dc87e012.js"><link rel="prefetch" href="/assets/js/37.9be237bc.js"><link rel="prefetch" href="/assets/js/38.a2ed656e.js"><link rel="prefetch" href="/assets/js/39.c6893003.js"><link rel="prefetch" href="/assets/js/4.ba718c7b.js"><link rel="prefetch" href="/assets/js/40.a70e21bb.js"><link rel="prefetch" href="/assets/js/41.95871ed4.js"><link rel="prefetch" href="/assets/js/42.2252d8af.js"><link rel="prefetch" href="/assets/js/43.081ffb45.js"><link rel="prefetch" href="/assets/js/44.a6b3c3cf.js"><link rel="prefetch" href="/assets/js/45.a3ce1167.js"><link rel="prefetch" href="/assets/js/46.befd8516.js"><link rel="prefetch" href="/assets/js/47.d0e55fa3.js"><link rel="prefetch" href="/assets/js/48.170cc5e4.js"><link rel="prefetch" href="/assets/js/49.dd11397f.js"><link rel="prefetch" href="/assets/js/5.4ebbb385.js"><link rel="prefetch" href="/assets/js/50.47bf653e.js"><link rel="prefetch" href="/assets/js/51.34a93758.js"><link rel="prefetch" href="/assets/js/52.431fc761.js"><link rel="prefetch" href="/assets/js/53.ef149a01.js"><link rel="prefetch" href="/assets/js/55.87cc1312.js"><link rel="prefetch" href="/assets/js/56.3d05bdcc.js"><link rel="prefetch" href="/assets/js/57.caa5f93a.js"><link rel="prefetch" href="/assets/js/58.81155e36.js"><link rel="prefetch" href="/assets/js/59.e08a57ff.js"><link rel="prefetch" href="/assets/js/6.0bff5906.js"><link rel="prefetch" href="/assets/js/60.fb48eb65.js"><link rel="prefetch" href="/assets/js/61.b96b4857.js"><link rel="prefetch" href="/assets/js/62.95df7c0f.js"><link rel="prefetch" href="/assets/js/63.c0e8f45a.js"><link rel="prefetch" href="/assets/js/64.123f6205.js"><link rel="prefetch" href="/assets/js/65.4f0b9c3f.js"><link rel="prefetch" href="/assets/js/66.5b421a1d.js"><link rel="prefetch" href="/assets/js/67.75c9f4f8.js"><link rel="prefetch" href="/assets/js/68.7ec0c505.js"><link rel="prefetch" href="/assets/js/69.56cdd1c7.js"><link rel="prefetch" href="/assets/js/7.38fc841b.js"><link rel="prefetch" href="/assets/js/70.51c8d23a.js"><link rel="prefetch" href="/assets/js/71.19f5c32c.js"><link rel="prefetch" href="/assets/js/72.03a9f5e4.js"><link rel="prefetch" href="/assets/js/73.9b88f44b.js"><link rel="prefetch" href="/assets/js/74.daa81746.js"><link rel="prefetch" href="/assets/js/75.8cc9672d.js"><link rel="prefetch" href="/assets/js/76.43d2e38b.js"><link rel="prefetch" href="/assets/js/77.f3af5f07.js"><link rel="prefetch" href="/assets/js/78.8d5cfeca.js"><link rel="prefetch" href="/assets/js/79.24cdce5c.js"><link rel="prefetch" href="/assets/js/8.f1e98a93.js"><link rel="prefetch" href="/assets/js/80.2ad1db1b.js"><link rel="prefetch" href="/assets/js/81.f1725f8c.js"><link rel="prefetch" href="/assets/js/82.dff2af03.js"><link rel="prefetch" href="/assets/js/83.99b7a775.js"><link rel="prefetch" href="/assets/js/84.dbec8ce7.js"><link rel="prefetch" href="/assets/js/85.6509c1de.js"><link rel="prefetch" href="/assets/js/86.f07b0ca0.js"><link rel="prefetch" href="/assets/js/87.44796890.js"><link rel="prefetch" href="/assets/js/88.4a11e112.js"><link rel="prefetch" href="/assets/js/89.adbf18c5.js"><link rel="prefetch" href="/assets/js/9.76534e6a.js"><link rel="prefetch" href="/assets/js/90.c7ea7ca7.js"><link rel="prefetch" href="/assets/js/91.0dc967ad.js"><link rel="prefetch" href="/assets/js/92.e48daf13.js"><link rel="prefetch" href="/assets/js/93.da65bd6d.js"><link rel="prefetch" href="/assets/js/94.92d9f38e.js"><link rel="prefetch" href="/assets/js/95.3756691a.js"><link rel="prefetch" href="/assets/js/96.31621153.js"><link rel="prefetch" href="/assets/js/97.d8b77542.js"><link rel="prefetch" href="/assets/js/98.52c296d9.js"><link rel="prefetch" href="/assets/js/99.6d470e1a.js">
    <link rel="stylesheet" href="/assets/css/0.styles.8eb0d87d.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/" class="home-link router-link-active"><!----> <span class="site-name">HACV</span></a> <div class="links" style="max-width:nullpx;"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link router-link-active">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">🐉计算机内功</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <div class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/02.DataStructureAndAlgorithm/" class="nav-link">🐾数据结构和算法</a></div><div class="nav-item"><a href="/03.OS/" class="nav-link router-link-active">💻操作系统</a></div><div class="nav-item"><a href="/04.Net/" class="nav-link">☁️网络</a></div><div class="nav-item"><a href="/05.SE/" class="nav-link">☕️软件工程</a></div><div class="nav-item"><a href="/06.SQL/" class="nav-link">💾数据库</a></div><div class="nav-item"><a href="/07.InternalSkill/" class="nav-link">🐉计算机内功</a></div><div class="nav-item"><a href="/08.Tools/" class="nav-link">🔧Tools</a></div><div class="nav-item"><a href="/09.Language/" class="nav-link">⚛️C/C++</a></div><div class="nav-item"><a href="https://github.com/HACV" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></div> <!----></nav>  <ul class="sidebar-links"><li><div class="sidebar-group first"><p class="sidebar-heading open"><span>线程编程</span> <!----></p> <ul class="sidebar-group-items"><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#一、准备工作" class="sidebar-link">一、准备工作</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#（1）debian系" class="sidebar-link">（1）Debian系</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#（2）redhat系" class="sidebar-link">（2）Redhat系</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#二、概述" class="sidebar-link">二、概述</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#三、线程基础" class="sidebar-link">三、线程基础</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#四、linux下线程的『实现原理』" class="sidebar-link">四、Linux下线程的『实现原理』</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_1）三级页表" class="sidebar-link">1）三级页表</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_2）线程优点和缺点" class="sidebar-link">2）线程优点和缺点</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#三、线程控制原语" class="sidebar-link">三、线程控制原语</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_1）pthread-self函数（获得线程id）" class="sidebar-link">1）pthread_self函数（获得线程ID）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_2）pthread-create函数（创建线程）" class="sidebar-link">2）pthread_create函数（创建线程）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_3）pthread-exit函数（退出线程）" class="sidebar-link">3）pthread_exit函数（退出线程）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_4）pthread-join函数（用于，线程回收）" class="sidebar-link">4）pthread_join函数（用于，线程回收）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_5）pthread-detach函数（线程分离）" class="sidebar-link">5）pthread_detach函数（线程分离）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_6）pthread-cancel函数（杀死线程）" class="sidebar-link">6）pthread_cancel函数（杀死线程）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_7）pthread-equal函数（判断进程id相等）" class="sidebar-link">7）pthread_equal函数（判断进程ID相等）</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#控制原语对比" class="sidebar-link">控制原语对比</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#四、线程属性" class="sidebar-link">四、线程属性</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#五、线程库版本（nptl实现机制-posix-，native-posix-thread-library）" class="sidebar-link">五、线程库版本（NPTL实现机制(POSIX)，Native POSIX Thread Library）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#内容" class="sidebar-link">内容</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#进程间同步的几种方法" class="sidebar-link">进程间同步的几种方法</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#哲学家吃饭问题：" class="sidebar-link">哲学家吃饭问题：</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#一、同步的概念" class="sidebar-link">一、同步的概念</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#二、互斥量mutex（互斥锁）" class="sidebar-link">二、互斥量mutex（互斥锁）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_1）pthread-mutex-init函数" class="sidebar-link">1）pthreadmutexinit函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_2）pthread-mutex-destroy函数" class="sidebar-link">2）pthreadmutexdestroy函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_3）pthread-mutex-lock函数" class="sidebar-link">3）pthreadmutexlock函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_4）pthread-mutex-trylock函数" class="sidebar-link">4）pthreadmutextrylock函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_5）pthread-mutex-unlock函数" class="sidebar-link">5）pthreadmutexunlock函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#以上所有函数，要用的数据类型" class="sidebar-link">以上所有函数，要用的数据类型</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#先置结论-死锁" class="sidebar-link">先置结论+死锁</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#三、读写锁" class="sidebar-link">三、读写锁</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#读写锁状态：" class="sidebar-link">读写锁状态：</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#读写锁特性：" class="sidebar-link">读写锁特性：</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_1）pthread-rwlock-init函数" class="sidebar-link">1）pthreadrwlockinit函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_2）pthread-rwlock-destroy函数" class="sidebar-link">2）pthreadrwlockdestroy函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_3）pthread-rwlock-rdlock函数" class="sidebar-link">3）pthreadrwlockrdlock函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_4）pthread-rwlock-wrlock函数" class="sidebar-link">4）pthreadrwlockwrlock函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_5）pthread-rwlock-tryrdlock函数" class="sidebar-link">5）pthreadrwlocktryrdlock函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_6）pthread-rwlock-trywrlock函数" class="sidebar-link">6）pthreadrwlocktrywrlock函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_7）pthread-rwlock-unlock函数" class="sidebar-link">7）pthreadrwlockunlock函数</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#四、条件变量（条件变量本身不是锁！）" class="sidebar-link">四、条件变量（条件变量本身不是锁！）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_1）pthread-cond-init函数" class="sidebar-link">1）pthreadcondinit函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_2）pthread-cond-destroy函数" class="sidebar-link">2）pthreadconddestroy函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_3）pthread-cond-wait函数（难点）" class="sidebar-link">3）pthreadcondwait函数（难点）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_4）pthread-cond-timedwait函数" class="sidebar-link">4）pthreadcondtimedwait函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_5）pthread-cond-signal函数" class="sidebar-link">5）pthreadcondsignal函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_6）pthread-cond-broadcast函数" class="sidebar-link">6）pthreadcondbroadcast函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#线程同步—“生产者消费者”条件变量模型" class="sidebar-link">线程同步—“生产者消费者”条件变量模型</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#总结" class="sidebar-link">总结</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#条件变量的优点：（为什么我们要引入这么多种锁的机制？？）" class="sidebar-link">条件变量的优点：（为什么我们要引入这么多种锁的机制？？）</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#五、信号量" class="sidebar-link">五、信号量</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_1）sem-init函数" class="sidebar-link">1）sem_init函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_2）sem-destroy函数" class="sidebar-link">2）sem_destroy函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_3）sem-wait函数（相当于加锁，表示-）" class="sidebar-link">3）sem_wait函数（相当于加锁，表示--）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_4）sem-trywait函数" class="sidebar-link">4）sem_trywait函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_5）sem-timedwait函数" class="sidebar-link">5）sem_timedwait函数</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_6）sem-post函数（相当于解锁，表示-）" class="sidebar-link">6）sem_post函数（相当于解锁，表示++）</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#“生产者消费者”-信号量（注意，比较条件变量下的模型）" class="sidebar-link">“生产者消费者”-信号量（注意，比较条件变量下的模型）</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#六、进程间同步" class="sidebar-link">六、进程间同步</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#互斥量" class="sidebar-link">互斥量</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#文件锁（借助fcntl函数来实现锁机制）" class="sidebar-link">文件锁（借助fcntl函数来实现锁机制）</a></li></ul></li><li><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#哲学家用餐模型" class="sidebar-link">哲学家用餐模型</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_1）多线程版" class="sidebar-link">1）多线程版</a></li><li class="sidebar-sub-header"><a href="/03.OS/OSBasic/06.%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B.html#_2）多进程版" class="sidebar-link">2）多进程版</a></li></ul></li></ul></div></li></ul> </div> <div class="page"> <div class="content"><h1 id="线程编程"><a href="#线程编程" class="header-anchor">#</a> 线程编程</h1> <p>date: 2020-07-21</p> <h2 id="一、准备工作"><a href="#一、准备工作" class="header-anchor">#</a> 一、准备工作</h2> <p>安装pthread的man pages</p> <h3 id="（1）debian系"><a href="#（1）debian系" class="header-anchor">#</a> （1）Debian系</h3> <p>命令：<code>sudo apt-get install manpages-posix-dev</code></p> <h3 id="（2）redhat系"><a href="#（2）redhat系" class="header-anchor">#</a> （2）Redhat系</h3> <p>安装pthread的man pages：<code>yum -y install man-pages</code></p> <p>安装完成，使用<code>man -k pthread</code>如能看到线程函数列表则表明安装成功。</p> <p>系统要是不带，比如，我的阿里云CentOS</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>[省略]# man -k pthread
pthread: nothing appropriate.
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>安装</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>[省略]# yum -y install man-pages
CentOS-8 - AppStream                                                                                                              627 kB/s | 4.3 kB     00:00    
CentOS-8 - Base                                                                                                                   608 kB/s | 3.9 kB     00:00    
CentOS-8 - Extras                                                                                                                 257 kB/s | 1.5 kB     00:00    
Extra Packages for Enterprise Linux 8 - x86_64                                                                                    806 kB/s | 4.7 kB     00:00    
Package man-pages-4.15-6.el8.x86_64 is already installed.
Dependencies resolved.
Nothing to do.
Complete!
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>但是，<code>man -k pthread</code>还是没有
如何解决？？</p> <p>我进行yum源更新</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>yum update
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>然后，就可以了。</p> <p>效果如下：</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>[省略~]# man -k pthread
pthread.h (0p)       - threads
pthread_atfork (3)   - register fork handlers
pthread_atfork (3p)  - register fork handlers
pthread_attr_destroy (3) - initialize and destroy thread attributes object
pthread_attr_destroy (3p) - destroy and initialize the thread attributes object
pthread_attr_getaffinity_np (3) - set/get CPU affinity attribute in thread 
省略
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="二、概述"><a href="#二、概述" class="header-anchor">#</a> 二、概述</h2> <blockquote><ul><li>1.线程概念
线程与进程关系。
线程之间共享、非共享
优缺点</li> <li>2.线程控制原语（对线程进行控制的时候，所要使用到的函数,几乎能和线程控制原语能一一对应起来）
pthread_self
create
exit
join
对比记忆
|进程|线程|
|---|---|
|fork		|pthead_create|
|exit(10)	|pthead_exit(void *);|
|wait(int *)	|pthread_join（， void **）   阻塞     分离 22 ； cancel -1|
|kill()		|pthread_cancel();	取消点(检查点)：系统调用|
man 7 pthreads
pthread_testcancel(); 系统调用
getpid()	pthread_self();
pthread_detach();  分离。 --自动清理pcb。</li> <li><ol start="3"><li>线程属性（扩展知识，特殊应用）
修改线程属性的方法</li></ol></li> <li><ol start="4"><li>注意的事项</li></ol></li></ul></blockquote> <p>要求，能够完成，线程和进程控制原语进行对比记忆！！！！</p> <h2 id="三、线程基础"><a href="#三、线程基础" class="header-anchor">#</a> 三、线程基础</h2> <p>什么是线程？
Linux下的线程实现和Windows下的实现是完全不一样的原理。
（详见，我的另一篇博客）</p> <blockquote><ul><li>Linux下，线程是依托于进程来实现的！
类Unix系统中，早期是没有“线程”概念的，80年代才引入，借助进程机制实现出了线程的概念。因此在这类系统中，进程和线程关系密切。</li> <li>出来是因为，其他操作系统中提出了线程这个概念，Unix为了不落后。</li></ul></blockquote> <p>其实，类Unix里面，进程设计这种理念实际上比较完善了。
没有很大的缺点。（所以，硬生生，把进程那啥，变成线程。。。变化过来的）
而进程在Windows操作系统下，几乎没法用。系统能力不是一般的低。
因此，Windows下线程是非常常见的，进程反而很少去提到。</p> <p>Linux下，用线程和进程差别不是特别大（但是有差别），看个人习惯和爱好</p> <p>Linux下线程：LWP：light weight process 轻量级的进程，本质仍是进程(在Linux环境下)</p> <p>Linux下的进程和线程对比</p> <table><thead><tr><th>进程</th> <th>线程</th></tr></thead> <tbody><tr><td>（独居）独立地址空间，拥有PCB</td> <td>（一块住，合租）也有PCB，但没有独立的地址空间(共享)</td></tr> <tr><td>最小<strong>分配资源</strong>单位，可看成是只有一个线程的进程</td> <td>最小的<strong>执行</strong>单位</td></tr></tbody></table> <blockquote><ul><li>Q:为什么多线程下载更快？？
A：由于线程是最小的<strong>执行</strong>单位，所以，线程多的，相同时间内，能够被分到CPU的概率大一些，执行起来会快一些。因此多线程能够提高程序的执行效率。</li></ul></blockquote> <h2 id="四、linux下线程的『实现原理』"><a href="#四、linux下线程的『实现原理』" class="header-anchor">#</a> 四、Linux下线程的『实现原理』</h2> <blockquote><ul><li>1）创建线程使用的底层函数和进程一样，都是clone
就是说，pthead_create和fork底层都是调用clone函数。</li> <li>2）从内核（操作系统来看）里看进程和线程是一样的,都有各自不同的PCB，但是<strong>PCB中指向内存资源的三级页表是相同的</strong></li></ul> <blockquote><ul><li>因为操作系统区分进程和线程，以PCB作为区分依据，PCB叫做进程控制块/进程描述符，，正是因为这个PCB的这个，因此把PCB分配给一个线程，他就伪装成一个进程，因此CPU在分配时间片的时候，他才会把一个线程也分配一个自己的时间片,加快执行效率。（根本原因：因为，内部在实现的时候，有一个关于内存映射的这样一个问题）</li></ul></blockquote></blockquote> <h3 id="_1）三级页表"><a href="#_1）三级页表" class="header-anchor">#</a> 1）三级页表</h3> <p>什么叫三级页表?</p> <img src="https://gitee.com/HACV/images_bed/raw/master/MainBlog/2020/2020_07/07_21/01.png"> <p>有的指针指向一个空间，我们叫页表。
如图，一个个目录项都是一个指针。
如上图，上面采用的三级映射的方法，4个东西，整个称之为3级页表。
三级映射和我们之前讲过的
虚拟内存和物理内存映射是什么关系？？
我们上面的，三级页表实际上就是在描述，MMU怎么样帮你把虚拟地址，映射到物理地址！！
上面的是简略的图，实际上的不能直接从用户空间对应过去。
MMU有个映射表，显然这个会和我们的三级页表进行对应，其实，映射表是保存在内核空间的。</p> <p><strong>注意图片中，新建的线程，虽然PCB是和前面的进程独立的，但是那个指针还是一样的（注意）</strong></p> <p>线程与线程之间，肯定整个地址空间不会完全相同，最起码要保证运行指令不一样。（不然，你复制有意义吗？）</p> <blockquote><ul><li>线程可看做『寄存器和栈』的集合（栈，线程在执行过程中，我们执行的主要依据是：函数调用，因为线程1和2内部的函数是不一样的）
<font size="5" style="background:yellow;"><strong>注意，强调了栈</strong></font></li></ul></blockquote> <p>实际上分配空间，就是两个指针，esp和ebp的移动。
原先是重合，后面慢慢拉开，形成栈帧（帧，一张张，我们知道，每一个函数有属于自己运行的栈帧空间）</p> <p>（注意：栈帧里面放局部变量和<strong>临时值</strong>（比如，某函数被调用，那他要<strong>保留，原先的ebp和esp</strong>，这样这个函数被调用完之后，才能返回去））</p> <p>如上分析：
每一个线程在调用的时候，都有自己的函数调用。那么<strong>每一个线程的stack空间（用户空间中的栈），不能一样</strong>。不然，线程与线程之间，无法区分。</p> <p>上面的内核区，其实还有内核栈，它的作用，主要是用来保存寄存器的值。
什么时候需要保存？？<strong>进程在要切换</strong>的时候，因为CPU要把时间轮片分给不同的进程。
现在变成线程的概念，现在CPU要把这个分配给线程运行，那么线程需不需要保存寄存器的值？显然需要，所以，显然线程需要有属于自己的内核栈空间。
（所以，能理解寄存器和栈那些了）</p> <p>Linux下CPU划分时间轮片，是依据什么？
lwp号（其实叫，轻量级线程，但是我们也可以叫，线程号，，）</p> <p>Linux下命令</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">ps</span> -Lf <span class="token number">3500</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>比如，这样，能知道3500这个进程下有哪些线程？</p> <p>比如，Firefox里面采用的<strong>线程池</strong>机制，同时开了好多个。
所以，可能我们只打开了几个页面，却发现有好多个线程。</p> <p><font style="background:yellow;">lwp是线程号，但是不是线程id，注意</font></p> <blockquote><ul><li><strong>线程号</strong>的作用：CPU分配时间仑片的作用</li> <li><strong>线程id</strong>的作用：是进程内部区分线程的!!!!</li></ul></blockquote> <p>同一个进程中的线程，他们的PCB虽然是不一样的，但是其中的三级页表却是相同的。</p> <h3 id="_2）线程优点和缺点"><a href="#_2）线程优点和缺点" class="header-anchor">#</a> 2）线程优点和缺点</h3> <blockquote><ul><li>线程<strong>共享</strong>资源
1.文件描述符表
2.每种信号的处理方式（由于，线程和信号都很麻烦，编程的时候，能够减少他们合体就尽量避免——</li></ul> <blockquote><ul><li>信号和进程是早期就有的，但信号复杂，线程是后期才有的。
3.当前工作目录（工作目录是根据进程定的）
4.用户ID和组ID
5.<strong>内存地址空间 (.text/.data/.bss/heap/共享库)</strong>，0-3G就把那个stack给排除了。</li></ul></blockquote> <ul><li>线程<strong>非共享</strong>资源
1.线程id
2.处理器现场（即，寄存器的值）和栈指针(内核栈)
3.独立的栈空间(用户空间栈)
4.<strong>errno变量</strong>（这个变量，是个全局变量，是放在.data段，但是，他很特殊，每个线程独享。注意！！）
5.信号屏蔽字（毕竟，线程概念是后面来的）
6.<strong>调度优先级</strong></li></ul></blockquote> <p>线程优、缺点
优点：
1.提高程序并发性
2.开销小（开10个线程比开10个进程小）
3.数据通信、共享数据方便（如前分析，比如，我们进程之间通信用IPC，现在我们线程都不需要这个了，比如全局变量，只见拿过来用）
缺点：
1.库函数，不稳定（线程里面，所有的函数都是库函数，所以说，对于第3方库函数而言，相较于进程而言，我们在进程当中，使用的函数，绝大多数都是系统调用，稳定性高一些，，但是线程的库函数的稳定性却没那么高）
2.调试、编写困难、gdb不支持（别的不说，gdb你在线程里面就别用了，用也用不了，因为gdb出现的时候，线程概念还没出现，，，，）（有第3方开发工具，就用它调试，没有就靠自己手工切，滑稽，其实可以加输出，其实高手调试的时候，都是直接加printf来，一般不用调试工具，这个调试方法，永远有效）
3.对信号支持不好（毕竟，线程概念出现比较晚）</p> <p>优点相对突出，缺点均不是硬伤。Linux下由于实现方法导致进程、线程差别不是很大。</p> <p>所以，从熟识度来说，可能用进程编程的人多一些
但是，从程序角度，用线程。</p> <h2 id="三、线程控制原语"><a href="#三、线程控制原语" class="header-anchor">#</a> 三、线程控制原语</h2> <h3 id="_1）pthread-self函数（获得线程id）"><a href="#_1）pthread-self函数（获得线程id）" class="header-anchor">#</a> 1）pthread_self函数（获得线程ID）</h3> <p>获取<strong>线程ID</strong>
对应进程中 getpid() 函数</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>pthread_t pthread_self(void);	返回值：成功：0；	失败：无！
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>线程ID：pthread_t类型，本质：在Linux下为无符号整数(%lu)，其他系统中可能是结构体实现
线程ID是进程内部，识别标志。(两个进程间，线程ID允许相同)
注意：不应使用全局变量 pthread_t tid，在子线程中通过pthread_create传出参数来获取线程ID，而应使用pthread_self。</p> <p>我们安装的man page起作用了</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code><span class="token function">man</span> pthread_self
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><div class="language-txt line-numbers-mode"><pre class="language-text"><code>PTHREAD_SELF(3)                       Linux Programmer's Manual                      PTHREAD_SELF(3)
NAME
       pthread_self - obtain ID of the calling thread
SYNOPSIS
       #include &lt;pthread.h&gt;
       pthread_t pthread_self(void);
       Compile and link with -pthread.
       //这句话告诉，gcc编译，链接使用-pthread才能编译通过
       //原因：从某种角度来讲，我们的线程库不是标准库，不是大家经常使用的标准C库了。
       //gcc编译的时候却是在给我们链接标准C库。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><h3 id="_2）pthread-create函数（创建线程）"><a href="#_2）pthread-create函数（创建线程）" class="header-anchor">#</a> 2）pthread_create函数（创建线程）</h3> <p>创建一个新线程。
其作用，对应进程中fork() 函数。</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>	int pthread_create(pthread_t *thread, const pthread_attr_t *attr, void *(*start_routine) (void *), void *arg);
	返回值：成功：0；	失败：错误号	-----Linux环境下，所有线程特点，失败均直接返回错误号。（这是和进程不同的地方）
    可以借助下面的
    strerror函数很简单，参数要接受一个错误号，帮你把这个错误号，转换为错误字符串描述。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>参数：
pthread_t：当前Linux中可理解为：typedef  unsigned long int  pthread_t;
参数1：传出参数，保存系统为我们分配好的线程ID
参数2：通常传NULL，表示使用线程默认属性。若想使用具体属性也可以修改该参数。（一般使用，NULL表示线程的默认属性）
参数3：函数指针，指向线程主函数(线程体)，该函数运行结束，则线程结束。
参数4：线程主函数执行期间所使用的参数。</p> <p>我们写一个函数测试一下</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;string.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token punctuation">{</span>
    <span class="token keyword">char</span> ch<span class="token punctuation">;</span>
    <span class="token keyword">int</span> var<span class="token punctuation">;</span>
    <span class="token keyword">char</span> str<span class="token punctuation">[</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token class-name">exit_t</span><span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">thrd_func</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">exit_t</span> <span class="token operator">*</span>retvar <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">exit_t</span> <span class="token operator">*</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>

    retvar<span class="token operator">-&gt;</span>ch <span class="token operator">=</span> <span class="token string">'m'</span><span class="token punctuation">;</span>
    retvar<span class="token operator">-&gt;</span>var <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span>
    <span class="token function">strcpy</span><span class="token punctuation">(</span>retvar<span class="token operator">-&gt;</span>str<span class="token punctuation">,</span> <span class="token string">&quot;my thread&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>retvar<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">;</span>
    <span class="token keyword">int</span> ret<span class="token punctuation">;</span>
    <span class="token class-name">exit_t</span> <span class="token operator">*</span>retval <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token class-name">exit_t</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    ret <span class="token operator">=</span> <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> thrd_func<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>ret <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">fprintf</span><span class="token punctuation">(</span><span class="token constant">stderr</span><span class="token punctuation">,</span> <span class="token string">&quot;pthread_create error:%s\n&quot;</span><span class="token punctuation">,</span> <span class="token function">strerror</span><span class="token punctuation">(</span>ret<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">exit</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token operator">&amp;</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;ch = %c, var = %d, str = %s\n&quot;</span><span class="token punctuation">,</span> retval<span class="token operator">-&gt;</span>ch<span class="token punctuation">,</span> retval<span class="token operator">-&gt;</span>var<span class="token punctuation">,</span> retval<span class="token operator">-&gt;</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">free</span><span class="token punctuation">(</span>retval<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_exit</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>注意链接的时候记得加上</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>[略~]# gcc -pthread te.c
[略 ~]# ls
a.out  solution.cpp  te.c  test.c
[略 ~]# ./a.out
ch = m, var = 200, str = my thread
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>线程之间共享全局变量
进程之间全局变量是不共享的，所以才有的IPC。</p> <h3 id="_3）pthread-exit函数（退出线程）"><a href="#_3）pthread-exit函数（退出线程）" class="header-anchor">#</a> 3）pthread_exit函数（退出线程）</h3> <p>将单个线程退出</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>void pthread_exit(void *retval);	参数：retval表示线程退出状态，通常传NULL
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_4）pthread-join函数（用于，线程回收）"><a href="#_4）pthread-join函数（用于，线程回收）" class="header-anchor">#</a> 4）pthread_join函数（用于，线程回收）</h3> <p>阻塞等待线程退出，获取线程退出状态
其作用，对应进程中 waitpid() 函数。</p> <h3 id="_5）pthread-detach函数（线程分离）"><a href="#_5）pthread-detach函数（线程分离）" class="header-anchor">#</a> 5）pthread_detach函数（线程分离）</h3> <p>这个函数在进程当中没有对应的
实现<strong>线程分离</strong></p> <pre><code>int pthread_detach(pthread_t thread);	成功：0；失败：错误号
线程分离状态：指定该状态，线程主动与主控线程断开关系。线程结束后，其退出状态不由其他线程获取，而直接自己自动释放。
&lt;font style=&quot;background: yellow&quot; size=5&gt;网络、多线程服务器常用。(很重要，因为状态分离后就不会产生僵尸进程了）&lt;/font&gt;
</code></pre> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>从状态上实现了分离，好处如下：
进程若有该机制，将不会产生僵尸进程。僵尸进程的产生主要由于进程死后，大部分资源被释放，一点残留资源仍存于系统中，导致内核认为该进程仍存在。
因此在，网络、多线程服务器常用。
也可使用 pthread_create函数参2(线程属性)来设置线程分离。
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>记得有书上说，虽说理论上，线程创建好之后，就和父进程在等同的地位上抢夺CPU
但是这个繁复做实验，发现，一般情况下是<strong>主控线程</strong>先执行，一般线程后执行。当然，只是科普，不敢这么写代码</p> <h3 id="_6）pthread-cancel函数（杀死线程）"><a href="#_6）pthread-cancel函数（杀死线程）" class="header-anchor">#</a> 6）pthread_cancel函数（杀死线程）</h3> <p>杀死(取消)线程
其作用，对应进程中 kill() 函数。</p> <p>kill是通过通过发信号杀死的，但是线程的这个函数杀死成功率很高。</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>int pthread_cancel(pthread_t thread);	成功：0；失败：错误号
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_7）pthread-equal函数（判断进程id相等）"><a href="#_7）pthread-equal函数（判断进程id相等）" class="header-anchor">#</a> 7）pthread_equal函数（判断进程ID相等）</h3> <p>现在的Linux操作系统中，这个函数没神马用，现在ID都是整数，之间数学比较就好了
以前，pthread_t是为了以后可能的扩展，比如现在是int,以后是结构体。</p> <p>比较两个线程ID是否相等。</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>int pthread_equal(pthread_t t1, pthread_t t2);
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>有可能Linux在未来线程ID pthread_t 类型被修改为结构体实现。</p> <h2 id="控制原语对比"><a href="#控制原语对比" class="header-anchor">#</a> 控制原语对比</h2> <table><thead><tr><th>进程</th> <th>线程</th></tr></thead> <tbody><tr><td>fork</td> <td>pthread_create</td></tr> <tr><td>exit</td> <td>pthread_exit</td></tr> <tr><td>wait</td> <td>pthread_join</td></tr> <tr><td>kill</td> <td>pthread_cancel</td></tr> <tr><td>getpid</td> <td>pthread_self		命名空间</td></tr></tbody></table> <h2 id="四、线程属性"><a href="#四、线程属性" class="header-anchor">#</a> 四、线程属性</h2> <p>一般情况下，实际上我们在做开发的时候，我们线程的默认属性是能够满足我们大多数情况下的需求的。
极个别的时候，线程的默认属性不满足，就需要我们自己来设定。</p> <blockquote><ul><li>如我们对程序的性能提出更高的要求那么需要设置线程属性，比如可以通过设置线程<strong>栈的大小</strong>来降低内存的使用，增加最大线程个数。</li></ul></blockquote> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>typedef struct
{
int 					etachstate; 	//线程的分离状态
int 					schedpolicy; 	//线程调度策略
struct sched_param	schedparam; 	//线程的调度参数
int 					inheritsched; 	//线程的继承性
int 					scope; 		//线程的作用域
size_t 				guardsize; 	//线程栈末尾的警戒缓冲区大小
int					stackaddr_set; //线程的栈设置
void* 				stackaddr; 	//线程栈的位置
size_t 				stacksize; 	//线程栈的大小
} pthread_attr_t;
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><h2 id="五、线程库版本（nptl实现机制-posix-，native-posix-thread-library）"><a href="#五、线程库版本（nptl实现机制-posix-，native-posix-thread-library）" class="header-anchor">#</a> 五、线程库版本（NPTL实现机制(POSIX)，Native POSIX Thread Library）</h2> <p>所谓NPTL就是你需要在使用线程的时候，注意一下使用的线程库的版本是什么。（原因是，我们编写的程序，可能<strong>跨平台开发</strong>）
<strong>（库的版本不一样，可能导致程序运行失败，甚至异常）</strong></p> <p>我们先前用的都是<code>POSIX标准</code>下面所<strong>默认推荐的线程库。</strong></p> <p>我们知道Linux下面，都是GNU组织给我们提供的lib库
你用这个可以查询当前库的版本</p> <p>1.察看当前pthread库版本</p> <div class="language-bash line-numbers-mode"><pre class="language-bash"><code>getconf GNU_LIBPTHREAD_VERSION
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>比如我的阿里云服务器</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>[略 ~]# getconf GNU_LIBPTHREAD_VERSION
NPTL 2.28
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>2.<strong>NPTL实现机制(POSIX)，Native POSIX Thread Library</strong>
3.使用线程库时gcc指定 –lpthread</p> <p>线程使用注意事项
1.主线程退出其他线程不退出，主线程应调用pthread_exit
2.避免僵尸线程
pthread_join
pthread_detach
pthread_create指定分离属性
被join线程可能在join函数返回前就释放完自己的所有内存资源，所以不应当返回被回收线程栈中的值;
3.<strong>malloc和mmap申请的内存可以被其他线程释放</strong>
4.应避免在多线程模型中调用fork除非，马上exec，子进程中只有调用fork的线程存在，其他线程在子进程中均pthread_exit
5.<strong>信号的复杂语义很难和多线程共存，应避免在多线程引入信号机制</strong></p> <p>title:  Linux系统——线程同步+进程同步
date: 2020-07-22 09:00:00
categories:</p> <ul><li>操作系统
tags:</li> <li>Linux</li></ul> <p>img: /photos/2020.6.03_15/2020_06_01_cover.jpg
top: false
summary: linux下锁机制</p> <h1 id="线程同步"><a href="#线程同步" class="header-anchor">#</a> 线程同步</h1> <p>主控线程
子线程</p> <h3 id="内容"><a href="#内容" class="header-anchor">#</a> 内容</h3> <p>主要内容，线程同步。</p> <p>======
本章讲到的和<strong>线程</strong>相关的锁有4种。
1）互斥量(互斥锁)
2）读写锁
3）条件变量（线程当中一种常见的锁机制）
4）信号量：互斥量升级版
就是上面这4种</p> <blockquote><ul><li>同步概念：（区分，生活和编程中的同步的区别）
同步
线程同步</li></ul></blockquote> <blockquote><ul><li>1）互斥量(互斥锁):
一系列函数：都是以pthread_mutex开头,重点，如何应用这些函数对一个变量进行加锁访问。
pthread_mutex_init
_destroy
_lock
_unlock</li></ul></blockquote> <blockquote><ul><li>2)读写锁：
一系列函数都是以pthread_rwlock_开头的
pthread_rwlock_</li></ul></blockquote> <blockquote><ul><li>3)条件变量：
一系列函数为pthread_cond_开头的
pthread_cond_xxxx
pthread_cond_wait();函数（这是一个学习这部分的重点，而且这个函数也是条件变量的难点）
绝对时间：   1970/1/1  00:00:00  --- unix 计时元年。
time_t cur = time(NULL);
strcut timespec t;
t.tv_sec = cur + 10;
pthread_cond_timedwait(&amp;cond, &amp;mutex, &amp;t);</li></ul></blockquote> <blockquote><ul><li>4)信号量：是互斥量升级版
一系列函数为sem_开头的
发现，少了那个pthread关键字，所以说，信号量不单单能用于线程间同步，还能用于进程间同步！
sem_</li></ul></blockquote> <h2 id="进程间同步的几种方法"><a href="#进程间同步的几种方法" class="header-anchor">#</a> 进程间同步的几种方法</h2> <p>1）信号量（Semaphore）
一系列函数为sem_开头的
2）文件锁
3）互斥量和信号量联合的一种方式</p> <h2 id="哲学家吃饭问题："><a href="#哲学家吃饭问题：" class="header-anchor">#</a> 哲学家吃饭问题：</h2> <p>1）线程版本
2）进程版本</p> <h2 id="一、同步的概念"><a href="#一、同步的概念" class="header-anchor">#</a> 一、同步的概念</h2> <p>所谓同步，即同时起步，协调一致。不同的对象，对“同步”的理解方式略有不同。
如，<strong>硬件</strong>上的设备，设备同步，是指在两个设备之间规定一个共同的时间参考；
<strong>数据库同步</strong>，是指让两个或多个数据库内容保持一致，或者按需要部分保持一致；
<strong>文件同步</strong>，是指让两个或多个文件夹里的文件保持一致。等等.</p> <blockquote><ul><li>而，<strong>编程中、通信中</strong>所说的同步与生活中大家印象中的同步概念略有差异。
“同”字应是指<strong>协同、协助、互相配合</strong>。
主旨在协同步调，按预定的先后次序运行。</li></ul></blockquote> <p>各个行业，对同步的理解方式是不一样的！！！</p> <p>线程同步，官方说法
线程同步，指一个线程发出某一功能调用时，在没有得到结果之前，该调用不返回。同时其它线程为<strong>保证数据一致性</strong>，不能调用该功能。</p> <p>不同的对象，对同一个数据同时进行操作，这个数据，我们称为共享数据或者叫共享资源。</p> <p>注意：
a,b,c都是一个进程中的线程
假设a和b都拿锁去访问，而c不拿锁就去直接访问
能不能成功？？
可以的，因为他们都共享那个变量
（但是这样会导致出现错误）
这把锁不具有强制性！！！</p> <p>在Linux，用户层面上编程所用到的所有的锁，我们都把他称之为<strong>建议锁</strong>。
所以这个，指的是Linux内核建议你在访问共享数据的时候，加一把锁再访问。是否具有强制性？？
不具有！！！
<font size="5" style="background:yellow;">因此访问共享数据的所有线程，要想保证数据不出现混乱。
都应该先加锁后访问才行！！！</font></p> <p>如果像前面那样的，直接访问，会导致数据尴尬的。</p> <p>描述的锁，如何在应用程序中表示出来呢？就需要一个变量表示出来。这个变量叫做互斥量（或者互斥锁）</p> <h2 id="二、互斥量mutex（互斥锁）"><a href="#二、互斥量mutex（互斥锁）" class="header-anchor">#</a> 二、互斥量mutex（互斥锁）</h2> <p>Linux中提供一把互斥锁mutex（也称之为互斥量）。
每个线程在对资源操作前都尝试先加锁，成功加锁才能操作，操作结束解锁。
资源还是共享的，线程间也还是竞争的，
但通过“锁”就将资源的访问变成<strong>互斥</strong>操作，而后与时间有关的错误也不会再产生了。</p> <p>主要应用函数：</p> <h3 id="_1）pthread-mutex-init函数"><a href="#_1）pthread-mutex-init函数" class="header-anchor">#</a> 1）pthread_mutex_init函数</h3> <p>将互斥量初始化</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>restrict mutex<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_mutexattr_t</span> <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>注意到上面有个关键字：
<font size="5" style="background:yellow;"><strong>restrict关键字</strong></font>：只用于限制指针，告诉编译器，所有修改该指针指向内存中内容的操作，<strong>只能通过本指针完成</strong>。不能通过除本指针以外的其他变量或指针修改</p> <h3 id="_2）pthread-mutex-destroy函数"><a href="#_2）pthread-mutex-destroy函数" class="header-anchor">#</a> 2）pthread_mutex_destroy函数</h3> <p>互斥量销毁</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>	<span class="token keyword">int</span> <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_3）pthread-mutex-lock函数"><a href="#_3）pthread-mutex-lock函数" class="header-anchor">#</a> 3）pthread_mutex_lock函数</h3> <p>互斥量加锁</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><h3 id="_4）pthread-mutex-trylock函数"><a href="#_4）pthread-mutex-trylock函数" class="header-anchor">#</a> 4）pthread_mutex_trylock函数</h3> <p>这个是，尝试加锁，如果成功则锁上，否则直接返回（不会阻塞等待）
返回的这些，我可以干其他事情，我可以过个几秒再来一次加锁
显然，要想用这个，我们需要，轮询（周期性的尝试加锁）</p> <p>而互斥量加锁，却要阻塞等待</p> <h3 id="_5）pthread-mutex-unlock函数"><a href="#_5）pthread-mutex-unlock函数" class="header-anchor">#</a> 5）pthread_mutex_unlock函数</h3> <p>互斥量解锁</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>以上5个函数的返回值都是：成功返回0， 失败返回错误号。</p> <h3 id="以上所有函数，要用的数据类型"><a href="#以上所有函数，要用的数据类型" class="header-anchor">#</a> 以上所有函数，要用的数据类型</h3> <p><code>pthread_mutex_t</code> 类型，其本质是一个结构体。
为简化理解，应用时可忽略其实现细节，简单当成整数看待。
可以简单看待，初始化完成后，取值为1，加锁成功，值由1--变成0
解锁成功，这个值由0++变成1
（两种取值）</p> <p>pthread_mutex_t mutex;
变量mutex只有两种取值1、0。</p> <h2 id="先置结论-死锁"><a href="#先置结论-死锁" class="header-anchor">#</a> 先置结论+死锁</h2> <p>在访问共享资源前加锁，访问结束后<strong>立即解锁</strong>。<strong>锁的“粒度”应越小越好</strong>。</p> <p>死锁：
我们的线程在使用互斥量，或者其他同步机制过程当中，出现的一种现象。而不是锁的一种机制。
（我记得，我学的操作系统中，线程和进程都有死锁现象把。。）</p> <p>比如下面两种死锁</p> <ol><li>线程试图对同一个互斥量A加锁两次。（解决方案：加锁完，立即解锁）</li> <li>线程1拥有A锁，请求获得B锁；线程2拥有B锁，请求获得A锁（解决方案：trylock尝试加锁，就不会阻塞了）（当不能获取所有的锁的时候，放弃已经占有的所有的锁）</li></ol> <h2 id="三、读写锁"><a href="#三、读写锁" class="header-anchor">#</a> 三、读写锁</h2> <p>读写锁（相较于互斥锁来说，性能稍微高一些）</p> <p><font size="5" style="background:yellow;">注意：读写锁，锁只有一把，不是两把</font>
与互斥量类似，但读写锁允许<strong>更高的并行性</strong>。
其特性为：写独占，读共享</p> <p>这把锁，既可以用“读”的方式对变量加锁，而且还能以“写”的方式对变量加锁</p> <h3 id="读写锁状态："><a href="#读写锁状态：" class="header-anchor">#</a> 读写锁状态：</h3> <p>一把读写锁具备三种状态：</p> <ol><li>读模式下加锁状态 (读锁)</li> <li>写模式下加锁状态 (写锁)</li> <li>不加锁状态</li></ol> <p>掌握读写锁，记住下面就好了：
写锁优先级高，写独占、读共享</p> <h3 id="读写锁特性："><a href="#读写锁特性：" class="header-anchor">#</a> 读写锁特性：</h3> <p>1.读写锁是“写模式加锁”时， 解锁前，所有对该锁加锁的线程都会被阻塞。
2.读写锁是“读模式加锁”时， 如果线程以读模式对其加锁会成功；如果线程以写模式加锁会阻塞。
3.读写锁是“读模式加锁”时， 既有试图以写模式加锁的线程，也有试图以读模式加锁的线程。那么读写锁会阻塞随后的读模式锁请求。优先满足写模式锁。读锁、写锁并行阻塞，<strong>写锁优先级高</strong></p> <p><font size="5" style="background:yellow;">读写锁也叫<strong>共享-独占锁</strong>。</font>
当读写锁以读模式锁住时，它是以共享模式锁住的；当它以写模式锁住时，它是以独占模式锁住的。<strong>写独占、读共享。</strong>
读写锁非常适合于对数据结构读的次数远大于写的情况。</p> <h3 id="_1）pthread-rwlock-init函数"><a href="#_1）pthread-rwlock-init函数" class="header-anchor">#</a> 1）pthread_rwlock_init函数</h3> <p>初始化一把读写锁</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code>	<span class="token keyword">int</span> <span class="token function">pthread_rwlock_init</span><span class="token punctuation">(</span><span class="token class-name">pthread_rwlock_t</span> <span class="token operator">*</span>restrict rwlock<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token class-name">pthread_rwlockattr_t</span> <span class="token operator">*</span>restrict attr<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参2：attr表读写锁属性，通常使用默认属性，传NULL即可。</p> <h3 id="_2）pthread-rwlock-destroy函数"><a href="#_2）pthread-rwlock-destroy函数" class="header-anchor">#</a> 2）pthread_rwlock_destroy函数</h3> <h3 id="_3）pthread-rwlock-rdlock函数"><a href="#_3）pthread-rwlock-rdlock函数" class="header-anchor">#</a> 3）pthread_rwlock_rdlock函数</h3> <h3 id="_4）pthread-rwlock-wrlock函数"><a href="#_4）pthread-rwlock-wrlock函数" class="header-anchor">#</a> 4）pthread_rwlock_wrlock函数</h3> <h3 id="_5）pthread-rwlock-tryrdlock函数"><a href="#_5）pthread-rwlock-tryrdlock函数" class="header-anchor">#</a> 5）pthread_rwlock_tryrdlock函数</h3> <h3 id="_6）pthread-rwlock-trywrlock函数"><a href="#_6）pthread-rwlock-trywrlock函数" class="header-anchor">#</a> 6）pthread_rwlock_trywrlock函数</h3> <h3 id="_7）pthread-rwlock-unlock函数"><a href="#_7）pthread-rwlock-unlock函数" class="header-anchor">#</a> 7）pthread_rwlock_unlock函数</h3> <p>以上7 个函数的返回值都是：成功返回0， 失败直接返回错误号。</p> <p>pthread_rwlock_t类型	用于定义一个读写锁变量。
pthread_rwlock_t rwlock;</p> <p>看如下示例，同时有多个线程对同一全局数据读、写操作。</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword">int</span> counter<span class="token punctuation">;</span>
<span class="token class-name">pthread_rwlock_t</span> rwlock<span class="token punctuation">;</span>

<span class="token comment">/* 3个线程不定时写同一全局资源，5个线程不定时读同一全局资源 */</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">th_write</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> t<span class="token punctuation">,</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_rwlock_wrlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        t <span class="token operator">=</span> counter<span class="token punctuation">;</span>
        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;=======write %d: %lu: counter=%d ++counter=%d\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> t<span class="token punctuation">,</span> <span class="token operator">++</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">10000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">th_read</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>arg<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span>arg<span class="token punctuation">;</span>

    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_rwlock_rdlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;----------------------------read %d: %lu: %d\n&quot;</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> <span class="token function">pthread_self</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> counter<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">pthread_rwlock_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">usleep</span><span class="token punctuation">(</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> <span class="token constant">NULL</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> i<span class="token punctuation">;</span>
    <span class="token class-name">pthread_t</span> tid<span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token function">pthread_rwlock_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">3</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> th_write<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>tid<span class="token punctuation">[</span>i<span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> th_read<span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span><span class="token punctuation">)</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>
        <span class="token function">pthread_join</span><span class="token punctuation">(</span>tid<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_rwlock_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>rwlock<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br></div></div><h2 id="四、条件变量（条件变量本身不是锁！）"><a href="#四、条件变量（条件变量本身不是锁！）" class="header-anchor">#</a> 四、条件变量（条件变量本身不是锁！）</h2> <p>条件变量：（一定要满足某个条件，才能咋咋咋样）
条件变量本身不是锁！但它也可以造成线程阻塞。
<strong>通常与互斥锁配合使用</strong>。给多线程提供一个会合的场所。</p> <p>会合的场所：指的共享数据</p> <p>主要应用函数：</p> <h3 id="_1）pthread-cond-init函数"><a href="#_1）pthread-cond-init函数" class="header-anchor">#</a> 1）pthread_cond_init函数</h3> <h3 id="_2）pthread-cond-destroy函数"><a href="#_2）pthread-cond-destroy函数" class="header-anchor">#</a> 2）pthread_cond_destroy函数</h3> <h3 id="_3）pthread-cond-wait函数（难点）"><a href="#_3）pthread-cond-wait函数（难点）" class="header-anchor">#</a> 3）pthread_cond_wait函数（难点）</h3> <p>它可以干3件事情
阻塞等待一个条件变量</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token class-name">pthread_cond_t</span> <span class="token operator">*</span>restrict cond<span class="token punctuation">,</span> <span class="token class-name">pthread_mutex_t</span> <span class="token operator">*</span>restrict mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>函数作用：
1.阻塞等待条件变量cond（参1）满足
2.释放已掌握的互斥锁（解锁互斥量）相当于pthread_mutex_unlock(&amp;mutex);
** 1.2.两步为一个原子操作。**
3.<strong>当被唤醒</strong>，pthread_cond_wait函数返回时，解除阻塞并重新申请获取互斥锁pthread_mutex_lock(&amp;mutex);</p> <p>谁来唤醒？？
<code>pthread_cond_signal</code>函数
唤醒至少一个阻塞在条件变量上的线程</p> <p><code>pthread_cond_broadcast</code>函数（broadcast，广播，计算机网络，网络编程中也讲这个）
唤醒全部阻塞在条件变量上的线程</p> <h3 id="_4）pthread-cond-timedwait函数"><a href="#_4）pthread-cond-timedwait函数" class="header-anchor">#</a> 4）pthread_cond_timedwait函数</h3> <h3 id="_5）pthread-cond-signal函数"><a href="#_5）pthread-cond-signal函数" class="header-anchor">#</a> 5）pthread_cond_signal函数</h3> <h3 id="_6）pthread-cond-broadcast函数"><a href="#_6）pthread-cond-broadcast函数" class="header-anchor">#</a> 6）pthread_cond_broadcast函数</h3> <p>以上6 个函数的返回值都是：成功返回0， 失败直接返回错误号。</p> <p>pthread_cond_t类型	用于定义条件变量
pthread_cond_t cond;</p> <p>应用场景呢？？</p> <h3 id="线程同步—“生产者消费者”条件变量模型"><a href="#线程同步—“生产者消费者”条件变量模型" class="header-anchor">#</a> 线程同步—“生产者消费者”条件变量模型</h3> <p>线程同步中最最知名的一个模型。
只要提到，几乎都会提到这个模型。</p> <blockquote><ul><li>假定有两个线程，一个模拟生产者行为，一个模拟消费者行为。
两个线程同时操作一个共享资源（一般称之为<strong>汇聚</strong>），生产向其中添加产品，消费者从中消费掉产品。</li></ul></blockquote> <p>显然，这个的条件变量就是：已经生产了产品</p> <p>看如下示例，使用条件变量模拟生产者、消费者问题：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdlib.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;unistd.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;pthread.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token operator">*</span>next<span class="token punctuation">;</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token operator">*</span>head<span class="token punctuation">;</span>

<span class="token class-name">pthread_cond_t</span> has_product <span class="token operator">=</span> PTHREAD_COND_INITIALIZER<span class="token punctuation">;</span>
<span class="token class-name">pthread_mutex_t</span> lock <span class="token operator">=</span> PTHREAD_MUTEX_INITIALIZER<span class="token punctuation">;</span>

<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">consumer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token operator">*</span>mp<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">while</span> <span class="token punctuation">(</span>head <span class="token operator">==</span> <span class="token constant">NULL</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment">//头指针为空,说明没有节点    可以为if吗</span>
            <span class="token function">pthread_cond_wait</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>has_product<span class="token punctuation">,</span> <span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        mp <span class="token operator">=</span> head<span class="token punctuation">;</span>      
        head <span class="token operator">=</span> mp<span class="token operator">-&gt;</span>next<span class="token punctuation">;</span>    			<span class="token comment">//模拟消费掉一个产品</span>
        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;-Consume ---%d\n&quot;</span><span class="token punctuation">,</span> mp<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">free</span><span class="token punctuation">(</span>mp<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">void</span> <span class="token operator">*</span><span class="token function">producer</span><span class="token punctuation">(</span><span class="token keyword">void</span> <span class="token operator">*</span>p<span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">struct</span> <span class="token class-name">msg</span> <span class="token operator">*</span>mp<span class="token punctuation">;</span>
    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        mp <span class="token operator">=</span> <span class="token function">malloc</span><span class="token punctuation">(</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token keyword">struct</span> <span class="token class-name">msg</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        mp<span class="token operator">-&gt;</span>num <span class="token operator">=</span> <span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">1000</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">//模拟生产一个产品</span>
        <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;-Produce ---%d\n&quot;</span><span class="token punctuation">,</span> mp<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>
        mp<span class="token operator">-&gt;</span>next <span class="token operator">=</span> head<span class="token punctuation">;</span>
        head <span class="token operator">=</span> mp<span class="token punctuation">;</span>
        <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>lock<span class="token punctuation">)</span><span class="token punctuation">;</span>

        <span class="token function">pthread_cond_signal</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>has_product<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//将等待在该条件变量上的一个线程唤醒</span>
        <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token function">rand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">int</span> argc<span class="token punctuation">,</span> <span class="token keyword">char</span> <span class="token operator">*</span>argv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token class-name">pthread_t</span> pid<span class="token punctuation">,</span> cid<span class="token punctuation">;</span>
    <span class="token function">srand</span><span class="token punctuation">(</span><span class="token function">time</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>pid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> producer<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_create</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>cid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">,</span> consumer<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_join</span><span class="token punctuation">(</span>pid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">pthread_join</span><span class="token punctuation">(</span>cid<span class="token punctuation">,</span> <span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br></div></div><h2 id="总结"><a href="#总结" class="header-anchor">#</a> 总结</h2> <p>互斥量在使用的时候，要注意把握一下，锁的**”粒度“**（或者叫做锁的“临界区”）
建议，锁的粒度（临界区）越小越好。
<font size="5" style="background:yellow;">此处和<code>《程序员的自我修养-链接，装载与库》</code>说的临界区咋不一样。。</font></p> <p>读写锁使用的场景：
如果对数据读的次数远远大于写的时候
但是，如果所有操作都是写的话。
用“读写锁”和“互斥量”没有区别。
但是，如果，读比写多，显然读写锁更好。</p> <h2 id="条件变量的优点：（为什么我们要引入这么多种锁的机制？？）"><a href="#条件变量的优点：（为什么我们要引入这么多种锁的机制？？）" class="header-anchor">#</a> 条件变量的优点：（为什么我们要引入这么多种锁的机制？？）</h2> <p><font size="3" style="background:yellow;">为什么我们要引入这么多种锁的机制？？最开始的互斥锁，不是已经可以完成保护数据的目的了吗？为什么还要引入读写锁呢？因为在读比写更多的场景，读写锁的效率比互斥锁高。那又为什么要引入条件变量呢？<strong>因为条件变量相对于我们的互斥量而言，它也可以减少一些不必要的竞争啊</strong>
原因如下：
相较于mutex而言，条件变量可以减少竞争。</font></p> <p>如直接使用mutex，除了生产者、消费者之间要竞争互斥量以外，消费者之间也需要竞争互斥量，但<strong>如果汇聚（链表）中没有数据，消费者之间竞争互斥锁是无意义的</strong>。有了条件变量机制以后，只有生产者完成生产，才会引起消费者之间的竞争。提高了程序效率。</p> <h2 id="五、信号量"><a href="#五、信号量" class="header-anchor">#</a> 五、信号量</h2> <p>注意，信号和信号量没有关系。就像java和JavaScript没关系一样。</p> <p><font style="background:yellow;">信号量的初值，决定了占用信号量的线程的个数。</font></p> <p>信号量对于<strong>线程同步</strong>来说，可以把它理解成一个进化版的互斥锁。
比如，互斥量初始化之后是1，强调这个是为了给信号量做铺垫。
而我们的信号量初始化之后是N。</p> <p>原来，互斥锁，只能供1个线程同时使用
现在，信号量，可以指定成N个线程同时过来，获取这把锁。（<strong>提升了，共同访问共享资源的线程数量</strong>）
好比
买了量车，小轿车可以载4个人（带4个线程）
买了两人座的，那么可以载1人（带一个线程）</p> <p>进化版的互斥锁（1 --&gt; N）</p> <blockquote><ul><li>互斥锁的粒度比较大，如果我们希望在<strong>多个线程</strong>间对<strong>某一对象</strong>的<strong>部分数据</strong>进行共享，使用互斥锁是没有办法实现的，只能将整个数据对象锁住。这样虽然达到了多线程操作共享数据时保证数据正确性的目的，却无形中导致线程的并发性下降。线程从并行执行，变成了串行执行。与直接使用单进程无异。</li> <li><strong>信号量，是相对折中的一种处理方式，既能保证同步，数据不混乱，又能提高线程并发。</strong></li></ul></blockquote> <p>主要应用函数：</p> <h3 id="_1）sem-init函数"><a href="#_1）sem-init函数" class="header-anchor">#</a> 1）sem_init函数</h3> <p>初始化一个信号量</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">sem_init</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">int</span> pshared<span class="token punctuation">,</span> <span class="token keyword">unsigned</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参1：sem信号量	
参2：pshared取0用于线程间；取非0（一般为1）用于进程间
参3：value指定信号量初值</p> <h3 id="_2）sem-destroy函数"><a href="#_2）sem-destroy函数" class="header-anchor">#</a> 2）sem_destroy函数</h3> <h3 id="_3）sem-wait函数（相当于加锁，表示-）"><a href="#_3）sem-wait函数（相当于加锁，表示-）" class="header-anchor">#</a> 3）sem_wait函数（相当于加锁，表示--）</h3> <h3 id="_4）sem-trywait函数"><a href="#_4）sem-trywait函数" class="header-anchor">#</a> 4）sem_trywait函数</h3> <h3 id="_5）sem-timedwait函数"><a href="#_5）sem-timedwait函数" class="header-anchor">#</a> 5）sem_timedwait函数</h3> <p>限时尝试对信号量加锁</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">sem_timedwait</span><span class="token punctuation">(</span><span class="token class-name">sem_t</span> <span class="token operator">*</span>sem<span class="token punctuation">,</span> <span class="token keyword">const</span> <span class="token keyword">struct</span> <span class="token class-name">timespec</span> <span class="token operator">*</span>abs_timeout<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参2：abs_timeout采用的是绝对时间.</p> <h3 id="_6）sem-post函数（相当于解锁，表示-）"><a href="#_6）sem-post函数（相当于解锁，表示-）" class="header-anchor">#</a> 6）sem_post函数（相当于解锁，表示++）</h3> <p>以上6 个函数的返回值都是：成功返回0， 失败返回-1，同时设置errno。(注意，它们没有pthread前缀)
sem_t类型，本质仍是结构体。但应用期间可简单看作为整数，忽略实现细节（类似于使用文件描述符）。
sem_t sem; 规定信号量<code>sem不能&lt;0</code>
头文件<code>&lt;semaphore.h&gt;</code></p> <h3 id="“生产者消费者”-信号量（注意，比较条件变量下的模型）"><a href="#“生产者消费者”-信号量（注意，比较条件变量下的模型）" class="header-anchor">#</a> “生产者消费者”-信号量（注意，比较条件变量下的模型）</h3> <p>公共区域，用的“环形队列”</p> <h2 id="六、进程间同步"><a href="#六、进程间同步" class="header-anchor">#</a> 六、进程间同步</h2> <p>我们详细讲下面2种锁</p> <p>1）信号量
2）互斥量也可以
3）文件锁</p> <h3 id="互斥量"><a href="#互斥量" class="header-anchor">#</a> 互斥量</h3> <p>进程间也可以使用互斥锁，来达到同步的目的。但应在pthread_mutex_init初始化之前，修改其<strong>属性</strong>为进程间共享。mutex的属性修改函数主要有以下几个。</p> <p>主要应用函数：</p> <h4 id="_1）pthread-mutexattr-t-mattr-类型："><a href="#_1）pthread-mutexattr-t-mattr-类型：" class="header-anchor">#</a> 1）pthread_mutexattr_t mattr 类型：</h4> <p>用于定义mutex锁的【属性】</p> <h4 id="_2）pthread-mutexattr-init函数："><a href="#_2）pthread-mutexattr-init函数：" class="header-anchor">#</a> 2）pthread_mutexattr_init函数：</h4> <p>初始化一个mutex属性对象</p> <h4 id="_3）int-pthread-mutexattr-init-pthread-mutexattr-t-attr"><a href="#_3）int-pthread-mutexattr-init-pthread-mutexattr-t-attr" class="header-anchor">#</a> 3）int pthread_mutexattr_init(pthread_mutexattr_t *attr);</h4> <pre><code>pthread_mutexattr_destroy函数：		
销毁mutex属性对象 (而非销毁锁)
</code></pre> <h4 id="_4）int-pthread-mutexattr-destroy-pthread-mutexattr-t-attr"><a href="#_4）int-pthread-mutexattr-destroy-pthread-mutexattr-t-attr" class="header-anchor">#</a> 4）int pthread_mutexattr_destroy(pthread_mutexattr_t *attr);</h4> <h4 id="_5）pthread-mutexattr-setpshared函数：修改mutex属性。"><a href="#_5）pthread-mutexattr-setpshared函数：修改mutex属性。" class="header-anchor">#</a> 5）pthread_mutexattr_setpshared函数：	修改mutex属性。</h4> <h4 id="_6）int-pthread-mutexattr-setpshared-pthread-mutexattr-t-attr-int-pshared"><a href="#_6）int-pthread-mutexattr-setpshared-pthread-mutexattr-t-attr-int-pshared" class="header-anchor">#</a> 6）int pthread_mutexattr_setpshared(pthread_mutexattr_t *attr, int pshared);</h4> <p>参2：pshared取值：
线程锁：PTHREAD_PROCESS_PRIVATE (mutex的默认属性即为线程锁，进程间私有)
进程锁：PTHREAD_PROCESS_SHARED</p> <p>进程间使用mutex来实现同步：</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;fcntl.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;pthread.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/mman.h&gt;</span></span>
<span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span><span class="token string">&lt;sys/wait.h&gt;</span></span>

<span class="token keyword">struct</span> <span class="token class-name">mt</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> num<span class="token punctuation">;</span>
    <span class="token class-name">pthread_mutex_t</span> mutex<span class="token punctuation">;</span>
    <span class="token class-name">pthread_mutexattr_t</span> mutexattr<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token keyword">void</span><span class="token punctuation">)</span>
<span class="token punctuation">{</span>
    <span class="token keyword">int</span> fd<span class="token punctuation">,</span> i<span class="token punctuation">;</span>
    <span class="token keyword">struct</span> <span class="token class-name">mt</span> <span class="token operator">*</span>mm<span class="token punctuation">;</span>
    <span class="token class-name">pid_t</span> pid<span class="token punctuation">;</span>

    fd <span class="token operator">=</span> <span class="token function">open</span><span class="token punctuation">(</span><span class="token string">&quot;mt_test&quot;</span><span class="token punctuation">,</span> O_CREAT <span class="token operator">|</span> O_RDWR<span class="token punctuation">,</span> <span class="token number">0777</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">ftruncate</span><span class="token punctuation">(</span>fd<span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>mm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    mm <span class="token operator">=</span> <span class="token function">mmap</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>mm<span class="token punctuation">)</span><span class="token punctuation">,</span> PROT_READ<span class="token operator">|</span>PROT_WRITE<span class="token punctuation">,</span> MAP_SHARED<span class="token punctuation">,</span> fd<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">close</span><span class="token punctuation">(</span>fd<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">unlink</span><span class="token punctuation">(</span><span class="token string">&quot;mt_test&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//mm = mmap(NULL, sizeof(*mm), PROT_READ|PROT_WRITE, MAP_SHARED|MAP_ANON, -1, 0);</span>
    <span class="token function">memset</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>mm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

    <span class="token function">pthread_mutexattr_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutexattr<span class="token punctuation">)</span><span class="token punctuation">;</span>                                  <span class="token comment">//初始化mutex属性对象</span>
    <span class="token function">pthread_mutexattr_setpshared</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutexattr<span class="token punctuation">,</span> PTHREAD_PROCESS_SHARED<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//修改属性为进程间共享</span>
    <span class="token function">pthread_mutex_init</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutex<span class="token punctuation">,</span> <span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutexattr<span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//初始化一把mutex琐</span>

    pid <span class="token operator">=</span> <span class="token function">fork</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">(</span>mm<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span><span class="token operator">++</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;-child----num++   %d\n&quot;</span><span class="token punctuation">,</span> mm<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pid <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">pthread_mutex_lock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
            mm<span class="token operator">-&gt;</span>num <span class="token operator">+=</span> <span class="token number">2</span><span class="token punctuation">;</span>
            <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">&quot;-parent---num+=2  %d\n&quot;</span><span class="token punctuation">,</span> mm<span class="token operator">-&gt;</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token function">pthread_mutex_unlock</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">wait</span><span class="token punctuation">(</span><span class="token constant">NULL</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>

    <span class="token function">pthread_mutexattr_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutexattr<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment">//销毁mutex属性对象</span>
    <span class="token function">pthread_mutex_destroy</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>mm<span class="token operator">-&gt;</span>mutex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//销毁mutex</span>
    <span class="token function">munmap</span><span class="token punctuation">(</span>mm<span class="token punctuation">,</span><span class="token keyword">sizeof</span><span class="token punctuation">(</span><span class="token operator">*</span>mm<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                          <span class="token comment">//释放映射区</span>
    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>					
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br></div></div><h3 id="文件锁（借助fcntl函数来实现锁机制）"><a href="#文件锁（借助fcntl函数来实现锁机制）" class="header-anchor">#</a> 文件锁（借助fcntl函数来实现锁机制）</h3> <p>（记忆方法：file control）</p> <p>操作文件的进程没有获得锁时，可以打开，但无法执行read、write操作。
fcntl函数：获取、设置文件访问控制属性。</p> <p>我们以前用这个修改过，阻塞和非阻塞</p> <div class="language-c line-numbers-mode"><pre class="language-c"><code><span class="token keyword">int</span> <span class="token function">fcntl</span><span class="token punctuation">(</span><span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> cmd<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token comment">/* arg */</span> <span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br></div></div><p>参2：</p> <div class="language-txt line-numbers-mode"><pre class="language-text"><code>F_SETLK (struct flock *)	设置文件锁（trylock）
F_SETLKW (struct flock *) 设置文件锁（lock）W --&gt; wait
F_GETLK (struct flock *)	获取文件锁
</code></pre> <div class="line-numbers-wrapper"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>【思考】：多线程中，可以使用文件锁吗？
多线程间共享文件描述符，而给文件加锁，是通过修改文件描述符所指向的文件结构体中的成员变量来实现的。因此，多线程中无法使用文件锁。</p> <h2 id="哲学家用餐模型"><a href="#哲学家用餐模型" class="header-anchor">#</a> 哲学家用餐模型</h2> <p>振荡：如果每个人都攥着自己左手的锁，尝试去拿右手锁，拿不到则将锁释放。过会儿五个人又同时再攥着左手锁尝试拿右手锁，依然拿不到。如此往复形成另外一种极端死锁的现象——振荡。</p> <p>如何避免这种“震荡”的死锁？
避免振荡现象：只需5个人中，任意一个人，拿锁的方向与其他人相逆即可(如：E，原来：左：4，右：0	现在：左：0， 右：4)。</p> <p>（特立独行2333的哲学家）</p> <h3 id="_1）多线程版"><a href="#_1）多线程版" class="header-anchor">#</a> 1）多线程版</h3> <h3 id="_2）多进程版"><a href="#_2）多进程版" class="header-anchor">#</a> 2）多进程版</h3></div> <div class="page-edit"><!----> <!----></div> <!----> </div> <!----></div></div>
    <script src="/assets/js/app.c10be5f5.js" defer></script><script src="/assets/js/54.6f595df2.js" defer></script>
  </body>
</html>
